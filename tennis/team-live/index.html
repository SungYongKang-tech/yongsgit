<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸ¾ ê²½ê¸° ì§„í–‰ (team-live)</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --bd:#e6e8ef;
      --txt:#0f172a; --mut:#64748b; --r:16px;
      --accent:#2563eb; --ok:#16a34a; --danger:#ef4444;
      --shadow:0 10px 28px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;background:var(--bg);color:var(--txt)}
    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    h2{margin:6px 0 12px;font-size:16px;font-weight:950;text-align:center}

    .card{background:var(--card);border:1px solid var(--bd);border-radius:var(--r);box-shadow:var(--shadow);padding:12px;margin-bottom:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}
    .input, select{
      padding:10px 12px;border:1px solid var(--bd);border-radius:12px;background:#fff;font-size:14px
    }
    .btn{
      padding:10px 14px;border:1px solid rgba(37,99,235,.25);
      background:linear-gradient(180deg,#2b74ff,#2563eb);
      color:#fff;border-radius:12px;cursor:pointer;font-weight:950;
    }
    .btn.secondary{background:#fff;color:#0f172a;border:1px solid var(--bd)}
    .btn.ok{background:linear-gradient(180deg,#22c55e,#16a34a);border:1px solid rgba(22,163,74,.25)}
    .btn.danger{background:linear-gradient(180deg,#ff5a5a,#ef4444);border:1px solid rgba(239,68,68,.25)}

    .mut{color:var(--mut);font-weight:750;font-size:12px;margin-top:8px;text-align:center}
    .err{color:#b91c1c;font-weight:950;text-align:center}
    .oktxt{color:#166534;font-weight:950;text-align:center}

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){ .grid2{grid-template-columns:1fr} }

    .box{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:12px}
    .box h3{margin:0 0 10px;font-size:14px;font-weight:1000}

    .chip{display:inline-flex;align-items:center;padding:6px 10px;border:1px solid var(--bd);
      border-radius:999px;background:#f8fafc;margin:4px 6px 0 0;font-weight:900}
    .teams{display:flex;flex-direction:column;gap:10px}
    .team{border:1px solid var(--bd);border-radius:14px;padding:10px;background:#f8fafc}
    .team .tline{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
    .team .name{font-weight:950}
    .team .meta{color:var(--mut);font-weight:800;font-size:12px}

    table{width:100%;border-collapse:separate;border-spacing:0}
    th,td{border-bottom:1px solid var(--bd);padding:10px 8px;text-align:center;font-size:13px}
    th{position:sticky;top:0;background:#f2f4f8;z-index:1;font-weight:950}
    tr:last-child td{border-bottom:none}

    .matchCard{
      border:1px solid var(--bd);border-radius:14px;background:#fff;padding:10px;margin-bottom:10px
    }
    .matchTop{
      display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;
      font-weight:950
    }
    .matchMid{
      display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;margin-top:8px
    }
    .side{
      border:1px solid var(--bd);border-radius:12px;padding:10px;background:#f8fafc;font-weight:900;
      line-height:1.45
    }
    .vs{font-weight:1000;color:#ef4444;text-align:center}
    
    .scoreRow{
  display:flex;
  gap:8px;
  justify-content:center;
  align-items:center;
  margin-top:8px;
  flex-wrap:wrap;
}

.scoreInput{
  width:38px;
  padding:6px 6px;
  text-align:center;
  font-weight:900;
  font-size:13px;
}

.colon{
  font-weight:900;
  font-size:18px;
  margin:0 6px;
}
    .small{font-size:12px;color:var(--mut);font-weight:800}

    .bracket{
      display:flex;flex-direction:column;gap:10px
    }
    .bmatch{
      border:1px solid var(--bd);border-radius:14px;background:#fff;padding:10px
    }
    .bmatch .line{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{padding:6px 10px;border:1px solid var(--bd);border-radius:999px;background:#f8fafc;font-weight:900}
  </style>
</head>

<body>
  <div class="wrap">
    <h2>ğŸ¾ ê²½ê¸° ì§„í–‰ (team-live)</h2>

    <div class="card">
      <div class="row">
        <span class="pill">ì„¸íŠ¸: 1ì„¸íŠ¸ 6ê²Œì„</span>
        <label class="pill" style="display:flex;gap:8px;align-items:center;cursor:pointer">
          <input type="checkbox" id="noAd" />
          ë…¸ì• ë“œ(ê·œì¹™)
        </label>
        <label class="pill" style="display:flex;gap:8px;align-items:center;cursor:pointer">
          <input type="checkbox" id="tiebreak" checked />
          6:6 íƒ€ì´ë¸Œë ˆì´í¬(7:6 í—ˆìš©)
        </label>
      </div>
      <div class="mut" id="status">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
    </div>

    <!-- í˜„ì¬ íŒ€/ì¡° í˜„í™© -->
    <div class="grid2">
      <div class="box">
        <h3>í˜„ì¬ íŒ€ êµ¬ì„±</h3>
        <div class="teams" id="teamsBox"><div class="mut">ë°ì´í„° ì—†ìŒ</div></div>
      </div>
      <div class="box">
        <h3>ì¡° êµ¬ì„±</h3>
        <div id="groupsBox"><div class="mut">ì¡° ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¦¬ê·¸/í† ë„ˆë¡œ ì§„í–‰í•˜ì‹œë©´ ë©ë‹ˆë‹¤.</div></div>
      </div>
    </div>

    <!-- ì§„í–‰ ë°©ì‹/ì§„ì¶œ ì¸ì› ì„¤ì • -->
    <div class="card">
      <div class="row">
        <label style="font-weight:950">
          ì§„í–‰ ë°©ì‹
          <select id="format" class="input">
            <option value="league">ë¦¬ê·¸ì „(ì „ì²´ í’€ë¦¬ê·¸)</option>
            <option value="tournament">í† ë„ˆë¨¼íŠ¸(ë‹¨íŒ)</option>
            <option value="groups_to">ì¡°ë³„ë¦¬ê·¸ + í† ë„ˆë¨¼íŠ¸</option>
          </select>
        </label>

        <label style="font-weight:950">
          ì¡°ë³„ë¦¬ê·¸ â†’ í† ë„ˆ ì§„ì¶œ(ì¡°ë‹¹)
          <select id="advancePerGroup" class="input">
            <option value="1">1ìœ„ë§Œ</option>
            <option value="2" selected>1Â·2ìœ„</option>
            <option value="3">1Â·2Â·3ìœ„</option>
          </select>
        </label>

        <button class="btn ok" id="buildBtn">ëŒ€ì§„ ìƒì„±</button>
        <button class="btn secondary" id="resetRunBtn">ì§„í–‰ ë°ì´í„° ì´ˆê¸°í™”</button>
      </div>
      <div class="mut">ì¡°ë³„+í† ë„ˆ ì„ íƒ ì‹œ â€œì§„ì¶œ ì¸ì›â€ì„ ë°”ê¾¸ë©´ í† ë„ˆ ëŒ€ì§„ì´ ìë™ ì¬ìƒì„±ë©ë‹ˆë‹¤.</div>
    </div>

    <!-- ì¡°ë³„/ë¦¬ê·¸ ìˆœìœ„ -->
    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">ìˆœìœ„í‘œ</div>
      <div id="standingsBox"><div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div></div>
    </div>

    <!-- ê²½ê¸° ì…ë ¥ -->
    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">ê²½ê¸° ì§„í–‰</div>
      <div id="matchesBox"><div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div></div>
    </div>

    <!-- í† ë„ˆë¨¼íŠ¸ -->
    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">í† ë„ˆë¨¼íŠ¸</div>
      <div id="bracketBox"><div class="mut">í† ë„ˆë¨¼íŠ¸ ì„ íƒ(ë˜ëŠ” ì¡°ë³„+í† ë„ˆ) ì‹œ í‘œì‹œë©ë‹ˆë‹¤.</div></div>
    </div>
  </div>

  <script type="module">
    import { db, auth } from "../firebase.js";
    import { ref, onValue, set, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
    import { signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

    const $ = (id)=>document.getElementById(id);

    const PATH = {
      current: "teamLive/current",
      run:     "teamLive/run"
    };

    const esc = (s)=>String(s??"")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");

    const nowId = ()=> `M${Date.now()}_${Math.random().toString(16).slice(2,8)}`;

    // ----- state
    let current = null; // {teams, groups, ...}
    let run = null;     // {settings, matches, bracketRounds, ...}

    function teamLabel(team){
      const names = (team.players||[]).map(p=>`${p.name}(${p.grade})`).join(" Â· ");
      return `${team.id}: ${names}`;
    }
    function teamById(id){
      return (current?.teams||[]).find(t=>t.id===id) || null;
    }

    function setStatus(msg, cls="mut"){
      const el = $("status");
      el.className = cls;
      el.textContent = msg;
    }

    // ----- scoring rules (1 set, 6 games)
    function validateSetScore(a, b, tiebreakOn){
      if(!Number.isInteger(a) || !Number.isInteger(b)) return {ok:false, msg:"ì •ìˆ˜ë¡œ ì…ë ¥"};
      if(a<0 || b<0) return {ok:false, msg:"0 ì´ìƒ"};
      if(a===b) return {ok:false, msg:"ë™ì  ë¶ˆê°€"};

      const w = Math.max(a,b);
      const l = Math.min(a,b);

      if(w < 6) return {ok:false, msg:"ìŠ¹ì 6ê²Œì„ ì´ìƒ"};

      if(tiebreakOn && w===7 && l===6) return {ok:true};

      if(w - l >= 2){
        return {ok:true};
      }
      return {ok:false, msg: tiebreakOn ? "ì˜ˆ: 6:4 ë˜ëŠ” 7:6" : "2ê²Œì„ì°¨ í•„ìš”(ì˜ˆ: 7:5, 8:6)"};
    }

    function matchWinner(a,b){ return (a>b) ? "A" : "B"; }

    // ----- schedule generators
    function roundRobin(teamIds){
      const ms = [];
      for(let i=0;i<teamIds.length;i++){
        for(let j=i+1;j<teamIds.length;j++){
          ms.push({
            id: nowId(),
            type: "match",
            group: null,
            A: teamIds[i],
            B: teamIds[j],
            score: null,
            done: false
          });
        }
      }
      return ms;
    }

    function groupRoundRobin(groupsObj){
      const ms = [];
      for(const [g, ids] of Object.entries(groupsObj||{})){
        const rr = roundRobin(ids);
        rr.forEach(m=>m.group=g);
        ms.push(...rr);
      }
      return ms;
    }

    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function buildBracketFromPositions(seeded){
      const pow2 = seeded.length;

      const first = [];
      for(let i=0;i<pow2/2;i++){
        const A = seeded[i];
        const B = seeded[pow2-1-i];
        first.push({
          id: nowId(),
          round: 1,
          A, B,
          score: null,
          done: false,
          winner: null
        });
      }

      // BYE ìë™ìŠ¹
      first.forEach(m=>{
        if(m.A && !m.B){
          m.done = true; m.winner = m.A; m.score = {a:0,b:0, bye:true};
        }else if(!m.A && m.B){
          m.done = true; m.winner = m.B; m.score = {a:0,b:0, bye:true};
        }
      });

      // ì´í›„ ë¼ìš´ë“œ ìŠ¬ë¡¯
      const rounds = [first];
      let round = 1;
      let curCount = first.length;
      while(curCount > 1){
        round++;
        curCount = Math.ceil(curCount/2);
        const r = Array.from({length: curCount}, () => ({
          id: nowId(),
          round,
          A: null, B: null,
          score: null,
          done: false,
          winner: null
        }));
        rounds.push(r);
      }

      return rounds;
    }

    function propagateBracket(rounds){
      for(let r=0;r<rounds.length-1;r++){
        const cur = rounds[r];
        const next = rounds[r+1];
        for(let i=0;i<next.length;i++){
          const m1 = cur[i*2];
          const m2 = cur[i*2+1];
          next[i].A = m1 ? (m1.winner||null) : null;
          next[i].B = m2 ? (m2.winner||null) : null;

          const m = next[i];
          if(m.A && !m.B){
            m.done = true; m.winner = m.A; m.score = {a:0,b:0, bye:true};
          }else if(!m.A && m.B){
            m.done = true; m.winner = m.B; m.score = {a:0,b:0, bye:true};
          }else{
            if(!m.done && (!m.score || m.score.bye)) m.score = null;
          }
        }
      }
    }

    // ----- standings
    function computeStandings(matchList, scopedTeamIds){
      const map = new Map();
      const ensure = (id)=>{
        if(!map.has(id)){
          map.set(id, { id, played:0, win:0, loss:0, gw:0, gl:0, gd:0 });
        }
        return map.get(id);
      };

      (scopedTeamIds||[]).forEach(id=>ensure(id));

      for(const m of (matchList||[])){
        if(!m.done || !m.score || m.score.bye) continue;
        if(!m.A || !m.B) continue;
        const A = ensure(m.A);
        const B = ensure(m.B);
        const a = m.score.a|0, b = m.score.b|0;

        A.played++; B.played++;
        A.gw += a; A.gl += b;
        B.gw += b; B.gl += a;

        const w = matchWinner(a,b);
        if(w==="A"){ A.win++; B.loss++; }
        else { B.win++; A.loss++; }
      }

      for(const v of map.values()){
        v.gd = v.gw - v.gl;
      }

      const arr = [...map.values()];
      arr.sort((x,y)=>{
        if(y.win !== x.win) return y.win - x.win;
        if(y.gd !== x.gd) return y.gd - x.gd;
        if(y.gw !== x.gw) return y.gw - x.gw;
        return x.id.localeCompare(y.id);
      });
      return arr;
    }

    function pickQualifiers(groupsObj, standingsByGroup, advancePerGroup){
      const adv = advancePerGroup|0;
      const meta = []; // {teamId, group, rank}

      for(const [g, ids] of Object.entries(groupsObj||{})){
        const st = standingsByGroup[g] || [];
        const take = Math.min(adv, st.length);
        for(let i=0;i<take;i++){
          meta.push({ teamId: st[i].id, group: g, rank: i+1 });
        }
      }

      meta.sort((a,b)=>{
        if(a.rank !== b.rank) return a.rank - b.rank;
        return String(a.group).localeCompare(String(b.group));
      });

      return { seeds: meta.map(x=>x.teamId), meta };
    }

    // âœ… ëœë¤ BYE + ê°™ì€ ì¡° 1R íšŒí”¼ â€œí¬ì§€ì…˜ ë°°ì—´â€ ìƒì„±
    function buildSeedPositions(meta, randomByes=true){
      const n = meta.length;
      const pow2 = 1 << Math.ceil(Math.log2(Math.max(2, n)));
      const byes = pow2 - n;

      const seeded = Array(pow2).fill(null);
      let pairSlots = Array.from({length: pow2/2}, (_,i)=>i);

      let remain = [...meta].sort((a,b)=>{
        if(a.rank !== b.rank) return a.rank - b.rank;
        return String(a.group).localeCompare(String(b.group));
      });

      if(randomByes && byes > 0){
        const picked = shuffle(remain).slice(0, byes);
        const byeSet = new Set(picked.map(x=>x.teamId));
        remain = remain.filter(x=>!byeSet.has(x.teamId));

        pairSlots = shuffle(pairSlots);
        picked.forEach((p, k)=>{
          const ps = pairSlots[k];
          if(Math.random() < 0.5){
            seeded[ps] = p.teamId;
            seeded[pow2-1-ps] = null;
          }else{
            seeded[ps] = null;
            seeded[pow2-1-ps] = p.teamId;
          }
        });

        pairSlots = pairSlots.slice(byes);
      }

      while(remain.length){
        const best = remain.shift();

        let oppIndex = -1;
        for(let k=remain.length-1;k>=0;k--){
          if(remain[k].group !== best.group){ oppIndex = k; break; }
        }
        const opp = (oppIndex>=0) ? remain.splice(oppIndex,1)[0] : (remain.pop() || null);

        const ps = pairSlots.shift();
        if(ps === undefined) break;

        seeded[ps] = best.teamId;
        seeded[pow2-1-ps] = opp ? opp.teamId : null;
      }

      return seeded;
    }

    function arraysEqual(a,b){
      if(!a || !b) return false;
      if(a.length !== b.length) return false;
      for(let i=0;i<a.length;i++){
        if(a[i] !== b[i]) return false;
      }
      return true;
    }

    // ----- rendering
    function renderCurrent(){
      const teamsBox = $("teamsBox");
      const groupsBox = $("groupsBox");

      if(!current){
        teamsBox.innerHTML = `<div class="mut">current ì—†ìŒ</div>`;
        groupsBox.innerHTML = `<div class="mut">-</div>`;
        return;
      }

      const teams = current.teams || [];
      teamsBox.innerHTML = teams.length
        ? teams.map(t=>`
            <div class="team">
              <div class="tline">
                <div class="name">${esc(teamLabel(t))}</div>
                <div class="meta">í•© ${esc(t.sum ?? "")}</div>
              </div>
            </div>
          `).join("")
        : `<div class="mut">íŒ€ ë°ì´í„° ì—†ìŒ</div>`;

      const groups = current.groups || {};
      const keys = Object.keys(groups);
      if(!keys.length){
        groupsBox.innerHTML = `<div class="mut">ì¡° ë°ì´í„° ì—†ìŒ</div>`;
      }else{
        groupsBox.innerHTML = keys.sort().map(g=>{
          const ids = groups[g] || [];
          return `
            <div style="margin-bottom:10px">
              <div style="font-weight:1000;margin-bottom:6px">${esc(g)}ì¡°</div>
              <div>
                ${ids.map(id=>{
                  const t = teamById(id);
                  return `<span class="chip">${esc(t ? teamLabel(t) : id)}</span>`;
                }).join("")}
              </div>
            </div>
          `;
        }).join("");
      }
    }

    function standingsTable(title, st){
      return `
        <div class="box" style="box-shadow:none">
          <div style="font-weight:1000;margin-bottom:8px">${esc(title)} ìˆœìœ„</div>
          <div style="overflow:auto;border:1px solid var(--bd);border-radius:12px">
            <table>
              <thead>
                <tr>
                  <th>ìˆœìœ„</th><th>íŒ€</th><th>ê²½ê¸°</th><th>ìŠ¹</th><th>íŒ¨</th><th>ë“</th><th>ì‹¤</th><th>ë“ì‹¤</th>
                </tr>
              </thead>
              <tbody>
                ${st.map((r,i)=>{
                  const t = teamById(r.id);
                  return `
                    <tr>
                      <td>${i+1}</td>
                      <td style="text-align:left;font-weight:900">${esc(t ? teamLabel(t) : r.id)}</td>
                      <td>${r.played}</td>
                      <td>${r.win}</td>
                      <td>${r.loss}</td>
                      <td>${r.gw}</td>
                      <td>${r.gl}</td>
                      <td>${r.gd}</td>
                    </tr>
                  `;
                }).join("") || `<tr><td colspan="8" class="mut">ë°ì´í„° ì—†ìŒ</td></tr>`}
              </tbody>
            </table>
          </div>
          <div class="small" style="margin-top:8px">
            ë™ë¥  ì •ë ¬: ìŠ¹ â†’ ë“ì‹¤ â†’ ë“ê²Œì„
          </div>
        </div>
      `;
    }

    function renderStandings(){
      const box = $("standingsBox");
      if(!run || !current){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div>`;
        return;
      }
      const format = run.settings?.format || "league";
      const matches = run.matches || [];
      const groupsObj = current.groups || {};
      const allIds = (current.teams||[]).map(t=>t.id);

      if(format==="league" || format==="tournament"){
        const st = computeStandings(matches, allIds);
        box.innerHTML = standingsTable("ì „ì²´", st);
        return;
      }

      // groups_to: ì¡°ë³„ ìˆœìœ„
      const out = [];
      const standingsByGroup = {};
      for(const [g, ids] of Object.entries(groupsObj)){
        const gMatches = matches.filter(m=>m.group===g);
        const st = computeStandings(gMatches, ids);
        standingsByGroup[g] = st;
        out.push(`<div style="margin-bottom:10px">${standingsTable(`${g}ì¡°`, st)}</div>`);
      }
      box.innerHTML = out.join("") || `<div class="mut">ì¡°ë³„ ìˆœìœ„ ì—†ìŒ</div>`;

      // í† ë„ˆ ì§„ì¶œ ë¯¸ë¦¬ë³´ê¸°
      const adv = run.settings?.advancePerGroup|0;
      if(adv>0){
        const q = pickQualifiers(groupsObj, standingsByGroup, adv);
        const seedsArr = q.seeds || [];
        if(seedsArr.length){
          box.innerHTML += `
            <div class="card" style="margin-top:10px;box-shadow:none">
              <div style="font-weight:1000;text-align:center;margin-bottom:8px">í† ë„ˆ ì§„ì¶œ(ì‹œë“œ)</div>
              <div style="text-align:center">
                ${seedsArr.map(id=>{
                  const t = teamById(id);
                  return `<span class="chip">${esc(t ? teamLabel(t) : id)}</span>`;
                }).join("")}
              </div>
              <div class="mut">â€» ì¡°ë³„ ê²°ê³¼ì— ë”°ë¼ í† ë„ˆ ì‹œë“œëŠ” ìë™ ê°±ì‹ ë©ë‹ˆë‹¤.</div>
            </div>
          `;
        }
      }
    }

    function renderMatches(){
      const box = $("matchesBox");
      if(!run || !current || !(run.matches||[]).length){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      const tiebreakOn = $("tiebreak").checked;
      const ms = run.matches || [];

      box.innerHTML = ms.map((m, idx)=>{
        const A = teamById(m.A);
        const B = teamById(m.B);
        const aName = A ? teamLabel(A) : (m.A||"BYE");
        const bName = B ? teamLabel(B) : (m.B||"BYE");

        const s = m.score && !m.score.bye ? `${m.score.a}:${m.score.b}` : (m.score?.bye ? "BYE" : "-");

        return `
          <div class="matchCard">
            <div class="matchTop">
              <div>#${idx+1} ${m.group ? `(${esc(m.group)}ì¡°)` : ""}</div>
              <div class="small">ê²°ê³¼: <b>${esc(s)}</b> ${m.done ? "âœ…" : ""}</div>
            </div>

            <div class="matchMid">
              <div class="side">${esc(aName)}</div>
              <div class="vs">VS</div>
              <div class="side">${esc(bName)}</div>
            </div>

            <div class="scoreRow">
  <input class="input scoreInput" type="number" min="0" step="1"
    id="a_${m.id}"
    value="${m.score && !m.score.bye ? m.score.a : ""}">

  <span class="colon">:</span>

  <input class="input scoreInput" type="number" min="0" step="1"
    id="b_${m.id}"
    value="${m.score && !m.score.bye ? m.score.b : ""}">

  <button class="btn ok" data-mid="${m.id}">ì €ì¥</button>
  <button class="btn secondary" data-clear="${m.id}">ì§€ìš°ê¸°</button>
</div>

            <div class="mut" id="msg_${m.id}" style="margin-top:6px"></div>
          </div>
        `;
      }).join("");

      box.querySelectorAll("button[data-mid]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-mid");
          await saveMatchScore(mid, tiebreakOn);
        });
      });
      box.querySelectorAll("button[data-clear]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-clear");
          await clearMatchScore(mid);
        });
      });
    }

    function renderBracket(){
      const box = $("bracketBox");
      if(!run || !current){
        box.innerHTML = `<div class="mut">-</div>`;
        return;
      }
      const format = run.settings?.format || "league";
      const rounds = run.bracketRounds || null;

      if(format!=="tournament" && format!=="groups_to"){
        box.innerHTML = `<div class="mut">í† ë„ˆë¨¼íŠ¸ ëª¨ë“œì—ì„œ í‘œì‹œë©ë‹ˆë‹¤.</div>`;
        return;
      }
      if(!rounds){
        box.innerHTML = `<div class="mut">í† ë„ˆ ëŒ€ì§„ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      box.innerHTML = `
        <div class="bracket">
          ${rounds.map((round, rIdx)=>{
            return `
              <div class="box" style="box-shadow:none">
                <h3>ë¼ìš´ë“œ ${rIdx+1}</h3>
                ${round.map((m, i)=>{
                  const A = m.A ? teamById(m.A) : null;
                  const B = m.B ? teamById(m.B) : null;
                  const aName = m.A ? (A ? teamLabel(A) : m.A) : "BYE/ëŒ€ê¸°";
                  const bName = m.B ? (B ? teamLabel(B) : m.B) : "BYE/ëŒ€ê¸°";
                  const s = m.score && !m.score.bye ? `${m.score.a}:${m.score.b}` : (m.score?.bye ? "BYE" : "-");
                  const winner = m.winner ? (teamById(m.winner) ? teamLabel(teamById(m.winner)) : m.winner) : "";

                  return `
                    <div class="bmatch">
                      <div class="line">
                        <div style="font-weight:950">ë§¤ì¹˜ ${i+1}</div>
                        <div class="small">ê²°ê³¼: <b>${esc(s)}</b> ${m.done ? "âœ…" : ""}</div>
                      </div>
                      <div style="margin-top:8px;display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center">
                        <div class="side">${esc(aName)}</div>
                        <div class="vs">VS</div>
                        <div class="side">${esc(bName)}</div>
                      </div>

                      <div class="scoreRow">
  <input class="input scoreInput" type="number" min="0" step="1"
    id="ba_${m.id}"
    value="${m.score && !m.score.bye ? m.score.a : ""}">

  <span class="colon">:</span>

  <input class="input scoreInput" type="number" min="0" step="1"
    id="bb_${m.id}"
    value="${m.score && !m.score.bye ? m.score.b : ""}">

  <button class="btn ok" data-bsave="${m.id}">ì €ì¥</button>
  <button class="btn secondary" data-bclear="${m.id}">ì§€ìš°ê¸°</button>
</div>

                      <div class="mut" id="bmsg_${m.id}" style="margin-top:6px"></div>
                      ${winner ? `<div class="oktxt">ìŠ¹ì: ${esc(winner)}</div>` : ``}
                    </div>
                  `;
                }).join("")}
              </div>
            `;
          }).join("")}
        </div>
      `;

      box.querySelectorAll("button[data-bsave]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-bsave");
          await saveBracketScore(mid, $("tiebreak").checked);
        });
      });
      box.querySelectorAll("button[data-bclear]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-bclear");
          await clearBracketScore(mid);
        });
      });
    }

    // ----- persistence helpers
    async function writeRun(nextRun){
      nextRun.updatedAt = Date.now();
      nextRun.serverUpdatedAt = serverTimestamp();
      await set(ref(db, PATH.run), nextRun);
    }

    // âœ… í•µì‹¬ ìˆ˜ì •: groups_toì—ì„œ â€œì§„ì¶œíŒ€ êµ¬ì„±ì›ì´ ê°™ìœ¼ë©´â€ seededPositions(=ëŒ€ì§„) ìœ ì§€
    function recalcDerived(nextRun){
      const format = nextRun.settings?.format || "league";

      if(format === "league"){
        return nextRun;
      }

      if(format === "tournament"){
        if(nextRun.bracketRounds){
          propagateBracket(nextRun.bracketRounds);
        }
        return nextRun;
      }

      if(format === "groups_to"){
        const groupsObj = current?.groups || {};

        // 1) ì¡°ë³„ ìˆœìœ„ ê³„ì‚°
        const standingsByGroup = {};
        for(const [g, ids] of Object.entries(groupsObj)){
          const gMatches = (nextRun.matches||[]).filter(m=>m.group===g);
          standingsByGroup[g] = computeStandings(gMatches, ids);
        }

        // 2) ì§„ì¶œíŒ€ + meta
        const adv = nextRun.settings?.advancePerGroup|0;
        const { seeds, meta } = pickQualifiers(groupsObj, standingsByGroup, adv);

        // 3) âœ… ì§„ì¶œíŒ€ â€œêµ¬ì„±ì›â€ì´ ë°”ë€” ë•Œë§Œ ëœë¤ ì‹œë“œ/ë¶€ì „ìŠ¹ ë‹¤ì‹œ ìƒì„±
        const qualifierIds = meta.map(x=>x.teamId).slice().sort();
        const prevQualifierIds = nextRun.bracketQualifierIds || null;

        const sameQualifiers =
          Array.isArray(prevQualifierIds) &&
          prevQualifierIds.length === qualifierIds.length &&
          prevQualifierIds.every((v,i)=>v === qualifierIds[i]);

        let seededPositions = nextRun.bracketSeededPositions || null;

        if(!sameQualifiers || !seededPositions){
          seededPositions = buildSeedPositions(meta, true); // ëœë¤ BYE + 1R ê°™ì€ì¡° íšŒí”¼
          nextRun.bracketQualifierIds = qualifierIds;       // êµ¬ì„±ì›ë§Œ ì €ì¥(ë¹„êµìš©)
          nextRun.bracketSeededPositions = seededPositions; // í¬ì§€ì…˜ ì €ì¥(ëŒ€ì§„ ê³ ì • í•µì‹¬)
        }

        // í‘œì‹œìš©
        nextRun.bracketSeeds = seeds;

        // 4) seededPositionsê°€ ë°”ë€ ê²½ìš°ì—ë§Œ ë¸Œë¼ì¼“ ì¬ìƒì„±(ì ìˆ˜/ë§¤ì¹˜ID ê¼¬ì„ ë°©ì§€)
        const prevPositions = nextRun.bracketSeededPositionsPrev || null;
        const needRebuild =
          !nextRun.bracketRounds ||
          !prevPositions ||
          !arraysEqual(prevPositions, seededPositions);

        if(needRebuild){
          nextRun.bracketRounds = buildBracketFromPositions(seededPositions);
        }

        // ë‹¤ìŒ ë¹„êµìš© ì €ì¥
        nextRun.bracketSeededPositionsPrev = seededPositions;

        // 5) ìŠ¹ì ì „íŒŒ
        propagateBracket(nextRun.bracketRounds);
        return nextRun;
      }

      return nextRun;
    }

    // ----- actions
    async function buildSchedule(){
      if(!current || !(current.teams||[]).length){
        alert("teamLive/current íŒ€ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }

      const format = $("format").value;
      const advancePerGroup = parseInt($("advancePerGroup").value, 10);

      const teamIds = current.teams.map(t=>t.id);
      const groupsObj = current.groups || {};
      const hasGroups = Object.keys(groupsObj).length > 0;

      if(format==="groups_to" && !hasGroups){
        alert("ì¡° ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (íŒ€ êµ¬ì„± í˜ì´ì§€ì—ì„œ ì¡° í¸ì„± í›„ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤)");
        return;
      }

      if(format==="groups_to"){
        const minSize = Math.min(...Object.values(groupsObj).map(v=>v.length));
        if(advancePerGroup > minSize){
          alert(`ì§„ì¶œ ì¸ì›(${advancePerGroup})ì´ ì¡° íŒ€ ìˆ˜(${minSize})ë³´ë‹¤ í½ë‹ˆë‹¤. ë‚®ì¶°ì£¼ì„¸ìš”.`);
          return;
        }
      }

      const nextRun = {
        settings: {
          format,
          advancePerGroup: (format==="groups_to") ? advancePerGroup : 0,
          scoring: {
            set: "6games",
            noAd: $("noAd").checked,
            tiebreak: $("tiebreak").checked
          }
        },
        matches: [],
        bracketRounds: null,
        bracketSeeds: [],
        // ë¹„êµ/ê³ ì •ìš© í•„ë“œ
        bracketSeededPositions: null,
        bracketQualifierIds: null,
        bracketSeededPositionsPrev: null
      };

      if(format==="league"){
        nextRun.matches = roundRobin(teamIds);

      }else if(format==="tournament"){
        // âœ… í† ë„ˆë„ ëœë¤ BYE + ëœë¤ ë°°ì¹˜(ì²˜ìŒ ìƒì„± ì‹œì—ë§Œ)
        const meta = shuffle(teamIds).map(id => ({ teamId: id, group: "X", rank: 1 }));
        const seededPositions = buildSeedPositions(meta, true);
        nextRun.bracketSeededPositions = seededPositions;
        nextRun.bracketSeededPositionsPrev = seededPositions;
        nextRun.bracketQualifierIds = meta.map(x=>x.teamId).slice().sort();

        nextRun.bracketRounds = buildBracketFromPositions(seededPositions);
        propagateBracket(nextRun.bracketRounds);

      }else if(format==="groups_to"){
        nextRun.matches = groupRoundRobin(groupsObj);
        recalcDerived(nextRun);
      }

      await writeRun(nextRun);
    }

    async function resetRun(){
      if(!confirm("ê²½ê¸° ì§„í–‰ ë°ì´í„°(teamLive/run)ë¥¼ ì´ˆê¸°í™”í• ê¹Œìš”?")) return;
      await set(ref(db, PATH.run), null);
    }

    async function saveMatchScore(matchId, tiebreakOn){
      const idx = (run?.matches||[]).findIndex(m=>m.id===matchId);
      if(idx < 0) return;

      const aEl = document.getElementById(`a_${matchId}`);
      const bEl = document.getElementById(`b_${matchId}`);
      const msg = document.getElementById(`msg_${matchId}`);

      const a = parseInt(aEl.value,10);
      const b = parseInt(bEl.value,10);

      const v = validateSetScore(a,b,tiebreakOn);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.noAd = $("noAd").checked;
      nextRun.settings.scoring.tiebreak = $("tiebreak").checked;

      nextRun.matches[idx].score = { a, b };
      nextRun.matches[idx].done = true;

      msg.className = "oktxt";
      msg.textContent = "ì €ì¥ë¨";

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    async function clearMatchScore(matchId){
      const idx = (run?.matches||[]).findIndex(m=>m.id===matchId);
      if(idx < 0) return;

      const nextRun = structuredClone(run);
      nextRun.matches[idx].score = null;
      nextRun.matches[idx].done = false;

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    function findBracketMatch(rounds, matchId){
      for(let r=0;r<rounds.length;r++){
        for(let i=0;i<rounds[r].length;i++){
          if(rounds[r][i].id===matchId) return {r,i};
        }
      }
      return null;
    }

    async function saveBracketScore(matchId, tiebreakOn){
      if(!run?.bracketRounds) return;
      const pos = findBracketMatch(run.bracketRounds, matchId);
      if(!pos) return;

      const aEl = document.getElementById(`ba_${matchId}`);
      const bEl = document.getElementById(`bb_${matchId}`);
      const msg = document.getElementById(`bmsg_${matchId}`);

      const a = parseInt(aEl.value,10);
      const b = parseInt(bEl.value,10);

      const m = run.bracketRounds[pos.r][pos.i];
      if(!m.A || !m.B){
        msg.className = "err";
        msg.textContent = "BYE/ëŒ€ê¸° ìŠ¬ë¡¯ì€ ì ìˆ˜ ì…ë ¥ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.";
        return;
      }

      const v = validateSetScore(a,b,tiebreakOn);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.noAd = $("noAd").checked;
      nextRun.settings.scoring.tiebreak = $("tiebreak").checked;

      const bm = nextRun.bracketRounds[pos.r][pos.i];
      bm.score = { a, b };
      bm.done = true;
      bm.winner = (matchWinner(a,b)==="A") ? bm.A : bm.B;

      propagateBracket(nextRun.bracketRounds);

      msg.className = "oktxt";
      msg.textContent = "ì €ì¥ë¨";
      await writeRun(nextRun);
    }

    async function clearBracketScore(matchId){
      if(!run?.bracketRounds) return;
      const pos = findBracketMatch(run.bracketRounds, matchId);
      if(!pos) return;

      const nextRun = structuredClone(run);
      const bm = nextRun.bracketRounds[pos.r][pos.i];

      if(bm.score?.bye) return;

      bm.score = null;
      bm.done = false;
      bm.winner = null;

      propagateBracket(nextRun.bracketRounds);
      await writeRun(nextRun);
    }

    // ----- bind UI
    $("buildBtn").addEventListener("click", buildSchedule);
    $("resetRunBtn").addEventListener("click", resetRun);

    $("advancePerGroup").addEventListener("change", async ()=>{
      if(!run || run.settings?.format!=="groups_to") return;
      const nextRun = structuredClone(run);
      nextRun.settings.advancePerGroup = parseInt($("advancePerGroup").value,10) || 2;
      recalcDerived(nextRun);
      await writeRun(nextRun);
    });

    $("format").addEventListener("change", ()=>{
      renderAll();
    });

    $("noAd").addEventListener("change", async ()=>{
      if(!run) return;
      const nextRun = structuredClone(run);
      nextRun.settings.scoring.noAd = $("noAd").checked;
      await writeRun(nextRun);
    });

    $("tiebreak").addEventListener("change", async ()=>{
      if(!run) return;
      const nextRun = structuredClone(run);
      nextRun.settings.scoring.tiebreak = $("tiebreak").checked;
      await writeRun(nextRun);
    });

    function renderAll(){
      renderCurrent();
      renderStandings();
      renderMatches();
      renderBracket();
    }

    // ----- init
    (async function init(){
      try{
        setStatus("Firebase ì—°ê²° ì¤‘...");
        await signInAnonymously(auth);

        onValue(ref(db, PATH.current), (snap)=>{
          current = snap.exists() ? (snap.val() || null) : null;
          if(!current){
            setStatus("teamLive/current ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (íŒ€ êµ¬ì„± í˜ì´ì§€ì—ì„œ ì €ì¥ í›„ ì´ë™í•˜ì„¸ìš”)", "err");
          }else{
            setStatus("ë°ì´í„° ë¡œë“œ ì™„ë£Œ", "oktxt");
          }
          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("current ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

        onValue(ref(db, PATH.run), (snap)=>{
          run = snap.exists() ? (snap.val() || null) : null;

          if(run?.settings){
            $("format").value = run.settings.format || "league";
            $("advancePerGroup").value = String(run.settings.advancePerGroup || 2);
            $("noAd").checked = !!run.settings.scoring?.noAd;
            $("tiebreak").checked = (run.settings.scoring?.tiebreak ?? true);
          }

          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("run ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

      }catch(e){
        console.error(e);
        setStatus("Firebase ì—°ê²° ì˜¤ë¥˜(ì½˜ì†” í™•ì¸)", "err");
      }
    })();
  </script>
</body>
</html>