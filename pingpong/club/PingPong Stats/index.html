<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>KOEN 탁구 · 성적입력</title>
  <style>
    :root{
      --ink:#0f172a; --muted:#64748b; --card:#fff; --bg:#f5f7fb;
      --primary:#0d47a1; --accent:#2563eb; --ok:#16a34a; --danger:#ef4444;
      --shadow:0 8px 28px rgba(0,0,0,.08)
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif; color:var(--ink); background:var(--bg)}
    header{position:sticky; top:0; z-index:10; background:#fff; border-bottom:1px solid #e5e7eb}
    .wrap{max-width:1040px; margin:0 auto; padding:14px 16px}
    h1{margin:4px 0 6px; font-size:clamp(18px,4vw,24px); color:var(--primary)}
    main{max-width:1040px; margin:16px auto; padding:0 16px 40px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .col{display:flex; flex-direction:column; gap:8px}
    .card{background:var(--card); border:1px solid #e5e7eb; border-radius:16px; padding:14px; box-shadow:var(--shadow); margin:12px 0}
    label{font-size:13px; color:#334155}
    select, input[type="text"], input[type="number"]{padding:8px 10px; border:1px solid #d1d5db; border-radius:10px; background:#fff; min-width:160px}
    .btn{border:1px solid #d1d5db; border-radius:10px; padding:10px 14px; font-size:14px; background:#fff; cursor:pointer}
    .btn.primary{background:var(--accent); color:#fff; border-color:var(--accent)}
    .btn.warn{background:#ef4444; color:#fff; border-color:#ef4444}
    .btn.ok{background:#16a34a; color:#fff; border-color:#16a34a}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .grid{display:grid; gap:14px}
    .grid.cols-2{grid-template-columns:repeat(auto-fit, minmax(280px,1fr))}
    .chip{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid #e5e7eb; background:#f8fafc; font-size:12px}
    .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:18px; background:#111827; color:#fff; padding:10px 14px; border-radius:12px; opacity:0; pointer-events:none; transition:.25s}
    .toast.show{opacity:1}
    .divider{height:1px; background:#e5e7eb; margin:10px 0}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1 style="margin-right:auto">KOEN 탁구 · 성적입력</h1>
      <a class="btn" href="admin.html">⚙️ 관리자</a>
      <a class="btn" href="monthly-report.html">📊 이번달 성적표</a>
    </div>
    <div class="row">
      <span class="chip">실험판</span>
      <span class="small muted">※ 가중치는 관리자에서 설정하세요.</span>
    </div>
  </div>
</header>

<main>
  <section class="card">
    <div class="grid cols-2">
      <div class="col">
        <div class="row">
          <label>경기 종류</label>
          <select id="matchType">
            <option value="singles">단식</option>
            <option value="doubles">복식</option>
          </select>
          <span class="small muted">복식 가중치는 관리자 설정 사용</span>
        </div>
        <div class="divider"></div>

        <div class="row">
          <label style="min-width:64px">A 선수</label>
          <select id="playerA"></select>
          <span id="lvA" class="chip">부수: -</span>
        </div>
        <div class="row doublesOnly" style="display:none">
          <label style="min-width:64px">A 파트너</label>
          <select id="partnerA"></select>
        </div>

        <div class="row">
          <label style="min-width:64px">B 선수</label>
          <select id="playerB"></select>
          <span id="lvB" class="chip">부수: -</span>
        </div>
        <div class="row doublesOnly" style="display:none">
          <label style="min-width:64px">B 파트너</label>
          <select id="partnerB"></select>
        </div>

        <div class="divider"></div>

        <div class="row">
          <label>세트 스코어</label>
          <input id="scoreInput" type="text" placeholder="예: 3-2" style="min-width:120px"/>
          <span class="small muted">형식: 3-2, 2:0 등</span>
        </div>

        <div class="row">
          <label>승자</label>
          <select id="winnerSel">
            <option value="A">A팀(또는 A선수)</option>
            <option value="B">B팀(또는 B선수)</option>
          </select>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button id="confirmBtn" class="btn primary">✅ 경기 확정 & 누적 반영</button>
          <button id="resetBtn" class="btn">초기화</button>
        </div>
        <div class="small muted" id="preview"></div>
      </div>

      <div class="col">
        <div class="row"><strong>적용될 가중치(미리보기)</strong></div>
        <div class="row">
          <div class="chip">실력차 보정: <span id="wSkill">-</span></div>
          <div class="chip">복식 가중: <span id="wDouble">-</span></div>
          <div class="chip">최종 가중: <span id="wFinal">-</span></div>
        </div>
        <div class="divider"></div>
        <div class="small muted">선수/승자/스코어를 바꾸면 자동 갱신됩니다.</div>
      </div>
    </div>
  </section>
</main>

<div id="toast" class="toast">Saved</div>

<!-- Firebase + Logic -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
  import { getDatabase, ref, onValue, get, set, update, push } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  // ===== Firebase ===== (🔧 수정 지점: 프로젝트 바꾸면 이 객체만 바꾸세요)
  const firebaseConfig = {
    apiKey: "AIzaSyC5iq3VY0QtBh8FVn70gi_Gsg7GXzkxdu8",
    authDomain: "koen-pingpong.firebaseapp.com",
    databaseURL: "https://koen-pingpong-default-rtdb.firebaseio.com",
    projectId: "koen-pingpong",
    storageBucket: "koen-pingpong.appspot.com",
    messagingSenderId: "597358811982",
    appId: "1:597358811982:web:b66dcb6a7159fb5f321c1f"
  };
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getDatabase(app);

  // ===== Utils =====
  const $ = (s, ctx=document)=>ctx.querySelector(s);
  const toast = (msg='저장되었습니다')=>{
    const t=$('#toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1600);
  };
  const pad = (n)=> String(n).padStart(2,'0');
  const toKST = (t = Date.now()) => new Date( new Date(t).toLocaleString('en-US', { timeZone:'Asia/Seoul' }) );
  const yyyymm = (d)=> `${d.getFullYear()}-${pad(d.getMonth()+1)}`;

  function parseSetScore(scoreStr){
    const m = /^(\d+)\s*[-:]\s*(\d+)$/.exec(String(scoreStr||"").trim());
    if(!m) return { for:0, against:0 };
    return { for:Number(m[1]), against:Number(m[2]) };
  }
  function clamp(min, x, max){ return Math.max(min, Math.min(max, x)); }

  // ===== 전역 상태 =====
  let players = [];      // {id, name, level}
  let skillAdjust = { perLevel:0.05, minFav:0.6, maxDog:1.8 }; // 관리자 설정 기본값
  let doubleWeight = 0.5; // 관리자 설정 기본값

  // ===== 보정 가중치 계산 =====
  // 🔧 수정 지점: 다른 페이지에서도 동일 로직을 쓰세요.
  function getAdjustedWeight(levelA, levelB, winner){ // winner: 'A' | 'B'
    const sa = skillAdjust;
    const d = Math.abs((levelA ?? 99) - (levelB ?? 99)); // level 미기입은 큰 값
    const aIsFav = (levelA ?? 99) < (levelB ?? 99);      // 숫자 작을수록 상위
    const favWin = clamp(sa.minFav, 1 - sa.perLevel * d, 1);
    const dogWin = clamp(1,         1 + sa.perLevel * d, sa.maxDog);
    if(winner === 'A'){
      return aIsFav ? favWin : dogWin;
    }else{
      const bIsFav = !aIsFav;
      return bIsFav ? favWin : dogWin;
    }
  }

  // ===== DB 접근: 월간 스탯 누적 =====
  // 🔧 수정 지점: 누적 경로/필드명을 프로젝트 표준에 맞게 바꾸려면 여기만 조정
  async function applyDeltaToPlayer(monthKey, playerId, delta){
    const pRef = ref(db, `stats/${monthKey}/${playerId}`);
    const snap = await get(pRef);
    const cur = snap.val() || {
      wWins:0, wLosses:0, wSetsFor:0, wSetsAgainst:0,
      matches:0,    // 비가중 경기 수
      lastUpdated:0
    };
    const next = {
      wWins:        (cur.wWins        || 0) + (delta.wWins        || 0),
      wLosses:      (cur.wLosses      || 0) + (delta.wLosses      || 0),
      wSetsFor:     (cur.wSetsFor     || 0) + (delta.wSetsFor     || 0),
      wSetsAgainst: (cur.wSetsAgainst || 0) + (delta.wSetsAgainst || 0),
      matches:      (cur.matches      || 0) + (delta.matches      || 0),
      lastUpdated: Date.now()
    };
    await update(pRef, next);
  }

  // ===== 경기 확정(단식/복식 공통 진입) =====
  // 🔧 핵심 함수: 여기서 finalWeight를 만들고 각 선수에게 델타를 반영합니다.
  async function confirmSinglesResult({ monthKey, playerAId, playerBId, levelA, levelB, winner, score }){
    const weight  = getAdjustedWeight(levelA, levelB, winner);
    const dbl     = 1; // 단식
    const finalWeight = weight * dbl;

    const { for:setsForA, against:setsAgainstA } = parseSetScore(score);
    const setsForB     = setsAgainstA;
    const setsAgainstB = setsForA;

    const deltaA = {
      wWins:        (winner === 'A') ? finalWeight : 0,
      wLosses:      (winner === 'B') ? finalWeight : 0,
      wSetsFor:     setsForA     * finalWeight,
      wSetsAgainst: setsAgainstA * finalWeight,
      matches:      1
    };
    const deltaB = {
      wWins:        (winner === 'B') ? finalWeight : 0,
      wLosses:      (winner === 'A') ? finalWeight : 0,
      wSetsFor:     setsForB     * finalWeight,
      wSetsAgainst: setsAgainstB * finalWeight,
      matches:      1
    };

    await Promise.all([
      applyDeltaToPlayer(monthKey, playerAId, deltaA),
      applyDeltaToPlayer(monthKey, playerBId, deltaB),
    ]);

    return { finalWeight, weight, dbl };
  }

  async function confirmDoublesResult({ monthKey, a1, a2, b1, b2, levelAmin, levelBmin, winner, score }){
    // 복식은 팀의 "대표 레벨"을 어떻게 볼지 결정 필요:
    // 여기서는 각 팀의 "최상위자(숫자 가장 작은 부수)"로 비교(간단/일관).
    const teamALevel = levelAmin;
    const teamBLevel = levelBmin;

    const skillW = getAdjustedWeight(teamALevel, teamBLevel, winner);
    const dbl    = doubleWeight;            // 관리자 설정값
    const finalWeight = skillW * dbl;

    const { for:setsForA, against:setsAgainstA } = parseSetScore(score);
    const setsForB     = setsAgainstA;
    const setsAgainstB = setsForA;

    const deltaTeamA = {
      wWins:        (winner === 'A') ? finalWeight : 0,
      wLosses:      (winner === 'B') ? finalWeight : 0,
      wSetsFor:     setsForA     * finalWeight,
      wSetsAgainst: setsAgainstA * finalWeight,
      matches:      1
    };
    const deltaTeamB = {
      wWins:        (winner === 'B') ? finalWeight : 0,
      wLosses:      (winner === 'A') ? finalWeight : 0,
      wSetsFor:     setsForB     * finalWeight,
      wSetsAgainst: setsAgainstB * finalWeight,
      matches:      1
    };

    // 각 팀 2명 모두에게 동일 델타 반영
    await Promise.all([
      applyDeltaToPlayer(monthKey, a1, deltaTeamA),
      applyDeltaToPlayer(monthKey, a2, deltaTeamA),
      applyDeltaToPlayer(monthKey, b1, deltaTeamB),
      applyDeltaToPlayer(monthKey, b2, deltaTeamB),
    ]);

    return { finalWeight, weight:skillW, dbl };
  }

  // (선택) 경기 로그 저장
  async function logMatch(monthKey, payload){
    const mRef = ref(db, `matches/${monthKey}`);
    await set(push(mRef), { ...payload, ts: Date.now() });
  }

  // ===== UI/데이터 바인딩 =====
  const els = {
    matchType: $('#matchType'),
    playerA:   $('#playerA'),
    partnerA:  $('#partnerA'),
    playerB:   $('#playerB'),
    partnerB:  $('#partnerB'),
    lvA:       $('#lvA'),
    lvB:       $('#lvB'),
    score:     $('#scoreInput'),
    winnerSel: $('#winnerSel'),
    confirm:   $('#confirmBtn'),
    reset:     $('#resetBtn'),
    preview:   $('#preview'),
    wSkill:    $('#wSkill'),
    wDouble:   $('#wDouble'),
    wFinal:    $('#wFinal'),
  };

  function fillPlayerSelect(sel){
    sel.innerHTML = '<option value="">선택</option>';
    players
      .slice()
      .sort((a,b)=> a.name.localeCompare(b.name,'ko'))
      .forEach(p=>{
        const opt=document.createElement('option');
        opt.value=p.id;
        opt.textContent = p.level!=null ? `${p.name} (${p.level})` : `${p.name}`;
        sel.appendChild(opt);
      });
  }

  function findPlayer(id){ return players.find(p=>p.id===id); }
  function getLevel(id){ return findPlayer(id)?.level ?? null; }

  function updateDoublesVisibility(){
    const show = els.matchType.value === 'doubles';
    document.querySelectorAll('.doublesOnly').forEach(el=>{
      el.style.display = show ? '' : 'none';
    });
  }

  function refreshLevelsBadge(){
    const la = getLevel(els.playerA.value);
    const lb = getLevel(els.playerB.value);
    els.lvA.textContent = `부수: ${la ?? '-'}`;
    els.lvB.textContent = `부수: ${lb ?? '-'}`;
  }

  function previewWeights(){
    const isDbl = (els.matchType.value === 'doubles');
    const winner = els.winnerSel.value; // 'A' or 'B'
    let skillW = 1, dblW = 1, finalW = 1;

    if(!isDbl){
      const la = getLevel(els.playerA.value);
      const lb = getLevel(els.playerB.value);
      skillW = getAdjustedWeight(la, lb, winner);
      dblW   = 1;
      finalW = skillW * dblW;
    }else{
      const la1 = getLevel(els.playerA.value);
      const la2 = getLevel(els.partnerA.value);
      const lb1 = getLevel(els.playerB.value);
      const lb2 = getLevel(els.partnerB.value);
      // 팀 대표 레벨: 최상위자(숫자 가장 작은 값)
      const teamALvl = Math.min(...[la1, la2].map(v=> v ?? 99));
      const teamBLvl = Math.min(...[lb1, lb2].map(v=> v ?? 99));
      skillW = getAdjustedWeight(teamALvl, teamBLvl, winner);
      dblW   = doubleWeight;
      finalW = skillW * dblW;
    }

    els.wSkill.textContent = isFinite(skillW) ? skillW.toFixed(3) : '-';
    els.wDouble.textContent = isFinite(dblW)   ? dblW.toFixed(3)   : '-';
    els.wFinal.textContent  = isFinite(finalW) ? finalW.toFixed(3) : '-';
  }

  function validateSelection(){
    const isDbl = (els.matchType.value === 'doubles');
    if(!els.playerA.value || !els.playerB.value) return false;
    if(isDbl && (!els.partnerA.value || !els.partnerB.value)) return false;
    if(els.playerA.value === els.playerB.value) return false;
    if(isDbl && (els.playerA.value===els.partnerA.value || els.playerB.value===els.partnerB.value)) return false;
    if(isDbl && (new Set([els.playerA.value, els.partnerA.value]).size<2)) return false;
    if(isDbl && (new Set([els.playerB.value, els.partnerB.value]).size<2)) return false;
    return true;
  }

  // 이벤트 바인딩
  els.matchType.addEventListener('change', ()=>{ updateDoublesVisibility(); previewWeights(); });
  [els.playerA, els.playerB, els.partnerA, els.partnerB].forEach(s=>{
    s.addEventListener('change', ()=>{ refreshLevelsBadge(); previewWeights(); });
  });
  els.winnerSel.addEventListener('change', previewWeights);
  els.score.addEventListener('input', previewWeights);

  els.reset.addEventListener('click', ()=>{
    els.playerA.value='';
    els.partnerA.value='';
    els.playerB.value='';
    els.partnerB.value='';
    els.score.value='';
    els.winnerSel.value='A';
    refreshLevelsBadge(); previewWeights();
  });

  els.confirm.addEventListener('click', async()=>{
    if(!validateSelection()){ toast('선수(팀) 선택을 확인하세요'); return; }
    const monthKey = yyyymm(toKST());
    const score = els.score.value || '3-2'; // 입력 없으면 3-2로 처리

    if(els.matchType.value === 'singles'){
      const payload = {
        monthKey,
        playerAId: els.playerA.value,
        playerBId: els.playerB.value,
        levelA: getLevel(els.playerA.value),
        levelB: getLevel(els.playerB.value),
        winner: els.winnerSel.value,
        score
      };
      const res = await confirmSinglesResult(payload);

      // (선택) 경기 로그
      await logMatch(monthKey, { type:'singles', ...payload, weights:res });

      toast('단식 결과 반영 완료');
    }else{
      const a1 = els.playerA.value, a2 = els.partnerA.value;
      const b1 = els.playerB.value, b2 = els.partnerB.value;
      const la1 = getLevel(a1), la2 = getLevel(a2);
      const lb1 = getLevel(b1), lb2 = getLevel(b2);
      const res = await confirmDoublesResult({
        monthKey,
        a1, a2, b1, b2,
        levelAmin: Math.min(la1??99, la2??99),
        levelBmin: Math.min(lb1??99, lb2??99),
        winner: els.winnerSel.value,
        score
      });

      // (선택) 경기 로그
      await logMatch(monthKey, {
        type:'doubles',
        monthKey, a1, a2, b1, b2,
        winner: els.winnerSel.value, score,
        weights:res
      });

      toast('복식 결과 반영 완료');
    }
  });

  // ===== 데이터 로딩 =====
  function fillAllSelects(){
    [els.playerA, els.partnerA, els.playerB, els.partnerB].forEach(fillPlayerSelect);
  }

  // 선수
  onValue(ref(db,'players'), (snap)=>{
    const val = snap.val() || {};
    players = Object.entries(val).map(([id, v])=>({ id, name:v.name, level:v.level }));
    fillAllSelects();
    refreshLevelsBadge();
    previewWeights();
  });

  // 관리자 설정: 복식 가중치
  onValue(ref(db,'config/doubleWeight'), (s)=>{
    doubleWeight = s.val() ?? 0.5;
    previewWeights();
  });

  // 관리자 설정: 실력차 보정
  onValue(ref(db,'config/skillAdjust'), (s)=>{
    const v = s.val();
    if(v && typeof v==='object'){
      skillAdjust = {
        perLevel: Number(v.perLevel ?? 0.05),
        minFav:   Number(v.minFav   ?? 0.6 ),
        maxDog:   Number(v.maxDog   ?? 1.8 )
      };
      previewWeights();
    }
  });

  // 시작
  signInAnonymously(auth).catch(console.error);
  onAuthStateChanged(auth, ()=>{ /* no-op */ });

  // 초기 표시
  updateDoublesVisibility();
</script>
</body>
</html>
