<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>KOEN íƒêµ¬ Â· ì„±ì ì…ë ¥</title>
  <style>
    :root{
      --ink:#0f172a; --muted:#64748b; --card:#fff; --bg:#f5f7fb;
      --primary:#0d47a1; --accent:#2563eb; --ok:#16a34a; --danger:#ef4444;
      --shadow:0 8px 28px rgba(0,0,0,.08)
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif; color:var(--ink); background:var(--bg)}
    header{position:sticky; top:0; z-index:10; background:#fff; border-bottom:1px solid #e5e7eb}
    .wrap{max-width:1040px; margin:0 auto; padding:14px 16px}
    h1{margin:4px 0 6px; font-size:clamp(18px,4vw,24px); color:var(--primary)}
    main{max-width:1040px; margin:16px auto; padding:0 16px 40px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .col{display:flex; flex-direction:column; gap:8px}
    .card{background:var(--card); border:1px solid #e5e7eb; border-radius:16px; padding:14px; box-shadow:var(--shadow); margin:12px 0}
    label{font-size:13px; color:#334155}
    select, input[type="text"], input[type="number"]{padding:8px 10px; border:1px solid #d1d5db; border-radius:10px; background:#fff; min-width:160px}
    .btn{border:1px solid #d1d5db; border-radius:10px; padding:10px 14px; font-size:14px; background:#fff; cursor:pointer}
    .btn.primary{background:var(--accent); color:#fff; border-color:var(--accent)}
    .btn.warn{background:#ef4444; color:#fff; border-color:#ef4444}
    .btn.ok{background:#16a34a; color:#fff; border-color:#16a34a}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .grid{display:grid; gap:14px}
    .grid.cols-2{grid-template-columns:repeat(auto-fit, minmax(280px,1fr))}
    .chip{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid #e5e7eb; background:#f8fafc; font-size:12px}
    .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:18px; background:#111827; color:#fff; padding:10px 14px; border-radius:12px; opacity:0; pointer-events:none; transition:.25s}
    .toast.show{opacity:1}
    .divider{height:1px; background:#e5e7eb; margin:10px 0}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1 style="margin-right:auto">KOEN íƒêµ¬ Â· ì„±ì ì…ë ¥</h1>
      <a class="btn" href="admin.html">âš™ï¸ ê´€ë¦¬ì</a>
      <a class="btn" href="monthly-report.html">ğŸ“Š ì´ë²ˆë‹¬ ì„±ì í‘œ</a>
    </div>
    <div class="row">
      <span class="chip">ì‹¤í—˜íŒ</span>
      <span class="small muted">â€» ê°€ì¤‘ì¹˜ëŠ” ê´€ë¦¬ìì—ì„œ ì„¤ì •í•˜ì„¸ìš”.</span>
    </div>
  </div>
</header>

<main>
  <section class="card">
    <div class="grid cols-2">
      <div class="col">
        <div class="row">
          <label>ê²½ê¸° ì¢…ë¥˜</label>
          <select id="matchType">
            <option value="singles">ë‹¨ì‹</option>
            <option value="doubles">ë³µì‹</option>
          </select>
          <span class="small muted">ë³µì‹ ê°€ì¤‘ì¹˜ëŠ” ê´€ë¦¬ì ì„¤ì • ì‚¬ìš©</span>
        </div>
        <div class="divider"></div>

        <div class="row">
          <label style="min-width:64px">A ì„ ìˆ˜</label>
          <select id="playerA"></select>
          <span id="lvA" class="chip">ë¶€ìˆ˜: -</span>
        </div>
        <div class="row doublesOnly" style="display:none">
          <label style="min-width:64px">A íŒŒíŠ¸ë„ˆ</label>
          <select id="partnerA"></select>
        </div>

        <div class="row">
          <label style="min-width:64px">B ì„ ìˆ˜</label>
          <select id="playerB"></select>
          <span id="lvB" class="chip">ë¶€ìˆ˜: -</span>
        </div>
        <div class="row doublesOnly" style="display:none">
          <label style="min-width:64px">B íŒŒíŠ¸ë„ˆ</label>
          <select id="partnerB"></select>
        </div>

        <div class="divider"></div>

        <div class="row">
          <label>ì„¸íŠ¸ ìŠ¤ì½”ì–´</label>
          <input id="scoreInput" type="text" placeholder="ì˜ˆ: 3-2" style="min-width:120px"/>
          <span class="small muted">í˜•ì‹: 3-2, 2:0 ë“±</span>
        </div>

        <div class="row">
          <label>ìŠ¹ì</label>
          <select id="winnerSel">
            <option value="A">AíŒ€(ë˜ëŠ” Aì„ ìˆ˜)</option>
            <option value="B">BíŒ€(ë˜ëŠ” Bì„ ìˆ˜)</option>
          </select>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button id="confirmBtn" class="btn primary">âœ… ê²½ê¸° í™•ì • & ëˆ„ì  ë°˜ì˜</button>
          <button id="resetBtn" class="btn">ì´ˆê¸°í™”</button>
        </div>
        <div class="small muted" id="preview"></div>
      </div>

      <div class="col">
        <div class="row"><strong>ì ìš©ë  ê°€ì¤‘ì¹˜(ë¯¸ë¦¬ë³´ê¸°)</strong></div>
        <div class="row">
          <div class="chip">ì‹¤ë ¥ì°¨ ë³´ì •: <span id="wSkill">-</span></div>
          <div class="chip">ë³µì‹ ê°€ì¤‘: <span id="wDouble">-</span></div>
          <div class="chip">ìµœì¢… ê°€ì¤‘: <span id="wFinal">-</span></div>
        </div>
        <div class="divider"></div>
        <div class="small muted">ì„ ìˆ˜/ìŠ¹ì/ìŠ¤ì½”ì–´ë¥¼ ë°”ê¾¸ë©´ ìë™ ê°±ì‹ ë©ë‹ˆë‹¤.</div>
      </div>
    </div>
  </section>
</main>

<div id="toast" class="toast">Saved</div>

<!-- Firebase + Logic -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
  import { getDatabase, ref, onValue, get, set, update, push } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  // ===== Firebase ===== (ğŸ”§ ìˆ˜ì • ì§€ì : í”„ë¡œì íŠ¸ ë°”ê¾¸ë©´ ì´ ê°ì²´ë§Œ ë°”ê¾¸ì„¸ìš”)
  const firebaseConfig = {
    apiKey: "AIzaSyC5iq3VY0QtBh8FVn70gi_Gsg7GXzkxdu8",
    authDomain: "koen-pingpong.firebaseapp.com",
    databaseURL: "https://koen-pingpong-default-rtdb.firebaseio.com",
    projectId: "koen-pingpong",
    storageBucket: "koen-pingpong.appspot.com",
    messagingSenderId: "597358811982",
    appId: "1:597358811982:web:b66dcb6a7159fb5f321c1f"
  };
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getDatabase(app);

  // ===== Utils =====
  const $ = (s, ctx=document)=>ctx.querySelector(s);
  const toast = (msg='ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤')=>{
    const t=$('#toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1600);
  };
  const pad = (n)=> String(n).padStart(2,'0');
  const toKST = (t = Date.now()) => new Date( new Date(t).toLocaleString('en-US', { timeZone:'Asia/Seoul' }) );
  const yyyymm = (d)=> `${d.getFullYear()}-${pad(d.getMonth()+1)}`;

  function parseSetScore(scoreStr){
    const m = /^(\d+)\s*[-:]\s*(\d+)$/.exec(String(scoreStr||"").trim());
    if(!m) return { for:0, against:0 };
    return { for:Number(m[1]), against:Number(m[2]) };
  }
  function clamp(min, x, max){ return Math.max(min, Math.min(max, x)); }

  // ===== ì „ì—­ ìƒíƒœ =====
  let players = [];      // {id, name, level}
  let skillAdjust = { perLevel:0.05, minFav:0.6, maxDog:1.8 }; // ê´€ë¦¬ì ì„¤ì • ê¸°ë³¸ê°’
  let doubleWeight = 0.5; // ê´€ë¦¬ì ì„¤ì • ê¸°ë³¸ê°’

  // ===== ë³´ì • ê°€ì¤‘ì¹˜ ê³„ì‚° =====
  // ğŸ”§ ìˆ˜ì • ì§€ì : ë‹¤ë¥¸ í˜ì´ì§€ì—ì„œë„ ë™ì¼ ë¡œì§ì„ ì“°ì„¸ìš”.
  function getAdjustedWeight(levelA, levelB, winner){ // winner: 'A' | 'B'
    const sa = skillAdjust;
    const d = Math.abs((levelA ?? 99) - (levelB ?? 99)); // level ë¯¸ê¸°ì…ì€ í° ê°’
    const aIsFav = (levelA ?? 99) < (levelB ?? 99);      // ìˆ«ì ì‘ì„ìˆ˜ë¡ ìƒìœ„
    const favWin = clamp(sa.minFav, 1 - sa.perLevel * d, 1);
    const dogWin = clamp(1,         1 + sa.perLevel * d, sa.maxDog);
    if(winner === 'A'){
      return aIsFav ? favWin : dogWin;
    }else{
      const bIsFav = !aIsFav;
      return bIsFav ? favWin : dogWin;
    }
  }

  // ===== DB ì ‘ê·¼: ì›”ê°„ ìŠ¤íƒ¯ ëˆ„ì  =====
  // ğŸ”§ ìˆ˜ì • ì§€ì : ëˆ„ì  ê²½ë¡œ/í•„ë“œëª…ì„ í”„ë¡œì íŠ¸ í‘œì¤€ì— ë§ê²Œ ë°”ê¾¸ë ¤ë©´ ì—¬ê¸°ë§Œ ì¡°ì •
  async function applyDeltaToPlayer(monthKey, playerId, delta){
    const pRef = ref(db, `stats/${monthKey}/${playerId}`);
    const snap = await get(pRef);
    const cur = snap.val() || {
      wWins:0, wLosses:0, wSetsFor:0, wSetsAgainst:0,
      matches:0,    // ë¹„ê°€ì¤‘ ê²½ê¸° ìˆ˜
      lastUpdated:0
    };
    const next = {
      wWins:        (cur.wWins        || 0) + (delta.wWins        || 0),
      wLosses:      (cur.wLosses      || 0) + (delta.wLosses      || 0),
      wSetsFor:     (cur.wSetsFor     || 0) + (delta.wSetsFor     || 0),
      wSetsAgainst: (cur.wSetsAgainst || 0) + (delta.wSetsAgainst || 0),
      matches:      (cur.matches      || 0) + (delta.matches      || 0),
      lastUpdated: Date.now()
    };
    await update(pRef, next);
  }

  // ===== ê²½ê¸° í™•ì •(ë‹¨ì‹/ë³µì‹ ê³µí†µ ì§„ì…) =====
  // ğŸ”§ í•µì‹¬ í•¨ìˆ˜: ì—¬ê¸°ì„œ finalWeightë¥¼ ë§Œë“¤ê³  ê° ì„ ìˆ˜ì—ê²Œ ë¸íƒ€ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.
  async function confirmSinglesResult({ monthKey, playerAId, playerBId, levelA, levelB, winner, score }){
    const weight  = getAdjustedWeight(levelA, levelB, winner);
    const dbl     = 1; // ë‹¨ì‹
    const finalWeight = weight * dbl;

    const { for:setsForA, against:setsAgainstA } = parseSetScore(score);
    const setsForB     = setsAgainstA;
    const setsAgainstB = setsForA;

    const deltaA = {
      wWins:        (winner === 'A') ? finalWeight : 0,
      wLosses:      (winner === 'B') ? finalWeight : 0,
      wSetsFor:     setsForA     * finalWeight,
      wSetsAgainst: setsAgainstA * finalWeight,
      matches:      1
    };
    const deltaB = {
      wWins:        (winner === 'B') ? finalWeight : 0,
      wLosses:      (winner === 'A') ? finalWeight : 0,
      wSetsFor:     setsForB     * finalWeight,
      wSetsAgainst: setsAgainstB * finalWeight,
      matches:      1
    };

    await Promise.all([
      applyDeltaToPlayer(monthKey, playerAId, deltaA),
      applyDeltaToPlayer(monthKey, playerBId, deltaB),
    ]);

    return { finalWeight, weight, dbl };
  }

  async function confirmDoublesResult({ monthKey, a1, a2, b1, b2, levelAmin, levelBmin, winner, score }){
    // ë³µì‹ì€ íŒ€ì˜ "ëŒ€í‘œ ë ˆë²¨"ì„ ì–´ë–»ê²Œ ë³¼ì§€ ê²°ì • í•„ìš”:
    // ì—¬ê¸°ì„œëŠ” ê° íŒ€ì˜ "ìµœìƒìœ„ì(ìˆ«ì ê°€ì¥ ì‘ì€ ë¶€ìˆ˜)"ë¡œ ë¹„êµ(ê°„ë‹¨/ì¼ê´€).
    const teamALevel = levelAmin;
    const teamBLevel = levelBmin;

    const skillW = getAdjustedWeight(teamALevel, teamBLevel, winner);
    const dbl    = doubleWeight;            // ê´€ë¦¬ì ì„¤ì •ê°’
    const finalWeight = skillW * dbl;

    const { for:setsForA, against:setsAgainstA } = parseSetScore(score);
    const setsForB     = setsAgainstA;
    const setsAgainstB = setsForA;

    const deltaTeamA = {
      wWins:        (winner === 'A') ? finalWeight : 0,
      wLosses:      (winner === 'B') ? finalWeight : 0,
      wSetsFor:     setsForA     * finalWeight,
      wSetsAgainst: setsAgainstA * finalWeight,
      matches:      1
    };
    const deltaTeamB = {
      wWins:        (winner === 'B') ? finalWeight : 0,
      wLosses:      (winner === 'A') ? finalWeight : 0,
      wSetsFor:     setsForB     * finalWeight,
      wSetsAgainst: setsAgainstB * finalWeight,
      matches:      1
    };

    // ê° íŒ€ 2ëª… ëª¨ë‘ì—ê²Œ ë™ì¼ ë¸íƒ€ ë°˜ì˜
    await Promise.all([
      applyDeltaToPlayer(monthKey, a1, deltaTeamA),
      applyDeltaToPlayer(monthKey, a2, deltaTeamA),
      applyDeltaToPlayer(monthKey, b1, deltaTeamB),
      applyDeltaToPlayer(monthKey, b2, deltaTeamB),
    ]);

    return { finalWeight, weight:skillW, dbl };
  }

  // (ì„ íƒ) ê²½ê¸° ë¡œê·¸ ì €ì¥
  async function logMatch(monthKey, payload){
    const mRef = ref(db, `matches/${monthKey}`);
    await set(push(mRef), { ...payload, ts: Date.now() });
  }

  // ===== UI/ë°ì´í„° ë°”ì¸ë”© =====
  const els = {
    matchType: $('#matchType'),
    playerA:   $('#playerA'),
    partnerA:  $('#partnerA'),
    playerB:   $('#playerB'),
    partnerB:  $('#partnerB'),
    lvA:       $('#lvA'),
    lvB:       $('#lvB'),
    score:     $('#scoreInput'),
    winnerSel: $('#winnerSel'),
    confirm:   $('#confirmBtn'),
    reset:     $('#resetBtn'),
    preview:   $('#preview'),
    wSkill:    $('#wSkill'),
    wDouble:   $('#wDouble'),
    wFinal:    $('#wFinal'),
  };

  function fillPlayerSelect(sel){
    sel.innerHTML = '<option value="">ì„ íƒ</option>';
    players
      .slice()
      .sort((a,b)=> a.name.localeCompare(b.name,'ko'))
      .forEach(p=>{
        const opt=document.createElement('option');
        opt.value=p.id;
        opt.textContent = p.level!=null ? `${p.name} (${p.level})` : `${p.name}`;
        sel.appendChild(opt);
      });
  }

  function findPlayer(id){ return players.find(p=>p.id===id); }
  function getLevel(id){ return findPlayer(id)?.level ?? null; }

  function updateDoublesVisibility(){
    const show = els.matchType.value === 'doubles';
    document.querySelectorAll('.doublesOnly').forEach(el=>{
      el.style.display = show ? '' : 'none';
    });
  }

  function refreshLevelsBadge(){
    const la = getLevel(els.playerA.value);
    const lb = getLevel(els.playerB.value);
    els.lvA.textContent = `ë¶€ìˆ˜: ${la ?? '-'}`;
    els.lvB.textContent = `ë¶€ìˆ˜: ${lb ?? '-'}`;
  }

  function previewWeights(){
    const isDbl = (els.matchType.value === 'doubles');
    const winner = els.winnerSel.value; // 'A' or 'B'
    let skillW = 1, dblW = 1, finalW = 1;

    if(!isDbl){
      const la = getLevel(els.playerA.value);
      const lb = getLevel(els.playerB.value);
      skillW = getAdjustedWeight(la, lb, winner);
      dblW   = 1;
      finalW = skillW * dblW;
    }else{
      const la1 = getLevel(els.playerA.value);
      const la2 = getLevel(els.partnerA.value);
      const lb1 = getLevel(els.playerB.value);
      const lb2 = getLevel(els.partnerB.value);
      // íŒ€ ëŒ€í‘œ ë ˆë²¨: ìµœìƒìœ„ì(ìˆ«ì ê°€ì¥ ì‘ì€ ê°’)
      const teamALvl = Math.min(...[la1, la2].map(v=> v ?? 99));
      const teamBLvl = Math.min(...[lb1, lb2].map(v=> v ?? 99));
      skillW = getAdjustedWeight(teamALvl, teamBLvl, winner);
      dblW   = doubleWeight;
      finalW = skillW * dblW;
    }

    els.wSkill.textContent = isFinite(skillW) ? skillW.toFixed(3) : '-';
    els.wDouble.textContent = isFinite(dblW)   ? dblW.toFixed(3)   : '-';
    els.wFinal.textContent  = isFinite(finalW) ? finalW.toFixed(3) : '-';
  }

  function validateSelection(){
    const isDbl = (els.matchType.value === 'doubles');
    if(!els.playerA.value || !els.playerB.value) return false;
    if(isDbl && (!els.partnerA.value || !els.partnerB.value)) return false;
    if(els.playerA.value === els.playerB.value) return false;
    if(isDbl && (els.playerA.value===els.partnerA.value || els.playerB.value===els.partnerB.value)) return false;
    if(isDbl && (new Set([els.playerA.value, els.partnerA.value]).size<2)) return false;
    if(isDbl && (new Set([els.playerB.value, els.partnerB.value]).size<2)) return false;
    return true;
  }

  // ì´ë²¤íŠ¸ ë°”ì¸ë”©
  els.matchType.addEventListener('change', ()=>{ updateDoublesVisibility(); previewWeights(); });
  [els.playerA, els.playerB, els.partnerA, els.partnerB].forEach(s=>{
    s.addEventListener('change', ()=>{ refreshLevelsBadge(); previewWeights(); });
  });
  els.winnerSel.addEventListener('change', previewWeights);
  els.score.addEventListener('input', previewWeights);

  els.reset.addEventListener('click', ()=>{
    els.playerA.value='';
    els.partnerA.value='';
    els.playerB.value='';
    els.partnerB.value='';
    els.score.value='';
    els.winnerSel.value='A';
    refreshLevelsBadge(); previewWeights();
  });

  els.confirm.addEventListener('click', async()=>{
    if(!validateSelection()){ toast('ì„ ìˆ˜(íŒ€) ì„ íƒì„ í™•ì¸í•˜ì„¸ìš”'); return; }
    const monthKey = yyyymm(toKST());
    const score = els.score.value || '3-2'; // ì…ë ¥ ì—†ìœ¼ë©´ 3-2ë¡œ ì²˜ë¦¬

    if(els.matchType.value === 'singles'){
      const payload = {
        monthKey,
        playerAId: els.playerA.value,
        playerBId: els.playerB.value,
        levelA: getLevel(els.playerA.value),
        levelB: getLevel(els.playerB.value),
        winner: els.winnerSel.value,
        score
      };
      const res = await confirmSinglesResult(payload);

      // (ì„ íƒ) ê²½ê¸° ë¡œê·¸
      await logMatch(monthKey, { type:'singles', ...payload, weights:res });

      toast('ë‹¨ì‹ ê²°ê³¼ ë°˜ì˜ ì™„ë£Œ');
    }else{
      const a1 = els.playerA.value, a2 = els.partnerA.value;
      const b1 = els.playerB.value, b2 = els.partnerB.value;
      const la1 = getLevel(a1), la2 = getLevel(a2);
      const lb1 = getLevel(b1), lb2 = getLevel(b2);
      const res = await confirmDoublesResult({
        monthKey,
        a1, a2, b1, b2,
        levelAmin: Math.min(la1??99, la2??99),
        levelBmin: Math.min(lb1??99, lb2??99),
        winner: els.winnerSel.value,
        score
      });

      // (ì„ íƒ) ê²½ê¸° ë¡œê·¸
      await logMatch(monthKey, {
        type:'doubles',
        monthKey, a1, a2, b1, b2,
        winner: els.winnerSel.value, score,
        weights:res
      });

      toast('ë³µì‹ ê²°ê³¼ ë°˜ì˜ ì™„ë£Œ');
    }
  });

  // ===== ë°ì´í„° ë¡œë”© =====
  function fillAllSelects(){
    [els.playerA, els.partnerA, els.playerB, els.partnerB].forEach(fillPlayerSelect);
  }

  // ì„ ìˆ˜
  onValue(ref(db,'players'), (snap)=>{
    const val = snap.val() || {};
    players = Object.entries(val).map(([id, v])=>({ id, name:v.name, level:v.level }));
    fillAllSelects();
    refreshLevelsBadge();
    previewWeights();
  });

  // ê´€ë¦¬ì ì„¤ì •: ë³µì‹ ê°€ì¤‘ì¹˜
  onValue(ref(db,'config/doubleWeight'), (s)=>{
    doubleWeight = s.val() ?? 0.5;
    previewWeights();
  });

  // ê´€ë¦¬ì ì„¤ì •: ì‹¤ë ¥ì°¨ ë³´ì •
  onValue(ref(db,'config/skillAdjust'), (s)=>{
    const v = s.val();
    if(v && typeof v==='object'){
      skillAdjust = {
        perLevel: Number(v.perLevel ?? 0.05),
        minFav:   Number(v.minFav   ?? 0.6 ),
        maxDog:   Number(v.maxDog   ?? 1.8 )
      };
      previewWeights();
    }
  });

  // ì‹œì‘
  signInAnonymously(auth).catch(console.error);
  onAuthStateChanged(auth, ()=>{ /* no-op */ });

  // ì´ˆê¸° í‘œì‹œ
  updateDoublesVisibility();
</script>
</body>
</html>
