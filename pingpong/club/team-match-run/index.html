<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ë‹¨ì²´ì „ ì§„í–‰</title>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <!-- html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    /* ===== ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ===== */
    body {
      font-family: 'Segoe UI', sans-serif;
      padding: 10px;
      margin: 0;
      background: #f5f7fa;
    }

    h2 {
      text-align: center;
      color: #0d47a1;
      margin: 10px 0 20px;
      font-size: clamp(20px, 4vw, 26px);
    }

    /* ===== ì»¨íŠ¸ë¡¤ ì˜ì—­ ===== */
    .config {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      max-width: 640px;
      margin: 0 auto 20px;
      align-items: center;
      justify-content: center;
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    .config label {
      font-weight: bold;
      color: #333;
      text-align: center;
      font-size: clamp(14px, 2.8vw, 16px);
    }
    select, button {
      padding: 8px 12px;
      font-size: clamp(14px, 2.8vw, 16px);
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #f8f9fa;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #e3f2fd; }
    button {
      background: #1976d2;
      color: white;
      font-weight: 500;
    }
    button:hover { background: #1565c0; }

    /* ===== í‘œ ê³µí†µ ===== */
    table {
      border-collapse: collapse;
      width: 100%;
      background: #fff;
      font-size: clamp(13px, 2.5vw, 17px);
      table-layout: auto;
    }

    th, td {
      border: 1px solid #888;
      padding: 4px 6px;
      text-align: center;
      white-space: nowrap;
    }

    th:nth-child(1), td:nth-child(1) { width: 12%; }
    th:nth-child(2), td:nth-child(2) { width: auto; }
    th:nth-child(3), td:nth-child(3) { width: 20%; }

    th {
      background: #e3f2fd;
      font-weight: bold;
    }

    /* ===== ëŒ€ì§„í‘œ ì¹´ë“œ ===== */
    .match-card {
      position: relative;
      overflow: hidden;
      border: 2px solid #0d47a1;
      padding: 12px;
      margin: 15px auto;
      width: 100%;
      max-width: 640px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.08);
    }
    .match-card h3 {
      text-align: center;
      margin-bottom: 12px;
      font-size: clamp(18px, 4vw, 22px);
      color: #0d47a1;
    }

    /* ===== ìˆœìœ„í‘œ ===== */
    .scroll-table {
      border: 1px solid #ccc;
      border-radius: 8px;
      margin: 15px auto;
      width: 100%;
      max-width: 640px;
      overflow-x: auto;
    }
    .scroll-table th:first-child,
    .scroll-table td:first-child {
      background: #ffe082;
      font-weight: bold;
    }

    /* ===== ëª¨ë‹¬ ===== */
    .local-modal-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 9999;
    }
    .local-modal {
      background: #fff;
      border-radius: 12px;
      padding: 16px;
      width: min(420px, 92%);
      max-height: 95vh;
      overflow-y: auto;
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    }
    .local-modal h4 {
      margin: 6px 0 10px;
      font-size: 18px;
      color: #0d47a1;
      text-align: center;
    }
    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 10px;
    }
    .modal-actions button {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      background: #1976d2;
      color: #fff;
      cursor: pointer;
    }
    .modal-actions button:hover { background: #1565c0; }

    /* ===== ëª¨ë°”ì¼ ì „ìš© ===== */
    @media (max-width: 480px) {
      .config {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 6px;
        padding: 8px;
      }
      select, button {
        font-size: 14px;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <div id="teamListArea" style="margin-bottom:30px;"></div>
  <h2>ë‹¨ì²´ì „ ì§„í–‰</h2>

  <div class="config">
    <label>ë‹¨ì‹
      <select id="singlesCnt">
        <option value="0">0ê²½ê¸°</option>
        <option value="1">1ê²½ê¸°</option>
        <option value="2">2ê²½ê¸°</option>
        <option value="3" selected>3ê²½ê¸°</option>
        <option value="4">4ê²½ê¸°</option>
        <option value="5">5ê²½ê¸°</option>
      </select>
    </label>

    <label>ë³µì‹
      <select id="doublesCnt">
        <option value="0">0ê²½ê¸°</option>
        <option value="1">1ê²½ê¸°</option>
        <option value="2" selected>2ê²½ê¸°</option>
        <option value="3">3ê²½ê¸°</option>
        <option value="4">4ê²½ê¸°</option>
      </select>
    </label>

    <button onclick="manualMatch()">ìˆ˜ë™ìƒì„±</button>
    <button onclick="autoMatch()">ìë™ìƒì„±</button>
    <button onclick="saveAsImage()">ëŒ€ì§„ê²°ê³¼ ì €ì¥</button>
  </div>

  <div id="captureArea">
    <div id="summaryArea"></div>
    <div id="rankingArea" style="margin-top:40px;"></div>
  </div>

<script>
/* ---------------- Firebase ì´ˆê¸°í™” ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyA-tp3iJ8-n0yrrd8lwE1IgOdsmDqyh69k",
  authDomain: "koen-teamleague.firebaseapp.com",
  projectId: "koen-teamleague",
  storageBucket: "koen-teamleague.appspot.com",
  messagingSenderId: "487164547059",
  appId: "1:487164547059:web:658a10c8bfe7272ca78c86",
  databaseURL: "https://koen-teamleague-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------------- ì „ì—­ ìƒíƒœ ---------------- */
let teamNames = [], teamData = {};
let autoMode = -1; 
const modeNames = ["ê³ ìˆ˜ ìš°ì„ ", "í•˜ìˆ˜ ìš°ì„ ", "ì¡°í•© ìš°ì„ "];

/* ---------------- ë¹„ë°€ë²ˆí˜¸ í™•ì¸ ---------------- */
function checkPassword() {
  const pw = prompt("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
  if (pw === null) return false;   
  if (pw === "7910") return true;
  alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.");
  return false;
}

/* ---------------- ë¡œê·¸ì¸ ì²˜ë¦¬ ---------------- */
async function requireAuth() {
  const u = firebase.auth().currentUser;
  if (u) return u;
  await firebase.auth().signInAnonymously();
  return new Promise(resolve => {
    const unsub = firebase.auth().onAuthStateChanged(user => {
      if (user) { unsub(); resolve(user); }
    });
  });
}

firebase.auth().onAuthStateChanged(async (user) => {
  if (!user) {
    try { await firebase.auth().signInAnonymously(); }
    catch (e) { console.error("ìµëª… ë¡œê·¸ì¸ ì‹¤íŒ¨:", e); }
    return;
  }
  await loadTeams();
  listenToMatchUpdates();
});

/* ---------------- íŒ€ ë¡œë“œ ---------------- */
function loadTeams() {
  return db.ref("teams").once("value").then(snap => {
    const raw = snap.val();
    teamData = {};
    teamNames = [];
    if (!raw) {
      alert("íŒ€ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € íŒ€ì„ êµ¬ì„±í•´ì£¼ì„¸ìš”.");
      return false;
    }
    Object.values(raw).forEach(team => {
      teamData[team.teamName] = team;
      teamNames.push(team.teamName);
    });
    renderTeamList();
    return true;
  });
}

function renderTeamList() {
  let html = '<h3 style="text-align:center">ğŸ“‹ íŒ€ êµ¬ì„± í˜„í™©</h3><table><tr><th>íŒ€ëª…</th><th>íŒ€ì›</th></tr>';
  teamNames.forEach(team => {
    const players = (teamData[team].players||[]).map(p => `${p.name}(${p.level})`).join(', ');
    html += `<tr><td>${team}</td><td>${players}</td></tr>`;
  });
  html += '</table>';
  document.getElementById('teamListArea').innerHTML = html;
}

/* ---------------- ìˆ˜ë™ ëŒ€ì§„ ìƒì„± ---------------- */
async function manualMatch() {
  if (!checkPassword()) return;
  const ok = await loadTeams();
  if (!ok || teamNames.length === 0) return;

  await requireAuth();
  await db.ref("matches").remove();

  const singles = parseInt(document.getElementById("singlesCnt").value, 10);
  const doubles = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  for (let i = 0; i < teamNames.length; i++) {
    for (let j = i + 1; j < teamNames.length; j++) {
      const matchList = [];
      for (let s = 0; s < singles; s++)
        matchList.push({ label: `${s + 1}ë‹¨`, players: "ë¯¸ì • vs ë¯¸ì •", result: "-" });
      for (let d = 0; d < doubles; d++)
        matchList.push({ label: `${d + 1}ë³µ`, players: "ë¯¸ì •/ë¯¸ì • vs ë¯¸ì •/ë¯¸ì •", result: "-" });
      const key = `${teamNames[i]}_vs_${teamNames[j]}`;
      updates[`matches/${key}`] = { teamA: teamNames[i], teamB: teamNames[j], matchList };
    }
  }
  await db.ref().update(updates);
}

/* ---------------- ìë™ ëŒ€ì§„ ìƒì„± ---------------- */
async function autoMatch() {
  if (!checkPassword()) return;
  const ok = await loadTeams();
  if (!ok || teamNames.length === 0) return;

  autoMode = (autoMode + 1) % 3;
  alert(`ìë™ ìƒì„± ëª¨ë“œ: ${modeNames[autoMode]}`);

  await requireAuth();
  await db.ref("matches").remove();

  const singlesCnt = parseInt(document.getElementById("singlesCnt").value, 10);
  const doublesCnt = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  for (let i = 0; i < teamNames.length; i++) {
    for (let j = i + 1; j < teamNames.length; j++) {
      const teamA = teamNames[i], teamB = teamNames[j];
      const A = [...(teamData[teamA].players||[])].sort((a,b)=>a.level-b.level);
      const B = [...(teamData[teamB].players||[])].sort((a,b)=>a.level-b.level);

      const singles = generateSinglesPairsByMode(A, B, singlesCnt, autoMode);
      const doubles = generateDoublesPairsByMode(A, B, doublesCnt, autoMode);

      const matchList = [];
      singles.forEach((m, idx) => {
        matchList.push({
          label: `${idx + 1}ë‹¨`,
          players: `${m.a.name}(${m.a.level}) vs ${m.b.name}(${m.b.level})`,
          result: "-"
        });
      });
      doubles.forEach((m, idx) => {
        matchList.push({
          label: `${idx + 1}ë³µ`,
          players: `${m.a1.name}(${m.a1.level})/${m.a2.name}(${m.a2.level}) vs ${m.b1.name}(${m.b1.level})/${m.b2.name}(${m.b2.level})`,
          result: "-"
        });
      });

      const key = `${teamA}_vs_${teamB}`;
      updates[`matches/${key}`] = { teamA, teamB, matchList };
    }
  }
  await db.ref().update(updates);
}

/* -------- ë‹¨ì‹ ìƒì„± -------- */
function generateSinglesPairsByMode(A, B, need, mode) {
  if (need <= 0) return [];
  const pairs = [];

  for (let ai = 0; ai < A.length; ai++) {
    for (let bi = 0; bi < B.length; bi++) {
      const a = A[ai], b = B[bi];
      const diff = Math.abs(a.level - b.level);
      const bias = (mode === 1) ? -(ai + bi) : (ai + bi); 
      pairs.push({ a, b, diff, bias });
    }
  }

  pairs.sort((x, y) => (x.diff !== y.diff ? x.diff - y.diff : x.bias - y.bias));

  const usedA = new Set();
  const usedB = new Set();
  const result = [];

  for (const p of pairs) {
    if (result.length >= need) break;
    if (usedA.has(p.a.name) || usedB.has(p.b.name)) continue;
    result.push(p);
    usedA.add(p.a.name);
    usedB.add(p.b.name);
  }

  if (result.length < need) {
    for (const p of pairs) {
      if (result.length >= need) break;
      if (result.some(r => r.a.name === p.a.name && r.b.name === p.b.name)) continue;
      result.push(p);
    }
  }
  return result.slice(0, need);
}

/* -------- ë³µì‹ ìƒì„± -------- */
const strongFilter = (i, j, n) => (i < Math.ceil(n/2) && j < Math.ceil(n/2));
const weakFilter   = (i, j, n) => (i >= Math.floor(n/2) && j >= Math.floor(n/2));
const mixedFilter  = (i, j, n) => ((i < Math.ceil(n/2) && j >= Math.floor(n/2)) || (j < Math.ceil(n/2) && i >= Math.floor(n/2)));

function allTeamPairsFiltered(players, filterFn) {
  const res = [];
  const n = players.length;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (filterFn && !filterFn(i, j, n)) continue;
      const p1 = players[i], p2 = players[j];
      res.push({ p1, p2, sum: p1.level + p2.level, i, j });
    }
  }
  return res;
}
function allTeamPairs(players) { return allTeamPairsFiltered(players, null); }
function pairKeySorted(n1, n2) { return [n1, n2].sort().join('/'); }
function versusKey(a1,a2,b1,b2){ return `${pairKeySorted(a1.name,a2.name)}||${pairKeySorted(b1.name,b2.name)}`; }

function greedyMatchPairs(
  pairsA, pairsB, need,
  usedPlayersA, usedPlayersB,
  usedPairsA, usedPairsB,
  usedVersus,
  allowDuplicates = false,
  lockedPairs = new Set()
) {
  const res = [];

  while (res.length < need) {
    let best = null;
    let bestDiff = Infinity;

    for (const a of pairsA) {
      const aPlayers = [a.p1.name, a.p2.name];
      const aKey = pairKeySorted(a.p1.name, a.p2.name);
      if ((!allowDuplicates && usedPairsA.has(aKey)) || lockedPairs.has(aKey)) continue;
      if (!allowDuplicates && (usedPlayersA.has(aPlayers[0]) || usedPlayersA.has(aPlayers[1]))) continue;

      for (const b of pairsB) {
        const bPlayers = [b.p1.name, b.p2.name];
        const bKey = pairKeySorted(b.p1.name, b.p2.name);
        if ((!allowDuplicates && usedPairsB.has(bKey)) || lockedPairs.has(bKey)) continue;
        if (!allowDuplicates && (usedPlayersB.has(bPlayers[0]) || usedPlayersB.has(bPlayers[1]))) continue;

        const vKey = versusKey(a.p1, a.p2, b.p1, b.p2);
        if ((!allowDuplicates && usedVersus.has(vKey)) || lockedPairs.has(vKey)) continue;

        const diff = Math.abs(a.sum - b.sum);
        if (diff < bestDiff) {
          bestDiff = diff;
          best = { a, b, aPlayers, bPlayers, aKey, bKey, vKey };
        }
      }
    }

    if (!best) break;

    res.push({ a1: best.a.p1, a2: best.a.p2, b1: best.b.p1, b2: best.b.p2 });

    best.aPlayers.forEach(name => usedPlayersA.add(name));
    best.bPlayers.forEach(name => usedPlayersB.add(name));
    usedPairsA.add(best.aKey);
    usedPairsB.add(best.bKey);
    usedVersus.add(best.vKey);

    if (res.length <= 2) {
      lockedPairs.add(best.aKey);
      lockedPairs.add(best.bKey);
      lockedPairs.add(best.vKey);
    }
  }

  return res;
}

function generateDoublesPairsByMode(A, B, need, mode) {
  if (need <= 0) return [];

  const usedPlayersA = new Set();
  const usedPlayersB = new Set();
  const usedPairsA = new Set();
  const usedPairsB = new Set();
  const usedVersus = new Set();
  const lockedPairs = new Set();

  let bucketOrder = [];
  if (mode === 0) { 
    bucketOrder = [
      { a: allTeamPairsFiltered(A, strongFilter), b: allTeamPairsFiltered(B, strongFilter) },
      { a: allTeamPairsFiltered(A, weakFilter),   b: allTeamPairsFiltered(B, weakFilter) },
      { a: allTeamPairs(A),                       b: allTeamPairs(B) }
    ];
  } else if (mode === 1) { 
    bucketOrder = [
      { a: allTeamPairsFiltered(A, weakFilter),   b: allTeamPairsFiltered(B, weakFilter) },
      { a: allTeamPairsFiltered(A, strongFilter), b: allTeamPairsFiltered(B, strongFilter) },
      { a: allTeamPairs(A),                       b: allTeamPairs(B) }
    ];
  } else { 
    bucketOrder = [
      { a: allTeamPairsFiltered(A, mixedFilter),  b: allTeamPairsFiltered(B, mixedFilter) },
      { a: allTeamPairs(A),                       b: allTeamPairs(B) }
    ];
  }

  let result = [];

  for (const bucket of bucketOrder) {
    if (result.length >= 2 || result.length >= need) break;
    const add = greedyMatchPairs(
      bucket.a, bucket.b, 2 - result.length,
      usedPlayersA, usedPlayersB,
      usedPairsA, usedPairsB,
      usedVersus,
      false,
      lockedPairs
    );
    result = result.concat(add);
  }

  if (result.length < need) {
    for (const bucket of bucketOrder) {
      if (result.length >= need) break;
      const add = greedyMatchPairs(
        bucket.a, bucket.b, need - result.length,
        usedPlayersA, usedPlayersB,
        usedPairsA, usedPairsB,
        usedVersus,
        true,
        lockedPairs
      );
      result = result.concat(add);
    }
  }

  if (result.length < need) {
    for (const bucket of bucketOrder) {
      if (result.length >= need) break;
      const add = greedyMatchPairs(
        bucket.a, bucket.b, need - result.length,
        new Set(), new Set(),
        new Set(), new Set(),
        new Set(),
        true,
        new Set()
      );
      result = result.concat(add);
    }
  }

  return result.slice(0, need);
}

/* ---------------- ê²½ê¸° ì¹´ë“œ ì¶œë ¥ ---------------- */
function renderMatchCard(teamA, teamB, matchList) {
  let html = `<div class='match-card'><h3>${teamA} VS ${teamB}</h3><table>`;
  html += `<thead><tr><th>ê²½ê¸°</th><th>ì¶œì „ ì„ ìˆ˜</th><th>ê²°ê³¼</th></tr></thead><tbody>`;
  matchList.forEach((m) => {
    const players = m.players || "ë¯¸ì • vs ë¯¸ì •";
    html += `<tr>
      <td>${m.label}</td>
      <td onclick="openPlayerPopup('${teamA}','${teamB}',this)">${players}</td>
      <td onclick="openResultPopup(this)" style="cursor:pointer;">${m.result||"-"}</td>
    </tr>`;
  });
  html += `</tbody></table></div>`;
  document.getElementById("summaryArea").innerHTML += html;
}

/* ---------------- ì¹´ë“œ ë‚´ë¶€ ëª¨ë‹¬ ---------------- */
let modalTargetCell = null;
let modalContext = null;

function openLocalModal(container, contentHTML) {
  closeLocalModal();
  const backdrop = document.createElement('div');
  backdrop.className = 'local-modal-backdrop';
  const modal = document.createElement('div');
  modal.className = 'local-modal';
  modal.innerHTML = contentHTML;
  backdrop.appendChild(modal);
  container.appendChild(backdrop);
}

function closeLocalModal() {
  document.querySelectorAll('.local-modal-backdrop').forEach(el => el.remove());
  modalTargetCell = null;
  modalContext = null;
}

/* ---------------- ì„ ìˆ˜ ì„ íƒ íŒì—… ---------------- */
function openPlayerPopup(teamA, teamB, cell) {
  const isDoubles = cell.innerText.includes("/");
  const inputType = isDoubles ? 'checkbox' : 'radio';

  const playersA = (teamData[teamA].players||[]).map(p =>
    `<label><input type='${inputType}' name='teamA' value="${p.name}"> ${p.name}(${p.level})</label>`).join('<br>');
  const playersB = (teamData[teamB].players||[]).map(p =>
    `<label><input type='${inputType}' name='teamB' value="${p.name}"> ${p.name}(${p.level})</label>`).join('<br>');

  const inner = `
    <h4>${teamA} ${isDoubles ? '(2ëª… ì„ íƒ)' : '(1ëª… ì„ íƒ)'}</h4>
    <div>${playersA}</div>
    <hr>
    <h4>${teamB} ${isDoubles ? '(2ëª… ì„ íƒ)' : '(1ëª… ì„ íƒ)'}</h4>
    <div>${playersB}</div>
    <div class="modal-actions">
      <button onclick="${isDoubles ? `setDoubles()` : `setSingles()`}">ì„ íƒ ì™„ë£Œ</button>
      <button onclick="closeLocalModal()">ë‹«ê¸°</button>
    </div>
  `;
  modalTargetCell = cell;
  modalContext = { teamA, teamB, isDoubles };
  openLocalModal(document.body, inner);
}

function findLevel(teamName, playerName){
  const p = (teamData[teamName].players||[]).find(x=>x.name===playerName);
  return p ? p.level : '?';
}

async function setSingles() {
  if (!modalTargetCell || !modalContext) return;
  await requireAuth();

  const { teamA, teamB } = modalContext;
  const modal = document.querySelector('.local-modal');

  const selectedA = modal.querySelector("input[name='teamA']:checked");
  const selectedB = modal.querySelector("input[name='teamB']:checked");
  if (!selectedA || !selectedB) {
    alert("ì–‘ íŒ€ì—ì„œ ê°ê° 1ëª…ì”© ì„ íƒí•´ì£¼ì„¸ìš”.");
    return;
  }

  const aTxt = `${selectedA.value}(${findLevel(teamA, selectedA.value)})`;
  const bTxt = `${selectedB.value}(${findLevel(teamB, selectedB.value)})`;
  modalTargetCell.innerText = `${aTxt} vs ${bTxt}`;

  const card = modalTargetCell.closest(".match-card");
  const [aTeam,bTeam] = card.querySelector("h3").innerText.split(" VS ");
  const teamKey = `${aTeam}_vs_${bTeam}`;
  const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(modalTargetCell.parentElement);

  await db.ref(`matches/${teamKey}/matchList/${rowIndex}/players`).set(`${aTxt} vs ${bTxt}`);
  closeLocalModal();
}

async function setDoubles() {
  if (!modalTargetCell || !modalContext) return;
  await requireAuth();

  const { teamA, teamB } = modalContext;
  const modal = document.querySelector('.local-modal');

  const selectedA = Array.from(modal.querySelectorAll("input[name='teamA']:checked"));
  const selectedB = Array.from(modal.querySelectorAll("input[name='teamB']:checked"));

  if (selectedA.length !== 2 || selectedB.length !== 2) {
    alert("ê° íŒ€ì—ì„œ 2ëª…ì”© ì„ íƒí•´ì£¼ì„¸ìš”");
    return;
  }

  const a1 = selectedA[0].value, a2 = selectedA[1].value;
  const b1 = selectedB[0].value, b2 = selectedB[1].value;

  const aTxt = `${a1}(${findLevel(teamA,a1)})/${a2}(${findLevel(teamA,a2)})`;
  const bTxt = `${b1}(${findLevel(teamB,b1)})/${b2}(${findLevel(teamB,b2)})`;

  modalTargetCell.innerText = `${aTxt} vs ${bTxt}`;

  const card = modalTargetCell.closest(".match-card");
  const [aTeam,bTeam] = card.querySelector("h3").innerText.split(" VS ");
  const teamKey = `${aTeam}_vs_${bTeam}`;
  const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(modalTargetCell.parentElement);

  await db.ref(`matches/${teamKey}/matchList/${rowIndex}/players`).set(`${aTxt} vs ${bTxt}`);
  closeLocalModal();
}

/* ---------------- ê²½ê¸° ê²°ê³¼ íŒì—… ---------------- */
function openResultPopup(cell) {
  const card = cell.closest(".match-card");
  const playerText = cell.parentElement.children[1].innerText;
  const [teamA, teamB] = card.querySelector("h3").innerText.split(" VS ");
  const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(cell.parentElement);

  modalTargetCell = cell;
  modalContext = { teamA, teamB, rowIndex };

  const scores = ["3:2","3:1","3:0","0:0","0:3","1:3","2:3"];
  const inner = `
    <h4>ê²½ê¸° ê²°ê³¼ ì…ë ¥</h4>
    <p style="text-align:center;margin:6px 0 12px;">${playerText}</p>
    <div style="display:flex;flex-wrap:wrap;gap:6px;justify-content:center;">
      ${scores.map(s=>`<button onclick="setMatchResult('${s}')">${s}</button>`).join("")}
    </div>
    <div class="modal-actions">
      <button onclick="closeLocalModal()">ë‹«ê¸°</button>
    </div>
  `;
  openLocalModal(document.body, inner);
}

async function setMatchResult(score) {
  if (!modalTargetCell || !modalContext) return;
  await requireAuth();

  const { teamA, teamB, rowIndex } = modalContext;

  const row = modalTargetCell.parentElement;
  const playerCell = row.children[1];
  const text = playerCell.innerText;

  const [a, b] = score.split(":").map(Number);
  if (!isNaN(a) && !isNaN(b) && text.includes(" vs ")) {
    let [aNames, bNames] = text.split(" vs ");
    if (a > b) playerCell.innerHTML = `<strong>${aNames}</strong> vs ${bNames}`;
    else if (b > a) playerCell.innerHTML = `${aNames} vs <strong>${bNames}</strong>`;
    else playerCell.innerHTML = `${aNames} vs ${bNames}`;
  }

  modalTargetCell.innerText = score;

  const teamKey = `${teamA}_vs_${teamB}`;
  await db.ref(`matches/${teamKey}/matchList/${rowIndex}/result`).set(score);

  closeLocalModal();
  calculateTeamResults();
}

/* ---------------- ì‹¤ì‹œê°„ Firebase ë¦¬ìŠ¤ë„ˆ ---------------- */
function listenToMatchUpdates() {
  db.ref("matches").on("value", snap => {
    const matches = snap.val();
    document.getElementById("summaryArea").innerHTML = "";
    if (!matches) { document.getElementById("rankingArea").innerHTML = ""; return; }
    for (const key in matches) {
      const { teamA, teamB } = matches[key];
      let list = matches[key].matchList;
      list = Array.isArray(list) ? list : Object.values(list||{});
      renderMatchCard(teamA, teamB, list);
    }
    calculateTeamResults();
  });
}

/* ---------------- ìˆœìœ„ ê³„ì‚° ---------------- */
function calculateTeamResults() {
  const cards = document.querySelectorAll(".match-card");
  const stats = {};
  const teams = new Set();

  cards.forEach(card => {
    const [a,b] = card.querySelector("h3").innerText.split(" VS ");
    teams.add(a); teams.add(b);
  });
  teams.forEach(t => stats[t] = { win:0, lose:0, setDiff:0 });

  cards.forEach(card => {
    const [teamA, teamB] = card.querySelector("h3").innerText.split(" VS ");
    const rows = card.querySelectorAll("tbody tr");
    let wA=0, wB=0, sA=0, sB=0;
    rows.forEach(r => {
      const result = r.children[2].innerText.trim();
      if (!result.includes(":")) return;
      const [a,b] = result.split(":").map(Number);
      if (a>b) wA++; else if (b>a) wB++;
      sA += a||0; sB += b||0;
    });
    stats[teamA].win += wA; stats[teamA].lose += wB; stats[teamA].setDiff += (sA-sB);
    stats[teamB].win += wB; stats[teamB].lose += wA; stats[teamB].setDiff += (sB-sA);
  });

  const sorted = Object.entries(stats).sort((x,y)=>{
    if (y[1].win !== x[1].win) return y[1].win - x[1].win;
    return y[1].setDiff - x[1].setDiff;
  });

  let html = '<h3 style="text-align:center">ğŸ“Š íŒ€ë³„ ê²½ê¸°ê²°ê³¼ ë° ìˆœìœ„í‘œ</h3>';
  html += '<div class="scroll-table"><table><thead><tr><th>íŒ€ëª…</th><th>ìŠ¹</th><th>íŒ¨</th><th>ì„¸íŠ¸ë“ì‹¤</th><th>ìˆœìœ„</th></tr></thead><tbody>';
  sorted.forEach(([team, st], idx)=>{
    html += `<tr><td>${team}</td><td>${st.win}</td><td>${st.lose}</td><td>${st.setDiff}</td><td>${idx+1}</td></tr>`;
  });
  html += '</tbody></table></div>';
  document.getElementById("rankingArea").innerHTML = html;
}

/* ---------------- ì´ë¯¸ì§€ ì €ì¥ ---------------- */
function saveAsImage() {
  const captureArea = document.getElementById("captureArea");
  html2canvas(captureArea, {
    scale: 2,
    scrollX: 0,
    scrollY: 0,
    useCORS: true
  }).then(canvas => {
    const link = document.createElement("a");
    link.download = `ë‹¨ì²´ì „_ëŒ€ì§„ê²°ê³¼_${new Date().toISOString().slice(0,10)}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
  });
}
</script>
</body>
</html>
