<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
 
   <!-- âœ… ì¹´ì¹´ì˜¤í†¡ ë¯¸ë¦¬ë³´ê¸° (Open Graph) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="ë‹¨ì²´ì „ ì§„í–‰ í˜ì´ì§€">
  <meta property="og:description" content="íƒêµ¬ ë‹¨ì²´ì „ ì‹¤ì‹œê°„ ê²½ê¸° ê¸°ë¡ ë° ìˆœìœ„ í™•ì¸">
  <meta property="og:image" content="https://sensational-tulumba-65e97e.netlify.app/pingpong/club/team-match-run/images/sinyubin.png">

  <meta property="og:url" content="https://bit.ly/ë‹¨ì²´ì „ì§„í–‰">
 
   <title>ë‹¨ì²´ì „ ì§„í–‰</title>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <!-- html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
  /* ì „ì²´ í™”ë©´ ë ˆì´ì•„ì›ƒ */
body {
  font-family: 'Segoe UI', sans-serif;
  padding: 10px;
  margin: 0;
  background: #f5f7fa;
}

/* ì œëª© */
h2 {
  text-align: center;
  color: #0d47a1;
  margin: 10px 0 20px;
  font-size: clamp(20px, 4vw, 26px);
}

/* ===== ì»¨íŠ¸ë¡¤ ì˜ì—­ ===== */
.config {
  display: flex;
  flex-direction: column; /* âœ… ì„¸ë¡œë¡œ ë‚˜ë€íˆ ë°°ì¹˜ */
  gap: 10px;
  max-width: 640px;
  margin: 0 auto 20px;
  align-items: center;
  background: #fff;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

.config label {
  font-weight: bold;
  color: #333;
  text-align: center;
  font-size: clamp(14px, 2.8vw, 16px);
}

/* ===== ë²„íŠ¼ ê³µí†µ ===== */
button {
  padding: 12px 16px;
  font-size: clamp(15px, 3vw, 18px);
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
  font-weight: 600;
  color: #fff;
}

button:hover {
  transform: translateY(-2px);
}

/* ===== ìƒì„± ë²„íŠ¼ (ì´ˆë¡ìƒ‰) ===== */
.btn-generate {
  font-size: 18px;     
  padding: 10px 10px;  /* ë†’ì´ì™€ ë„ˆë¹„ */
  background-color: #e7160f; /* ê¸°ë³¸ ë¹¨ê°• */
  min-width: 90px;  /* âœ… ëª¨ë°”ì¼ ëŒ€ì‘ */
  text-align: center;
}
.btn-generate:hover {
  background-color: #43a047;
}

/* ===== ê²°ê³¼ ì €ì¥ ë²„íŠ¼ (íŒŒë‘ìƒ‰) ===== */
.btn-save {
  font-size: 18px;     
  padding: 10px 10px;  /* ë†’ì´ì™€ ë„ˆë¹„ */
  background-color: #1976d2; /* ê¸°ë³¸ íŒŒë‘ */
  min-width: 90px;  /* âœ… ëª¨ë°”ì¼ ëŒ€ì‘ */
  text-align: center;
}
.btn-save:hover {
  background-color: #1565c0;
}

/* ===== ê³µìœ  ë²„íŠ¼ (ë³´ë¼ìƒ‰) ===== */
.btn-share {
  font-size: 18px;     
  padding: 10px 10px;  /* ë†’ì´ì™€ ë„ˆë¹„ */
  background-color: #7b1fa2; /* ê¸°ë³¸ ë³´ë¼ */
  min-width: 90px;  /* âœ… ëª¨ë°”ì¼ ëŒ€ì‘ */
  text-align: center;
}
.btn-share:hover {
  background-color: #6a1b9a;
}


/* ===== í…Œì´ë¸” ===== */
table {
  border-collapse: collapse;
  width: 100%;
  background: #fff;
  font-size: clamp(14px, 3vw, 18px); /* ê¸€ì”¨ í¬ê¸° í™•ëŒ€ */
}
th, td {
  border: 1px solid #888;
  padding: clamp(6px, 2vw, 10px); /* ì…€ ë†’ì´ ë„‰ë„‰í•˜ê²Œ */
  text-align: center;
}
th { background: #e3f2fd; }

/* ===== ëŒ€ì§„í‘œ ì¹´ë“œ ===== */
.match-card {
  border: 2px solid #0d47a1;
  padding: 12px;
  margin: 15px auto;
  width: 100%;
  max-width: 640px;
  background: #fff;
  border-radius: 10px;
  box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
}
.match-card h3 {
  text-align: center;
  margin-bottom: 12px;
  font-size: clamp(18px, 4vw, 22px);
  color: #0d47a1;
}

/* ===== ìˆœìœ„í‘œ ===== */
.scroll-table {
  border: 1px solid #ccc;
  border-radius: 8px;
  margin: 15px auto;
  width: 100%;
  max-width: 640px;
  overflow-x: auto;
}
.scroll-table table {
  border-collapse: collapse;
  width: 100%;
}
.scroll-table th:first-child,
.scroll-table td:first-child {
  background: #ffe082;
  font-weight: bold;
}

/* ëª¨ë°”ì¼ í™”ë©´ ì „ìš© */
@media (max-width: 400px) {
  .config {
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 6px;
    padding: 5px;
  }
  select, button {
    font-size: 14px;
    padding: 6px;
  }
}

/* ===== íŒì—… (ì¤‘ì•™ ê³ ì •) ===== */
.popup {
  position: fixed; /* í™”ë©´ ê¸°ì¤€ ê³ ì • */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #fff;
  border: 2px solid #1976d2;
  border-radius: 8px;
  padding: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  z-index: 1001;
  width: 80%;
  max-width: 400px;
  display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
}

/* íŒì—… ë’¤ ì–´ë‘ìš´ ë°°ê²½ */
#popupOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.4);
  z-index: 1000;
  display: none;
}

.popup button {
  font-size: 14px;
  padding: 6px 10px;
  margin: 3px;
  min-width: 40px;    /* ìµœì†Œ ë²„íŠ¼ ê°€ë¡œí­ */
  /* max-width: 40px; */  /* ìµœëŒ€ ë²„íŠ¼ ê°€ë¡œí­ */
  /*display: inline-block; /* ë²„íŠ¼ì´ ìë™ìœ¼ë¡œ ë‚˜ë€íˆ ë°°ì¹˜ë˜ë„ë¡ */
 } 



/* ë²„íŠ¼ ê·¸ë£¹ (í•­ìƒ í•œ ì¤„ ìœ ì§€) */
.btn-group {
  display: flex;
  flex-wrap: nowrap; /* âœ… ì¤„ë°”ê¿ˆ ë°©ì§€ */
  gap: 6px;          /* ë²„íŠ¼ ê°„ ê°„ê²© */
  justify-content: center;
}

/* ë‹¨ì‹/ë³µì‹ ì„ íƒ ì˜ì—­ ê°€ë¡œ ë°°ì¹˜ */
.config .match-count-group {
  display: flex;
  justify-content: center;   /* ê°€ìš´ë° ì •ë ¬ */
  gap: 15px;                 /* ë‹¨ì‹-ë³µì‹ ì‚¬ì´ ê°„ê²© */
  width: 100%;
  margin-bottom: 10px;
}

.config .match-count-group label {
  font-size: 18px;
  display: flex;
  flex-direction: column;    /* ë¼ë²¨ ìœ„, ì…€ë ‰íŠ¸ ì•„ë˜ */
  align-items: center;
  font-weight: bold;
  color: #333;
  font-size: clamp(16px, 3vw, 18px);
  gap: 5px;       
}
.config .match-count-group select {
  font-size: 18px;
  padding: 3px 10px;  /* ë²„íŠ¼ê³¼ ë™ì¼ padding ê°’ */
  border: 2px solid #1976d2;
  border-radius: 6px;
  min-width: 100px;
  text-align: center;
}

/* âŒ ì‚­ì œ ë²„íŠ¼ */
.delete-btn {
  position: absolute;
  top: 4px;
  right: 6px;
  background: #e53935;
  color: white;
  border: none;
  font-size: 10px;
  padding: 2px 4px;
  border-radius: 3px;
  cursor: pointer;
  z-index: 10;
}
.delete-btn:hover {
  background: #b71c1c;
}
.match-card {
  position: relative; /* ë²„íŠ¼ ìœ„ì¹˜ ê¸°ì¤€ */
}

/* ì„ íƒí˜• ë²„íŠ¼ ì‹œê° íš¨ê³¼ */
.btn-option {
  opacity: 0.6;
  transition: opacity 0.2s, transform 0.1s;
}
.btn-option:hover {
  transform: translateY(-2px);
}
.btn-option.active {
  opacity: 1;
  box-shadow: 0 0 8px rgba(0,0,0,0.2);
}

/* âœ… ì‹ ê·œì„ ìˆ˜ ì¶”ê°€ì¤„ ì „ìš© ì‚¬ì´ì¦ˆ ì¶•ì†Œ */
.quick-add-row #addTeamSelect{
  flex: 1;
  min-width: 95px;
  max-width: 140px;   /* ë” ì¤„ì´ê³  ì‹¶ìœ¼ë©´ 120px ë“±ìœ¼ë¡œ */
}

.quick-add-row .btn-add{
  padding: 8px 10px;  /* âœ… ë²„íŠ¼ ì‘ê²Œ */
  font-size: 15px;
  min-width: 60px;    /* âœ… 'ì¶”ê°€' í­ */
  border-radius: 6px;
  white-space: nowrap;
}

/* (ì˜µì…˜) ëª¨ë°”ì¼ì—ì„œ ë” ì¶•ì†Œ */
@media (max-width: 400px){
  .quick-add-row #addTeamSelect{ min-width: 80px; max-width: 120px; padding: 8px; }
  .quick-add-row .btn-add{ min-width: 52px; padding: 7px 8px; font-size: 14px; }
}


</style>

</head>
<body>
  <h2>ë‹¨ì²´ì „ ì§„í–‰(made by Sung-Yong)</h2>
  <div class="config">

    <!-- âœ… ê²½ê¸° ì¤‘ ì‹ ê·œ ì„ ìˆ˜ ì¶”ê°€ -->
<div class="btn-group quick-add-row" style="width:100%; max-width:640px;">
  ...
  <select id="addTeamSelect" style="padding:10px; border:2px solid #1976d2; border-radius:6px;">
    <option value="">íŒ€ ì„ íƒ</option>
  </select>
  <button class="btn-save btn-add" onclick="addPlayerQuick()">ì¶”ê°€</button>
</div>



   <div class="match-count-group">
  <label>ë‹¨ì‹
    <select id="singlesCnt">
      <option value="0">0ê²½ê¸°</option>
      <option value="1">1ê²½ê¸°</option>
      <option value="2">2ê²½ê¸°</option>
      <option value="3" selected>3ê²½ê¸°</option>
      <option value="4">4ê²½ê¸°</option>
      <option value="5">5ê²½ê¸°</option>
    </select>
  </label>

  <label>ë³µì‹
    <select id="doublesCnt">
      <option value="0">0ê²½ê¸°</option>
      <option value="1">1ê²½ê¸°</option>
      <option value="2" selected>2ê²½ê¸°</option>
      <option value="3">3ê²½ê¸°</option>
      <option value="4">4ê²½ê¸°</option>
      <option value="5">5ê²½ê¸°</option>
    </select>
  </label>
  </div>

   <!-- âœ… ìƒì„± ë²„íŠ¼ -->
    <!-- âœ… ìë™ ìƒì„± ë°©ì‹ ì„¤ëª… ë°•ìŠ¤ -->
<div id="modeDesc" style="
  display:none;
  background:#fff8e1;
  border:1px solid #f9d27a;
  padding:10px;
  border-radius:8px;
  max-width:640px;
  margin:10px auto;
  font-size:14px;
  line-height:1.5;
">
  <div id="modeText"></div>
</div>

  <div class="btn-group">
    <button class="btn-generate" onclick="manualMatch()">ìˆ˜ë™ ìƒì„±</button>
    <button class="btn-generate" onclick="openAutoModePopup()">ìë™ ìƒì„±</button>

  <!-- ğŸ“ ê²½ê¸°ì‹œê°„ ë²„íŠ¼ -->
  <button class="btn-generate" style="background-color:#009688" onclick="estimateMatchTime()">ê²½ê¸°ì‹œê°„</button>
</div>

  <!-- âœ… ë§í¬/QR ë²„íŠ¼ -->
  <div class="btn-group">
    <button class="btn-share" onclick="copyLink()">ë§í¬ ë³µì‚¬</button>
    <button class="btn-share" onclick="showQR()">QR ë³´ê¸°</button>
  
<!-- âœ… ê²°ê³¼ ì €ì¥ ë²„íŠ¼ -->

    <button class="btn-save" onclick="saveAsImage()">ëŒ€ì§„ê²°ê³¼ ì €ì¥</button>
  </div>

</div>

  

<div id="popup" class="popup" style="display:none;"></div>
  <div id="captureArea">
    <div id="teamListArea" style="margin-bottom:30px;"></div>
    <div id="summaryArea"></div>
    <div id="rankingArea" style="margin-top:40px;"></div>
  </div>

<script>
/* ---------------- Firebase ì´ˆê¸°í™” ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyA-tp3iJ8-n0yrrd8lwE1IgOdsmDqyh69k",
  authDomain: "koen-teamleague.firebaseapp.com",
  projectId: "koen-teamleague",
  storageBucket: "koen-teamleague.appspot.com",
  messagingSenderId: "487164547059",
  appId: "1:487164547059:web:658a10c8bfe7272ca78c86",
  databaseURL: "https://koen-teamleague-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------------- ì „ì—­ ìƒíƒœ ---------------- */
let teamsRef = null;
let teamsListener = null;

let teamNames = [], teamData = {};
let autoMode = -1; 
const modeNames = ["ì‹¤ë ¥ë§¤ì¹­(ê³ ìˆ˜ ìš°ì„ )", "ì¡°í•©ë§¤ì¹­(ê°•Â·ì•½ ì¡°í•©)"];

// âœ… [ì¶”ê°€] íŒ€ë³„ ë³µì‹ ë¼ìš´ë“œ ìºì‹œ/í¬ì¸í„° (3vs3, 5vs5 ë“±ì—ì„œ ì¤‘ë³µ ì¤„ì´ê¸°)
if (!window.__pairRounds) window.__pairRounds = {};      // { teamName: rounds }
if (!window.__pairRoundIdx) window.__pairRoundIdx = {};  // { teamName: idx }


if (!window.__doublesHistory) {
  window.__doublesHistory = {
    usedPairsA: new Set(),
    usedPairsB: new Set(),
    usedVersus: new Set(),
    usedPlayersA: new Map(),
    usedPlayersB: new Map(),
  };
}


/* ---------------- ë¹„ë°€ë²ˆí˜¸ í™•ì¸ ---------------- */
function checkPassword() {
  const pw = prompt("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
  
  // [ì¶”ê°€] ì·¨ì†Œ ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œ ì•„ë¬´ ë™ì‘ë„ í•˜ì§€ ì•ŠìŒ
  if (pw === null) return false;

  if (pw === "7910") return true;

  // ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ì„ ë•Œë§Œ ë©”ì‹œì§€ í‘œì‹œ
  alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.");
  return false;
}


/* ---------------- ë¡œê·¸ì¸ ì²˜ë¦¬ ---------------- */
async function requireAuth() {
  const u = firebase.auth().currentUser;
  if (u) return u;
  await firebase.auth().signInAnonymously();
  return new Promise(resolve => {
    const unsub = firebase.auth().onAuthStateChanged(user => {
      if (user) { unsub(); resolve(user); }
    });
  });
}

firebase.auth().onAuthStateChanged(async (user) => {
  if (!user) {
    try { await firebase.auth().signInAnonymously(); }
    catch (e) { console.error("ìµëª… ë¡œê·¸ì¸ ì‹¤íŒ¨:", e); }
    return;
  }
  await loadTeams();
  listenToMatchUpdates();
});

/* ---------------- íŒ€ ë¡œë“œ ---------------- */
function loadTeams() {
  // âœ… ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆê°€ ìˆìœ¼ë©´ ë¨¼ì € í•´ì œ(ì¤‘ë³µ êµ¬ë… ë°©ì§€)
  if (teamsRef && teamsListener) {
    teamsRef.off("value", teamsListener);
  }

  teamsRef = db.ref("teams");

  return new Promise((resolve) => {
    teamsListener = (snap) => {
      const raw = snap.val();

      teamData = {};
      teamNames = [];

      if (!raw) {
        renderTeamList(); // í™”ë©´ ë°˜ì˜(ë¹ˆ ìƒíƒœ)
        alert("íŒ€ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € íŒ€ì„ êµ¬ì„±í•´ì£¼ì„¸ìš”.");
        resolve(false);
        return;
      }

      Object.entries(raw).forEach(([id, team]) => {
        team._id = id; // âœ… Firebase teamsì˜ ì‹¤ì œ key ì €ì¥
        teamData[team.teamName] = team;
        teamNames.push(team.teamName);
      });

      renderTeamList(); // âœ… íŒ€í‘œ/ë“œë¡­ë‹¤ìš´ ì¦‰ì‹œ ê°±ì‹ 

      // âœ… íŒì—…ì´ ì—´ë ¤ìˆë‹¤ë©´(ì„ ìˆ˜ ì„ íƒ ì¤‘) ìµœì‹  íŒ€ ë°˜ì˜ì´ ê¼¬ì¼ ìˆ˜ ìˆì–´
      //    ì•ˆì „í•˜ê²Œ ë‹«ê±°ë‚˜, ìƒˆë¡œ ì—´ë„ë¡ ìœ ë„(ì›í•˜ì‹œë©´ "ìë™ ê°±ì‹ "ìœ¼ë¡œë„ ë°”ê¿”ë“œë¦´ê²Œìš”)
      const popup = document.getElementById("popup");
      if (popup && popup.style.display === "block" && popup.targetCell) {
        // íŒì—…ì„ ê³„ì† ìµœì‹ ìœ¼ë¡œ ìœ ì§€í•˜ë ¤ë©´ ì•„ë˜ closePopup() ëŒ€ì‹  "ì¬ë Œë”" ë¡œì§ì„ ë„£ì–´ì•¼ í•¨
        closePopup();
      }

      resolve(true);
    };

    teamsRef.on("value", teamsListener, (err) => {
      console.error("teams ë¦¬ìŠ¤ë„ˆ ì˜¤ë¥˜:", err);
      resolve(false);
    });
  });
}


function renderTeamList() {
  let html = '<h3 style="text-align:center">ğŸ“‹ íŒ€ êµ¬ì„± í˜„í™©</h3><table><tr><th>íŒ€ëª…</th><th>íŒ€ì›</th></tr>';
  teamNames.forEach(team => {
    const players = (teamData[team].players||[]).map(p => `${p.name}(${p.level})`).join(', ');
    html += `<tr><td>${team}</td><td>${players}</td></tr>`;
  });
  html += '</table>';
  document.getElementById('teamListArea').innerHTML = html;

  // âœ… ìƒë‹¨ 'íŒ€ ì„ íƒ' ë“œë¡­ë‹¤ìš´ ê°±ì‹ 
  const sel = document.getElementById("addTeamSelect");
  if (sel) {
    sel.innerHTML = `<option value="">íŒ€ ì„ íƒ</option>` +
      teamNames.map(t => `<option value="${t}">${t}</option>`).join("");
  }
}

/* ---------------- ìˆ˜ë™ ëŒ€ì§„ ìƒì„± ---------------- */
async function manualMatch() {
  if (!checkPassword()) return;
  if (teamNames.length === 0) {
  alert("íŒ€ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € íŒ€ì„ êµ¬ì„±í•´ì£¼ì„¸ìš”.");
  return;
}


  await requireAuth();

// âœ… ìë™ ìƒì„± ì‹œì‘í•  ë•Œ ì´ì „ ì¤‘ë³µ ë°©ì§€ ê¸°ë¡ ì´ˆê¸°í™”
window.__doublesHistoryByMatch = {};
window.__pairRounds = {};
window.__pairRoundIdx = {};
window.__rot43 = 0;
window.__single2v2 = 0;


  await db.ref("matches").remove();

  const singles = parseInt(document.getElementById("singlesCnt").value, 10);
  const doubles = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  for (let i = 0; i < teamNames.length; i++) {
    for (let j = i + 1; j < teamNames.length; j++) {
      const matchList = [];
      for (let s = 0; s < singles; s++)
        matchList.push({ label: `${s + 1}ë‹¨`, players: "ë¯¸ì • vs ë¯¸ì •", result: "-" });
      for (let d = 0; d < doubles; d++)
        matchList.push({ label: `${d + 1}ë³µ`, players: "ë¯¸ì •/ë¯¸ì • vs ë¯¸ì •/ë¯¸ì •", result: "-" });
      const key = `${teamNames[i]}_vs_${teamNames[j]}`;
      updates[`matches/${key}`] = { teamA: teamNames[i], teamB: teamNames[j], matchList };
    }
  }
  await db.ref().update(updates);
}

/* ---------------- ìë™ ëŒ€ì§„ ìƒì„± ---------------- */
async function autoMatch() {
  if (!checkPassword()) return;
  const ok = await loadTeams();
  if (!ok || teamNames.length === 0) return;


  // âœ… ìë™ ìƒì„± ëª¨ë“œ ì„¤ëª… í‘œì‹œ
const descBox = document.getElementById("modeDesc");
const descText = document.getElementById("modeText");

if (autoMode === 0) {
  descText.innerText =
"Â· ê³ ìˆ˜ ì„ ìˆ˜ë¶€í„° ìš°ì„  ë°°ì •í•˜ëŠ” ë°©ì‹\n" +
"Â· ë‘ íŒ€ì˜ ì‹¤ë ¥ì´ ë¹„ìŠ·í•  ë•Œ ê°€ì¥ ê³µì •í•œ ê²½ê¸° êµ¬ì„±\n" +
"Â· ê²½ê¸°ë ¥ ì¤‘ì‹¬ ë°°ì •ì´ í•„ìš”í•  ë•Œ ì í•©";
} else {
  descText.innerText =
"Â· ìƒÂ·í•˜ìœ„ ì¡°í•©ì„ ì„ì–´ ê²½ê¸°ë¥¼ êµ¬ì„±í•˜ëŠ” ë°©ì‹\n" +
"Â· í•œ ê²½ê¸°ì—ì„œ ì‹¤ë ¥ ì°¨ì´ë¥¼ ì¤„ì—¬ ì ‘ì „ì„ ë§Œë“¤ê¸° ì¢‹ìŒ\n" +
"Â· ì¹œì„  ê²½ê¸°ë‚˜ ë‹¤ì–‘í•œ ì¡°í•©ì„ ë§Œë“¤ê³  ì‹¶ì„ ë•Œ ìœ ë¦¬";
}

descBox.style.display = "block";


  await requireAuth();
  await db.ref("matches").remove();

  const singlesCnt = parseInt(document.getElementById("singlesCnt").value, 10);
  const doublesCnt = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  for (let i = 0; i < teamNames.length; i++) {
    for (let j = i + 1; j < teamNames.length; j++) {
      const teamA = teamNames[i], teamB = teamNames[j];
      // âœ… ë‹¨ì‹/ë³µì‹ ëª¨ë“œì—ì„œ ê°ê° ë”°ë¡œ ì •ë ¬í•´ì•¼ í•˜ë¯€ë¡œ ì—¬ê¸°ì„  ì •ë ¬í•˜ì§€ ì•ŠìŒ
// âœ… ì™„ì „ ê¹Šì€ ë³µì‚¬ (ì•ˆì „)
const A_raw = JSON.parse(JSON.stringify(teamData[teamA].players || []));
const B_raw = JSON.parse(JSON.stringify(teamData[teamB].players || []));


const singlesA = [...A_raw];
const singlesB = [...B_raw];

const doublesA = [...A_raw];
const doublesB = [...B_raw];




let singles;
if (singlesA.length !== singlesB.length) {
    singles = generateSinglesPairsForDifferentTeamSize(singlesA, singlesB, singlesCnt);
} else {
    singles = generateSinglesPairsByMode(singlesA, singlesB, singlesCnt, autoMode);
}


      const doubles = generateDoublesPairsByMode(doublesA, doublesB, doublesCnt, autoMode, teamA, teamB);



      const matchList = [];
      singles.forEach((m, idx) => {
        matchList.push({
          label: `${idx + 1}ë‹¨`,
          players: `${m.a.name}(${m.a.level}) vs ${m.b.name}(${m.b.level})`,
          result: "-"
        });
      });
      doubles.forEach((m, idx) => {
        matchList.push({
          label: `${idx + 1}ë³µ`,
          players: `${m.a1.name}(${m.a1.level})/${m.a2.name}(${m.a2.level}) vs ${m.b1.name}(${m.b1.level})/${m.b2.name}(${m.b2.level})`,
          result: "-"
        });
      });

      const key = `${teamA}_vs_${teamB}`;
      updates[`matches/${key}`] = { teamA, teamB, matchList };
    }
  }
  await db.ref().update(updates);
}

/* ============================================================
   âœ… 2ëª… vs 2ëª… ë‹¨ì‹ ì „ìš© ì¡°í•© ìƒì„± (AC, AD, BC, BD)
   ============================================================ */
function generateSinglesPairs2v2(A, B, need) {
    const result = [];

    // A íŒ€ 2ëª…, B íŒ€ 2ëª…ì¼ ë•Œ ê°€ëŠ¥í•œ ëª¨ë“  ì¡°í•©
    const combos = [
        { a: A[0], b: B[0] }, // A vs C
        { a: A[0], b: B[1] }, // A vs D
        { a: A[1], b: B[0] }, // B vs C
        { a: A[1], b: B[1] }, // B vs D
    ];

    // ë¡œí…Œì´ì…˜ ì¸ë±ìŠ¤ (ì¤‘ë³µ ë°©ì§€ìš©)
    if (!window.__single2v2) window.__single2v2 = 0;

    const start = window.__single2v2 % combos.length;
    window.__single2v2++;

    // need ê°œìˆ˜ë§Œí¼ ìˆœì„œëŒ€ë¡œ ê°€ì ¸ì˜¤ê¸° (4ë‹¨ì‹ì´ë©´ 4ê°œ ëª¨ë‘)
    for (let i = 0; i < need; i++) {
        const idx = (start + i) % combos.length;
        result.push(combos[idx]);
    }

    return result;
}

/* -------- ë‹¨ì‹: ì¤‘ë³µ ì—†ëŠ” ì¡°í•© ìš°ì„ , ë¶€ì¡± ì‹œ ì¤‘ë³µ í—ˆìš© -------- */
// âœ… ë‹¨ì‹ ìƒì„± (ìµœì¢… ì™„ì„±)
function generateSinglesPairsByMode(A, B, need, mode) {

  // =========================================
// âœ… 2ëª… vs 2ëª…ì¼ ë•ŒëŠ” ë¬´ì¡°ê±´ AC, AD, BC, BD ì¡°í•© ìƒì„±
// =========================================
if (A.length === 2 && B.length === 2) {
    return generateSinglesPairs2v2(A, B, need);
}


    // âœ… ì¸ì›ìˆ˜ê°€ ë‹¤ë¥¸ ê²½ìš° ì„±ìš©ë‹˜ ë§ì¶¤ ë¡œì§ ì‚¬ìš©!
    if (A.length !== B.length) {
        return generateSinglesPairsForDifferentTeamSize(A, B, need);
    }

    // âœ… ì¸ì›ì´ ê°™ì„ ë•ŒëŠ” ê¸°ì¡´ ë°©ì‹ ì ìš©
    const result = [];

    A = [...A].sort((a,b)=>a.level - b.level);
    B = [...B].sort((a,b)=>a.level - b.level);

    // ê³µí†µ ì¸ì›ìˆ˜ê¹Œì§€ ê¸°ë³¸ ë§¤ì¹­
    for (let i = 0; i < Math.min(A.length, need); i++) {
        result.push({ a: A[i], b: B[i] });
    }

    // ì¶”ê°€ê²½ê¸° í•„ìš” ì‹œ ê¸°ì¡´ íšŒì „ ë¡œì§
    const extraCount = need - A.length;

    if (extraCount > 0) {
        const candidatesA = [...A];
        const candidatesB = [...B];

        if (!window.singlesRotationA)
            window.singlesRotationA = 0;
        if (!window.singlesRotationB)
            window.singlesRotationB = 0;

        for (let i = 0; i < extraCount; i++) {
            result.push({
                a: candidatesA[(window.singlesRotationA + i) % candidatesA.length],
                b: candidatesB[(window.singlesRotationB + i) % candidatesB.length]
            });
        }

        window.singlesRotationA += extraCount;
        window.singlesRotationB += extraCount;
    }

    return result.slice(0, need);
}




function generateSinglesPairsForDifferentTeamSize(A, B, need) {
    const result = [];

    // âœ… 1) ë ˆë²¨ ë‚®ì€ ìˆœì„œë¡œ ì •ë ¬ (ìˆ«ì ë‚®ì„ìˆ˜ë¡ ê³ ìˆ˜)
    A = [...A].sort((a,b)=>a.level - b.level);
    B = [...B].sort((a,b)=>a.level - b.level);

    const sizeA = A.length;
    const sizeB = B.length;

    // âœ… ê³µí†µ ì¸ì›ê¹Œì§€ëŠ” ê¸°ì¡´ ë§¤ì¹­
    const common = Math.min(sizeA, sizeB);

    for (let i = 0; i < common; i++) {
        result.push({ a: A[i], b: B[i] });
    }

    // âœ… ë‹¨ì‹ needê°€ ê³µí†µ ì¸ì› ì´í•˜ë¼ë©´ ì—¬ê¸°ì„œ ë
    if (need <= common) return result.slice(0, need);


    /* ---------------------------------------------------
       âœ… 2) A ë‚¨ì€ 1ëª… vs B í›„ë³´ ì¤‘ ì°¨ì´ ìµœì†Œ
    --------------------------------------------------- */

    // AíŒ€ ë‚¨ëŠ” ì„ ìˆ˜ (ì˜ˆ: 4ëª… vs 3ëª…ì´ë©´ A[3])
    const extraA = A[common];
    const Bteam = [...B];

    let minDiff = Infinity;
    let candidates = [];

    for (const p of Bteam) {
        const diff = Math.abs(extraA.level - p.level);
        if (diff < minDiff) {
            minDiff = diff;
            candidates = [p];
        } else if (diff === minDiff) {
            candidates.push(p);
        }
    }

    // âœ… í›„ë³´ê°€ ì—¬ëŸ¬ ëª…ì´ë©´ ë¡œí…Œì´ì…˜
    if (!window.singlesRotationExtraB)
        window.singlesRotationExtraB = 0;

    const idx = window.singlesRotationExtraB % candidates.length;
    const selectedB = candidates[idx];

    window.singlesRotationExtraB++;

    // âœ… ë§¤ì¹­ ì¶”ê°€
    result.push({ a: extraA, b: selectedB });


    /* ---------------------------------------------------
       âœ… 3) needê°€ ê³µí†µ+1 ë³´ë‹¤ í´ ê²½ìš° (ì˜ˆ: 5ë‹¨ì‹)
    --------------------------------------------------- */

    let extraCount = need - (common + 1);

    if (extraCount > 0) {
        const candidatesA = [...A];
        const candidatesBrot = [...B];

        if (!window.singlesRotationA2)
            window.singlesRotationA2 = 0;
        if (!window.singlesRotationB2)
            window.singlesRotationB2 = 0;

        for (let i = 0; i < extraCount; i++) {
            const aSel = candidatesA[(window.singlesRotationA2 + i) % candidatesA.length];
            const bSel = candidatesBrot[(window.singlesRotationB2 + i) % candidatesBrot.length];

            result.push({
                a: aSel,
                b: bSel
            });
        }

        window.singlesRotationA2 += extraCount;
        window.singlesRotationB2 += extraCount;
    }

    return result.slice(0, need);
}





/* -------- ë³µì‹: ë™ì¼íŒ€/ìƒëŒ€íŒ€ ì¤‘ë³µ ë°©ì§€, ë¶€ì¡± ì‹œ ì¤‘ë³µ í—ˆìš© -------- */
const strongFilter = (i, j, n) => (i < Math.ceil(n/2) && j < Math.ceil(n/2));
const weakFilter   = (i, j, n) => (i >= Math.floor(n/2) && j >= Math.floor(n/2));

// âœ… ê°•+ì•½ ì¡°í•© í•„í„° (ìƒˆë¡œ êµì²´í•´ì•¼ í•¨)
function mixedFilter(i, j, n) {
  const mid = Math.floor(n / 2); // ìƒìœ„ ì ˆë°˜ê¹Œì§€ ê°•ì
  const isStrongI = i < mid;
  const isStrongJ = j < mid;
  return isStrongI !== isStrongJ;  // í•œ ëª…ë§Œ ê°•ìì¼ ë•Œ true
}


function allTeamPairsFiltered(players, filterFn) {
  const res = [];
  const n = players.length;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (filterFn && !filterFn(i, j, n)) continue;
      const p1 = players[i], p2 = players[j];
      res.push({ p1, p2, sum: p1.level + p2.level, i, j });
    }
  }
  return res;
}

function allTeamPairs(players) { return allTeamPairsFiltered(players, null); }
function pairKeySorted(n1, n2) { return [n1, n2].sort().join('/'); }
function versusKey(a1,a2,b1,b2){ return `${pairKeySorted(a1.name,a2.name)}||${pairKeySorted(b1.name,b2.name)}`; }

// âœ… [ì¶”ê°€] ì „ì›ì¶œì „(need*2==ì¸ì›)ì¼ ë•Œ ê°€ëŠ¥í•œ "ì™„ì „ ë§¤ì¹­" í›„ë³´ ìƒì„±
function allPerfectMatchings(indices) {
  // indices: [0,1,2,3,...]
  if (indices.length === 0) return [[]];
  const res = [];
  const first = indices[0];
  for (let i = 1; i < indices.length; i++) {
    const pair = [first, indices[i]];
    const rest = indices.slice(1, i).concat(indices.slice(i + 1));
    for (const sub of allPerfectMatchings(rest)) {
      res.push([pair, ...sub]);
    }
  }
  return res;
}

// âœ… [ì¶”ê°€] ëª¨ë“œ ì„ í˜¸ë„ ì ìˆ˜(ë‚®ì„ìˆ˜ë¡ ê·¸ ëª¨ë“œì— ë” "ê°€ê¹ë‹¤")
// - mode 0: ì‹¤ë ¥ë§¤ì¹­ ì„±ê²©(ì¸ì ‘í•œ ì¸ë±ìŠ¤ë¼ë¦¬) ì„ í˜¸ â†’ |i-j| í•©ì´ ì‘ì„ìˆ˜ë¡ ì¢‹ìŒ
// - mode 1: ì¡°í•©ë§¤ì¹­ ì„±ê²©(ê°•+ì•½) ì„ í˜¸ â†’ mixedFilterë¥¼ ë§Œì¡±í•˜ëŠ” í˜ì–´ê°€ ë§ì„ìˆ˜ë¡ ì¢‹ìŒ
function modePreferenceScore(pairs, n, mode) {
  if (mode === 0) {
    // ì¸ì ‘ ì„ í˜¸: gap í•©ì´ ì‘ì„ìˆ˜ë¡ ì¢‹ìŒ
    return pairs.reduce((sum, [i,j]) => sum + Math.abs(i - j), 0);
  } else {
    // ê°•+ì•½ ì¡°í•© ì„ í˜¸: mixedFilter ë§Œì¡± ëª»í•˜ë©´ í° ë²Œì 
    let bad = 0;
    for (const [i,j] of pairs) {
      if (!mixedFilter(i, j, n)) bad += 1;
    }
    // badê°€ 0ì´ë©´ ìµœê³ , badê°€ ë§ìœ¼ë©´ ë‚˜ì¨
    return bad * 1000;
  }
}


// âœ… [ì¶”ê°€] ì „ì›ì¶œì „ ì¼€ì´ìŠ¤ì—ì„œ "ìµœì  ë¼ìš´ë“œ" ì„ íƒ
function pickBestFullParticipationRound(SA, SB, need, mode, history) {
  const n = SA.length; // = SB.length, = need*2
  const idx = Array.from({length:n}, (_,i)=>i);

  // ëª¨ë“  ì™„ì „ ë§¤ì¹­ í›„ë³´ ìƒì„±
  let candA = allPerfectMatchings(idx);
  let candB = allPerfectMatchings(idx);

  // ëª¨ë“œ ì„ í˜¸ë„ ì ìˆ˜ë¡œ ì •ë ¬ + í›„ë³´ ìˆ˜ ì œí•œ(ì†ë„ ì•ˆì „ì¥ì¹˜)
  candA.sort((x,y)=>modePreferenceScore(x,n,mode) - modePreferenceScore(y,n,mode));
  candB.sort((x,y)=>modePreferenceScore(x,n,mode) - modePreferenceScore(y,n,mode));

  const MAX = 60; // âœ… í•„ìš”ì‹œ 40~120 ë²”ìœ„ë¡œ ì¡°ì ˆ
  candA = candA.slice(0, Math.min(MAX, candA.length));
  candB = candB.slice(0, Math.min(MAX, candB.length));

  // Aí›„ë³´ x Bí›„ë³´ ì¡°í•© ì¤‘ scoreRoundê°€ ìµœì†Œì¸ ê²ƒ ì„ íƒ
  let best = null;
  let bestScore = Infinity;

  for (const ra of candA) {
    for (const rb of candB) {
      const sc = scoreRound(SA, SB, ra, rb, history);
      if (sc < bestScore) {
        bestScore = sc;
        best = { ra, rb };
      }
    }
  }

  return best; // {ra, rb} ë˜ëŠ” null
}


// âœ… 3ë‹¨ê³„: ë¼ìš´ë“œ ì ìˆ˜(ê· í˜• + ì¤‘ë³µ í˜ë„í‹°) ê³„ì‚°
function scoreRound(SA, SB, roundA, roundB, history) {
  const pairsA = roundA.map(([i,j]) => {
    const p1 = SA[i], p2 = SA[j];
    return { p1, p2, sum: p1.level + p2.level, key: pairKeySorted(p1.name,p2.name) };
  }).sort((x,y)=>x.sum - y.sum);

  const pairsB = roundB.map(([i,j]) => {
    const p1 = SB[i], p2 = SB[j];
    return { p1, p2, sum: p1.level + p2.level, key: pairKeySorted(p1.name,p2.name) };
  }).sort((x,y)=>x.sum - y.sum);

  let score = 0;

  for (let k=0; k<pairsA.length; k++) {
    const a = pairsA[k], b = pairsB[k];

    // 1) ê· í˜•: diff ì‘ì„ìˆ˜ë¡ ì¢‹ìŒ
    score += Math.abs(a.sum - b.sum);

    // 2) ì¤‘ë³µ í˜ë„í‹°(ì¬ì‚¬ìš©ì´ë©´ ë²Œì )
    if (history.usedPairsA.has(a.key)) score += 100;
    if (history.usedPairsB.has(b.key)) score += 100;

    const vKey = versusKey(a.p1, a.p2, b.p1, b.p2);
    if (history.usedVersus.has(vKey)) score += 150;
  }

  return score;
}


function greedyMatchPairs(
  pairsA, pairsB, need,
  usedPlayersA, usedPlayersB,
  usedPairsA, usedPairsB, usedVersus,
  allowDuplicates = false,
  lockedPairs = new Set()
) {
  const res = [];

  while (res.length < need) {
    let best = null;
    let bestDiff = Infinity; // âœ… ì–´ë–¤ ëª¨ë“œë“  "ì°¨ì´ ìµœì†Œ"ë¡œ í†µì¼

    for (const a of pairsA) {
      const aPlayers = [a.p1.name, a.p2.name];
      const aKey = pairKeySorted(a.p1.name, a.p2.name);

      // AíŒ€ ë™ì¼ ì¡°í•© ë°©ì§€
      if ((!allowDuplicates && usedPairsA.has(aKey)) || lockedPairs.has(aKey)) continue;

      // ì„ ìˆ˜ ê°œë³„ ì¤‘ë³µ ë°©ì§€
      if (!allowDuplicates && (usedPlayersA.has(aPlayers[0]) || usedPlayersA.has(aPlayers[1]))) continue;

      for (const b of pairsB) {
        const bPlayers = [b.p1.name, b.p2.name];
        const bKey = pairKeySorted(b.p1.name, b.p2.name);

        // BíŒ€ ë™ì¼ ì¡°í•© ë°©ì§€
        if ((!allowDuplicates && usedPairsB.has(bKey)) || lockedPairs.has(bKey)) continue;

        // ì„ ìˆ˜ ê°œë³„ ì¤‘ë³µ ë°©ì§€
        if (!allowDuplicates && (usedPlayersB.has(bPlayers[0]) || usedPlayersB.has(bPlayers[1]))) continue;

        // ë™ì¼ ìƒëŒ€ ì¡°í•© ë°©ì§€
        const vKey = versusKey(a.p1, a.p2, b.p1, b.p2);
        if ((!allowDuplicates && usedVersus.has(vKey)) || lockedPairs.has(vKey)) continue;

        // âœ… ì‹¤ë ¥ë§¤ì¹­/ì¡°í•©ë§¤ì¹­ ëª¨ë‘ "ê²½ê¸° ê· í˜•" = ì°¨ì´ ìµœì†Œ
        const diff = Math.abs(a.sum - b.sum);
        if (diff < bestDiff) {
          bestDiff = diff;
          best = { a, b, aPlayers, bPlayers, aKey, bKey, vKey };
        }
      }
    }

    if (!best) break;

    // í™•ì •
    res.push({
      a1: best.a.p1, a2: best.a.p2,
      b1: best.b.p1, b2: best.b.p2
    });

    // ì‚¬ìš© ê¸°ë¡
    best.aPlayers.forEach(n => usedPlayersA.add(n));
    best.bPlayers.forEach(n => usedPlayersB.add(n));
    usedPairsA.add(best.aKey);
    usedPairsB.add(best.bKey);
    usedVersus.add(best.vKey);

    // ì´ˆë°˜ í™•ì • ì¡°í•© ì ê¸ˆ
    if (res.length <= 2) {
      lockedPairs.add(best.aKey);
      lockedPairs.add(best.bKey);
      lockedPairs.add(best.vKey);
    }
  }

  return res;
}

function buildRoundRobinPairRounds(n) {
  const rounds = [];
  let arr = Array.from({length:n}, (_,i)=>i);

  for (let r = 0; r < n - 1; r++) {
    const pairs = [];
    for (let i = 0; i < n/2; i++) {
      pairs.push([arr[i], arr[n-1-i]]);
    }
    rounds.push(pairs);

    // ì›í˜• íšŒì „: ì²« ë²ˆì§¸ëŠ” ê³ ì •, ë‚˜ë¨¸ì§€ íšŒì „
    arr = [arr[0], arr[n-1], ...arr.slice(1, n-1)];
  }
  return rounds;
}

// âœ… [ì¶”ê°€] í™€ìˆ˜ ì¸ì›ë„ ì§€ì›í•˜ëŠ” "ê²¹ì¹˜ì§€ ì•ŠëŠ” í˜ì–´ ë¼ìš´ë“œ" ìƒì„±
// - í™€ìˆ˜ë©´ ghost(bye) 1ëª…ì„ ì¶”ê°€í•´ì„œ íšŒì „ì‹œí‚¤ê³ 
// - ghostê°€ í¬í•¨ëœ í˜ì–´ëŠ” ë²„ë ¤ì„œ "í•œ ëª… ì‰¼"ì„ ìë™ ì²˜ë¦¬
function buildDisjointPairRounds(n) {
  const hasGhost = (n % 2 === 1);
  const N = hasGhost ? n + 1 : n;       // ghostëŠ” N-1
  let arr = Array.from({ length: N }, (_, i) => i);

  const rounds = [];
  const roundCount = N - 1;            // circle method

  for (let r = 0; r < roundCount; r++) {
    const pairs = [];
    for (let i = 0; i < N / 2; i++) {
      const a = arr[i];
      const b = arr[N - 1 - i];
      if (hasGhost && (a === N - 1 || b === N - 1)) continue; // ghost í¬í•¨ í˜ì–´ ì œì™¸
      pairs.push([a, b]);
    }
    rounds.push(pairs);

    // íšŒì „: ì²« ì›ì†Œ ê³ ì •, ë‚˜ë¨¸ì§€ íšŒì „
    arr = [arr[0], arr[N - 1], ...arr.slice(1, N - 1)];
  }

  return rounds; // ê° roundëŠ” "ê²¹ì¹˜ì§€ ì•ŠëŠ” í˜ì–´ë“¤"
}



function normalizePlayers(list){
  return (list || []).map(p => ({
    ...p,
    name: String(p.name || "").trim(),   // âœ… ê³µë°± ì œê±°
    level: Number(p.level)              // âœ… ìˆ«ì ë³´ì •
  }));
}


/* =========================================================
   âœ… ë³µì‹ ìë™ ìƒì„± (ìµœì¢…ë³¸)
   - í˜„ì¬ ì„±ìš©ë‹˜ ì½”ë“œ êµ¬ì¡° ìœ ì§€
   - historyë¥¼ "íŒ€A_vs_íŒ€B" ê²½ê¸° ë‹¨ìœ„ë¡œ ë¶„ë¦¬ + í•¨ìˆ˜ ì „ì²´ì—ì„œ ê³µìœ 
   - 4vs4+4ë³µ ì™„ì „íƒìƒ‰ / ì „ì›ì¶œì „ / ì¼ë°˜(3vs3,5vs5 í¬í•¨) ëª¨ë‘ ë™ì¼ history ì‚¬ìš©
   ========================================================= */
function generateDoublesPairsByMode(A, B, need, mode, teamAName="A", teamBName="B") {

  window.currentDoublesMode = mode;

  /* ------------------------------------------------------
     âœ… 0) ì „ì²˜ë¦¬: ì´ë¦„/ë¶€ìˆ˜ ì •ë¦¬ + ì•ˆì • ì •ë ¬
  ------------------------------------------------------ */
  const SA = normalizePlayers(A).sort((a,b)=>
    a.level === b.level ? a.name.localeCompare(b.name) : a.level - b.level
  );
  const SB = normalizePlayers(B).sort((a,b)=>
    a.level === b.level ? a.name.localeCompare(b.name) : a.level - b.level
  );

  /* ------------------------------------------------------
     âœ… 0-1) íŒ€ í‚¤ / íˆìŠ¤í† ë¦¬ í‚¤ (íŒ€ë³„/ëŒ€ì§„ë³„ ë¶„ë¦¬)
  ------------------------------------------------------ */
  const safe = s => String(s ?? "").trim()
    .replace(/\s+/g, "_")
    .replace(/[^\wê°€-í£]/g, "");

  const keyA = `TEAM_${safe(teamAName)}`;
  const keyB = `TEAM_${safe(teamBName)}`;
  // A_vs_B ì™€ B_vs_A ê°€ ê°™ì€ ëŒ€ì§„ìœ¼ë¡œ ì·¨ê¸‰ë˜ê²Œ ì •ë ¬(í‚¤ ì•ˆì •í™”)
  const histKey = [keyA, keyB].sort().join("__VS__");

  if (!window.__doublesHistoryByMatch) window.__doublesHistoryByMatch = {};
  if (!window.__doublesHistoryByMatch[histKey]) {
    window.__doublesHistoryByMatch[histKey] = {
      usedPairsA: new Set(),
      usedPairsB: new Set(),
      usedVersus: new Set(),
    };
  }
  const history = window.__doublesHistoryByMatch[histKey];

  const nA = SA.length, nB = SB.length;

  // ì˜ˆì™¸: ê²½ê¸° 0ê°œ
  if (!need || need <= 0) return [];

  /* ------------------------------------------------------
     âœ… 1) (íŠ¹ìˆ˜) 4ëª… vs 4ëª…, 4ë³µ: ì™„ì „íƒìƒ‰ìœ¼ë¡œ ì¤‘ë³µ ìµœì†Œ + ê· í˜• ìµœì 
        - "ì™„ì „ ì¤‘ë³µ 0"ì„ ê°•í•˜ê²Œ ì¶”êµ¬
        - history í˜ë„í‹°ê¹Œì§€ ë°˜ì˜
  ------------------------------------------------------ */
  if (SA.length === 4 && SB.length === 4 && need === 4) {

    const pairsA_all = allTeamPairs(SA); // 6ê°œ
    const pairsB_all = allTeamPairs(SB); // 6ê°œ

    // 6ê°œ ì¤‘ 4ê°œ ë½‘ê¸° (15ê°œ)
    function choose4(pairs){
      const res = [];
      for (let i=0;i<pairs.length;i++){
        for (let j=i+1;j<pairs.length;j++){
          for (let k=j+1;k<pairs.length;k++){
            for (let l=k+1;l<pairs.length;l++){
              res.push([pairs[i],pairs[j],pairs[k],pairs[l]]);
            }
          }
        }
      }
      return res;
    }

    // ìˆœì—´
    function perms(arr){
      if (arr.length <= 1) return [arr];
      const out = [];
      for (let i=0;i<arr.length;i++){
        const rest = arr.slice(0,i).concat(arr.slice(i+1));
        for (const p of perms(rest)) out.push([arr[i], ...p]);
      }
      return out;
    }

    const combosA = choose4(pairsA_all);
    const combosB = choose4(pairsB_all);
    const permIdxs = perms([0,1,2,3]); // 24ê°œ

    let best = null;
    let bestScore = Infinity;

    for (const setA of combosA) {
      const A_sorted = [...setA].sort((x,y)=>x.sum-y.sum);

      // A ì¬ì‚¬ìš© í˜ë„í‹°
      let basePenaltyA = 0;
      for (const a of A_sorted) {
        const aKey = pairKeySorted(a.p1.name, a.p2.name);
        if (history.usedPairsA.has(aKey)) basePenaltyA += 120;
      }

      for (const setB of combosB) {
        const B_sorted0 = [...setB].sort((x,y)=>x.sum-y.sum);

        let basePenaltyB = 0;
        for (const b of B_sorted0) {
          const bKey = pairKeySorted(b.p1.name, b.p2.name);
          if (history.usedPairsB.has(bKey)) basePenaltyB += 120;
        }

        for (const pi of permIdxs) {
          let score = 0;
          score += basePenaltyA + basePenaltyB;

          // "ì´ë²ˆ ìƒì„±" ì•ˆì—ì„œ ì¤‘ë³µì€ ì‚¬ì‹¤ìƒ ì—†ìŒ(choose4ë¼) + ëŒ€ì§„ ì¤‘ë³µë§Œ ê°•í•˜ê²Œ ì²´í¬
          for (let t=0; t<4; t++) {
            const a = A_sorted[t];
            const b = B_sorted0[pi[t]];

            const vKey = versusKey(a.p1, a.p2, b.p1, b.p2);

            // ê· í˜•(ì°¨ì´ ìµœì†Œ)
            score += Math.abs(a.sum - b.sum);

            // ê³¼ê±° ë™ì¼ ëŒ€ì§„ í˜ë„í‹°
            if (history.usedVersus.has(vKey)) score += 180;

            // ëª¨ë“œ ì„±í–¥(ì•½í•˜ê²Œë§Œ)
            if (mode === 0) {
              score += 0.3 * (Math.abs(a.i - a.j) + Math.abs(b.i - b.j));
            } else {
              if (!mixedFilter(a.i, a.j, SA.length)) score += 8;
              if (!mixedFilter(b.i, b.j, SB.length)) score += 8;
            }
          }

          if (score < bestScore) {
            bestScore = score;
            best = { A_sorted, B_sorted0, pi };
          }
        }
      }
    }

    // ê²°ê³¼ êµ¬ì„± + history ê¸°ë¡
    const result = [];
    for (let t=0; t<4; t++) {
      const a = best.A_sorted[t];
      const b = best.B_sorted0[best.pi[t]];

      result.push({ a1: a.p1, a2: a.p2, b1: b.p1, b2: b.p2 });

      const aKey = pairKeySorted(a.p1.name, a.p2.name);
      const bKey = pairKeySorted(b.p1.name, b.p2.name);
      const vKey = versusKey(a.p1, a.p2, b.p1, b.p2);

      history.usedPairsA.add(aKey);
      history.usedPairsB.add(bKey);
      history.usedVersus.add(vKey);
    }

    return result;
  }

  /* ------------------------------------------------------
     âœ… 2) ì „ì›ì¶œì „ ì¡°ê±´ (need*2 == ì¸ì›ìˆ˜)  ì˜ˆ: 4ëª…-2ë³µ, 6ëª…-3ë³µ ë“±
        - pickBestFullParticipationRound + scoreRound
        - ì„ íƒëœ ë¼ìš´ë“œì˜ í˜ì–´ë¥¼ í•© ê¸°ì¤€ ì •ë ¬ í›„ ë§¤ì¹­
  ------------------------------------------------------ */
  if (need * 2 === SA.length && need * 2 === SB.length) {

    const picked = pickBestFullParticipationRound(SA, SB, need, mode, history);

    // ì‹¤íŒ¨ ì‹œ fallback (ê±°ì˜ ì—†ìŒ)
    if (!picked) {
      const result = [];
      if (mode === 0) {
        for (let i = 0; i < need; i++) {
          result.push({ a1: SA[i*2], a2: SA[i*2+1], b1: SB[i*2], b2: SB[i*2+1] });
        }
      } else {
        const n = SA.length;
        for (let i = 0; i < need; i++) {
          result.push({ a1: SA[i], a2: SA[n-1-i], b1: SB[i], b2: SB[n-1-i] });
        }
      }
      return result;
    }

    const pairsA = picked.ra.map(([i,j]) => ({
      i, j,
      p1: SA[i], p2: SA[j],
      sum: SA[i].level + SA[j].level,
      key: pairKeySorted(SA[i].name, SA[j].name),
    })).sort((x,y)=>x.sum - y.sum);

    const pairsB = picked.rb.map(([i,j]) => ({
      i, j,
      p1: SB[i], p2: SB[j],
      sum: SB[i].level + SB[j].level,
      key: pairKeySorted(SB[i].name, SB[j].name),
    })).sort((x,y)=>x.sum - y.sum);

    const result = [];
    for (let k=0; k<need; k++) {
      const a = pairsA[k], b = pairsB[k];
      result.push({ a1: a.p1, a2: a.p2, b1: b.p1, b2: b.p2 });

      history.usedPairsA.add(a.key);
      history.usedPairsB.add(b.key);
      history.usedVersus.add(versusKey(a.p1, a.p2, b.p1, b.p2));
    }

    return result;
  }

  /* ------------------------------------------------------
     âœ… 3) (ê¸°ì¡´ ìœ ì§€) 4ëª… vs 3ëª… ì „ìš© ê·œì¹™ (need=2ì¼ ë•Œ)
        - ì „ì›ì¶œì „ 100% / ì¤‘ë³µ ìµœì†Œ ë¡œí…Œì´ì…˜
  ------------------------------------------------------ */
  if (need === 2 && SA.length === 4 && SB.length === 3) {

    const combos = [
      [ [0,1], [1,2] ],
      [ [0,1], [0,2] ],
      [ [0,2], [1,2] ],
    ];

    if (!window.__rot43) window.__rot43 = 0;
    const choice = combos[window.__rot43 % 3];
    window.__rot43++;

    const result = [];
    result.push({
      a1: SA[0], a2: SA[1],
      b1: SB[choice[0][0]], b2: SB[choice[0][1]]
    });
    result.push({
      a1: SA[2], a2: SA[3],
      b1: SB[choice[1][0]], b2: SB[choice[1][1]]
    });

    // history ê¸°ë¡(ì¡°í•©/ëŒ€ì§„)
    for (const m of result) {
      const aKey = pairKeySorted(m.a1.name, m.a2.name);
      const bKey = pairKeySorted(m.b1.name, m.b2.name);
      history.usedPairsA.add(aKey);
      history.usedPairsB.add(bKey);
      history.usedVersus.add(versusKey(m.a1, m.a2, m.b1, m.b2));
    }

    return result;
  }

  /* ------------------------------------------------------
     âœ… 4) ê·¸ ì™¸ ì¼ë°˜ ì¼€ì´ìŠ¤ (3vs3, 5vs5 í¬í•¨)
        - íŒ€ë³„ ë¼ìš´ë“œ(ê²¹ì¹˜ì§€ ì•ŠëŠ” í˜ì–´) ê¸°ë°˜ìœ¼ë¡œ í›„ë³´ Kê°œ íƒìƒ‰
        - ê· í˜•(ì°¨ì´ ìµœì†Œ) + history ì¤‘ë³µ í˜ë„í‹° + "ì´ë²ˆ ìƒì„± ë‚´" ì¤‘ë³µ ê°•ë²Œì 
        - needê°€ ë¼ìš´ë“œ í˜ì–´ ìˆ˜ë³´ë‹¤ í¬ë©´(ì˜ˆ: 3ëª… 2ë³µ) ìˆœí™˜í•´ì„œ ì±„ìš°ë˜
          ë™ì¼ ëŒ€ì§„ ì¤‘ë³µì€ ê°•í•˜ê²Œ í”¼í•˜ë„ë¡ ì ìˆ˜ë¡œ ì œì–´
  ------------------------------------------------------ */

  // ë¼ìš´ë“œ ìºì‹œ ìƒì„±(í™€ìˆ˜ ì§€ì›)
  if (!window.__pairRounds[keyA]) window.__pairRounds[keyA] = buildDisjointPairRounds(SA.length);
  if (!window.__pairRounds[keyB]) window.__pairRounds[keyB] = buildDisjointPairRounds(SB.length);

  if (window.__pairRoundIdx[keyA] == null) window.__pairRoundIdx[keyA] = 0;
  if (window.__pairRoundIdx[keyB] == null) window.__pairRoundIdx[keyB] = 0;

  const roundsA = window.__pairRounds[keyA];
  const roundsB = window.__pairRounds[keyB];

  const startA = window.__pairRoundIdx[keyA] % roundsA.length;
  const startB = window.__pairRoundIdx[keyB] % roundsB.length;

  const K = 6;
  const candA = Array.from({ length: Math.min(K, roundsA.length) }, (_, k) => roundsA[(startA + k) % roundsA.length]);
  const candB = Array.from({ length: Math.min(K, roundsB.length) }, (_, k) => roundsB[(startB + k) % roundsB.length]);

  let best = null;
  let bestScore = Infinity;

  function toPairs(players, round) {
    return round.map(([i, j]) => ({
      p1: players[i], p2: players[j],
      sum: players[i].level + players[j].level,
      i, j,
      key: pairKeySorted(players[i].name, players[j].name),
    }));
  }

  for (let ia = 0; ia < candA.length; ia++) {
    const PA0 = toPairs(SA, candA[ia]).sort((x, y) => x.sum - y.sum);

    for (let ib = 0; ib < candB.length; ib++) {
      const PB0 = toPairs(SB, candB[ib]).sort((x, y) => x.sum - y.sum);

      const useA = PA0.slice(0, Math.min(need, PA0.length));
      const useB = PB0.slice(0, Math.min(need, PB0.length));

      let score = 0;

      // í˜ì–´ ìˆ˜ ë¶€ì¡± í˜ë„í‹°(ê°€ëŠ¥í•˜ë©´ í”¼í•˜ë˜, 3ëª… 2ë³µ ê°™ì€ ê±´ ì–´ì©” ìˆ˜ ì—†ìŒ)
      if (useA.length < need) score += 500 * (need - useA.length);
      if (useB.length < need) score += 500 * (need - useB.length);

      const m = Math.min(useA.length, useB.length, need);

      const usedPairsA_local = new Set();
      const usedPairsB_local = new Set();
      const usedVersus_local = new Set();

      for (let t = 0; t < m; t++) {
        const a = useA[t], b = useB[t];
        const vKey = versusKey(a.p1, a.p2, b.p1, b.p2);

        // ì´ë²ˆ ìƒì„± ë‚´ ì¤‘ë³µ ê°•ë²Œì 
        if (usedPairsA_local.has(a.key)) score += 999;
        if (usedPairsB_local.has(b.key)) score += 999;
        if (usedVersus_local.has(vKey)) score += 1500;

        usedPairsA_local.add(a.key);
        usedPairsB_local.add(b.key);
        usedVersus_local.add(vKey);

        // ê· í˜•(ì°¨ì´ ìµœì†Œ)
        score += Math.abs(a.sum - b.sum);

        // ê³¼ê±° ì¤‘ë³µ í˜ë„í‹°
        if (history.usedPairsA.has(a.key)) score += 120;
        if (history.usedPairsB.has(b.key)) score += 120;
        if (history.usedVersus.has(vKey)) score += 180;

        // ëª¨ë“œ ì„±í–¥(ì•½í•˜ê²Œë§Œ)
        if (mode === 0) {
          score += 0.3 * (Math.abs(a.i - a.j) + Math.abs(b.i - b.j));
        } else {
          if (!mixedFilter(a.i, a.j, SA.length)) score += 8;
          if (!mixedFilter(b.i, b.j, SB.length)) score += 8;
        }
      }

      if (score < bestScore) {
        bestScore = score;
        best = { ia, ib, useA, useB };
      }
    }
  }

  if (!best) return [];

  // ë‹¤ìŒì— ë‹¤ë¥¸ ë¼ìš´ë“œ ìš°ì„ 
  window.__pairRoundIdx[keyA] = (startA + best.ia + 1) % roundsA.length;
  window.__pairRoundIdx[keyB] = (startB + best.ib + 1) % roundsB.length;

  const result = [];
  for (let t = 0; t < need; t++) {
    const a = best.useA[t % best.useA.length];
    const b = best.useB[t % best.useB.length];
    result.push({ a1: a.p1, a2: a.p2, b1: b.p1, b2: b.p2 });

    history.usedPairsA.add(a.key);
    history.usedPairsB.add(b.key);
    history.usedVersus.add(versusKey(a.p1, a.p2, b.p1, b.p2));
  }

  return result;
}


/* ---------------- ê²½ê¸° ì¹´ë“œ ì¶œë ¥ ---------------- */
function renderMatchCard(teamA, teamB, matchList, exchangeName = "") {
  const key = `${teamA}_vs_${teamB}`;
  const titleText = exchangeName ? `${exchangeName} (${teamA} VS ${teamB})` : `${teamA} VS ${teamB}`;

  let html = `
    <div class='match-card' data-key="${key}" data-team-a="${teamA}" data-team-b="${teamB}">
      <button class="delete-btn" onclick="deleteMatch('${key}')">âŒ</button>
      <h3>${titleText}</h3>
      <table>
        <thead><tr><th>ê²½ê¸°</th><th>ì¶œì „ ì„ ìˆ˜</th><th>ê²°ê³¼</th></tr></thead>
        <tbody>
  `;
  matchList.forEach((m) => {
    const players = m.players || "ë¯¸ì • vs ë¯¸ì •";
    html += `
      <tr>
        <td>${m.label}</td>
        <td onclick="openPlayerPopup('${teamA}','${teamB}',this)">${players}</td>
        <td onclick="openResultPopup(this)" style="cursor:pointer;">${m.result||"-"}</td>
      </tr>`;
  });
  html += `</tbody></table></div>`;
  document.getElementById("summaryArea").innerHTML += html;
}


/* ---------------- ì„ ìˆ˜ ì„ íƒ íŒì—… ---------------- */
function openPlayerPopup(teamA, teamB, cell) {
  const popup = document.getElementById("popup");
  const isDoubles = cell.innerText.includes("/");
  const inputType = isDoubles ? 'checkbox' : 'radio';

  const playersA = (teamData[teamA].players||[]).map(p =>
    `<label><input type='${inputType}' name='teamA' value="${p.name}"> ${p.name}(${p.level})</label><br>`).join('');
  const playersB = (teamData[teamB].players||[]).map(p =>
    `<label><input type='${inputType}' name='teamB' value="${p.name}"> ${p.name}(${p.level})</label><br>`).join('');

  popup.innerHTML = `
  <h4>${teamA} ${isDoubles ? '(2ëª… ì„ íƒ)' : '(1ëª… ì„ íƒ)'}</h4>${playersA}
  <hr>
  <h4>${teamB} ${isDoubles ? '(2ëª… ì„ íƒ)' : '(1ëª… ì„ íƒ)'}</h4>${playersB}
  <br>
  <div style="text-align:center; margin-top:10px;">
    <button class="btn-generate" onclick="${isDoubles ? `setDoubles('${teamA}','${teamB}')` : `setSingles('${teamA}','${teamB}')`}">ì„ íƒ ì™„ë£Œ</button>
    <button class="btn-share" onclick="closePopup()">ë‹«ê¸°</button>
  </div>`;

  popup.targetCell = cell;
  popup.style.display = 'block';
}

function findLevel(teamName, playerName){
  const p = (teamData[teamName].players||[]).find(x=>x.name===playerName);
  return p ? p.level : '?';
}

async function setSingles(teamA, teamB) {
  await requireAuth();
  const popup = document.getElementById("popup");
  const cell = popup.targetCell;
  const selectedA = popup.querySelector("input[name='teamA']:checked");
  const selectedB = popup.querySelector("input[name='teamB']:checked");
  if (!selectedA || !selectedB) { alert("ì–‘ íŒ€ì—ì„œ ê°ê° 1ëª…ì”© ì„ íƒí•´ì£¼ì„¸ìš”."); return; }

  const aTxt = `${selectedA.value}(${findLevel(teamA, selectedA.value)})`;
  const bTxt = `${selectedB.value}(${findLevel(teamB, selectedB.value)})`;
  cell.innerText = `${aTxt} vs ${bTxt}`;

  const card = cell.closest(".match-card");
const teamKey = card.dataset.key;  // âœ… h3 íŒŒì‹± ê¸ˆì§€!
const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(cell.parentElement);

await db.ref(`matches/${teamKey}/matchList/${rowIndex}/players`).set(`${aTxt} vs ${bTxt}`);

  popup.style.display = 'none';
}

async function setDoubles(teamA, teamB) {
  await requireAuth();
  const popup = document.getElementById("popup");
  const cell = popup.targetCell;

  const selectedA = Array.from(popup.querySelectorAll("input[name='teamA']:checked"));
  const selectedB = Array.from(popup.querySelectorAll("input[name='teamB']:checked"));
  if (selectedA.length !== 2 || selectedB.length !== 2) { alert("ê° íŒ€ì—ì„œ 2ëª…ì”© ì„ íƒí•´ì£¼ì„¸ìš”"); return; }

  const a1 = selectedA[0].value, a2 = selectedA[1].value;
  const b1 = selectedB[0].value, b2 = selectedB[1].value;

  const aTxt = `${a1}(${findLevel(teamA,a1)})/${a2}(${findLevel(teamA,a2)})`;
  const bTxt = `${b1}(${findLevel(teamB,b1)})/${b2}(${findLevel(teamB,b2)})`;
  cell.innerText = `${aTxt} vs ${bTxt}`;

  const card = cell.closest(".match-card");
const teamKey = card.dataset.key;  // âœ… h3 íŒŒì‹± ê¸ˆì§€!
const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(cell.parentElement);

await db.ref(`matches/${teamKey}/matchList/${rowIndex}/players`).set(`${aTxt} vs ${bTxt}`);

  popup.style.display = 'none';
}

function closePopup(){ document.getElementById("popup").style.display = 'none'; }

/* ---------------- ê²½ê¸° ê²°ê³¼ íŒì—… ---------------- */
function openResultPopup(cell) {
  const popup = document.getElementById("popup");
  const playerText = cell.parentElement.children[1].innerText;
  const scores = ["3:2","3:1","3:0","0:0","0:3","1:3","2:3","2:1","2:0","0:2","1:2"];
  const buttons = scores.map(s =>
  `<button class="btn-save" onclick="setMatchResult('${s}')">${s}</button>`
).join(" ");

  popup.innerHTML = `
  <p style="font-weight:bold; text-align:center;">ê²½ê¸° ê²°ê³¼ ì…ë ¥</p>
  <p style="text-align:center;">${playerText}</p>
  <div style="text-align:center; margin:10px 0;">${buttons}</div>
  <div style="text-align:center; margin-top:10px;">
    <button class="btn-share" onclick="closePopup()">ë‹«ê¸°</button>
  </div>`;

  popup.targetCell = cell;
  popup.style.display = "block";
}

async function setMatchResult(score) {
  await requireAuth();
  const popup = document.getElementById("popup");
  const cell = popup.targetCell;

  const row = cell.parentElement;
  const playerCell = row.children[1];
  const text = playerCell.innerText;
  const [a,b] = score.split(":").map(Number);
  if (!isNaN(a) && !isNaN(b) && text.includes(" vs ")) {
    let [aNames, bNames] = text.split(" vs ");
    if (a>b) playerCell.innerHTML = `<strong>${aNames}</strong> vs ${bNames}`;
    else if (b>a) playerCell.innerHTML = `${aNames} vs <strong>${bNames}</strong>`;
    else playerCell.innerHTML = `${aNames} vs ${bNames}`;
  }
  cell.innerText = score;

  const card = cell.closest(".match-card");
const teamKey = card.dataset.key;   // h3 ì•ˆ ë´„
const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(cell.parentElement);

await db.ref(`matches/${teamKey}/matchList/${rowIndex}/result`).set(score);

  popup.style.display = "none";
  calculateTeamResults();
}

/* ---------------- ì‹¤ì‹œê°„ Firebase ë¦¬ìŠ¤ë„ˆ ---------------- */
function listenToMatchUpdates() {
    db.ref("matches").on("value", snap => {
    const matches = snap.val();
    document.getElementById("summaryArea").innerHTML = "";

    if (!matches) {
      document.getElementById("rankingArea").innerHTML = "";
      document.querySelector("h2").innerText = "ë‹¨ì²´ì „ ì§„í–‰ (ë°ì´í„° ì—†ìŒ)";
      return;
    }

 // âœ… ëª¨ë“  ê²½ê¸° í‘œì‹œ
const keys = Object.keys(matches);
const titleEl = document.querySelector("h2");

// ì²« ë²ˆì§¸ ê²½ê¸°ì˜ êµë¥˜ì „ ì´ë¦„ë§Œ ìƒë‹¨ì— í‘œì‹œ
const first = matches[keys[0]];
titleEl.innerText = first.exchangeName
  ? `ğŸ“ ${first.exchangeName}`
  : "ë‹¨ì²´ì „ ì§„í–‰";

keys.forEach(key => {
  const m = matches[key];
  const { exchangeName, teamA, teamB } = m;
  const list = Array.isArray(m.matchList)
    ? m.matchList
    : Object.values(m.matchList || {});
  renderMatchCard(teamA, teamB, list, exchangeName);
});


    calculateTeamResults();
  });
}


/* ---------------- ìˆœìœ„ ê³„ì‚° ---------------- */
function calculateTeamResults() {
  const cards = document.querySelectorAll(".match-card");
  const stats = {};
  const teams = new Set();

  // âœ… dataset ê¸°ë°˜ìœ¼ë¡œ íŒ€ ìˆ˜ì§‘
  cards.forEach(card => {
    const teamA = card.dataset.teamA;
    const teamB = card.dataset.teamB;
    if (!teamA || !teamB) return;
    teams.add(teamA); teams.add(teamB);
  });

  teams.forEach(t => stats[t] = { win:0, lose:0, setDiff:0 });

  // âœ… dataset ê¸°ë°˜ìœ¼ë¡œ ê²°ê³¼ ì§‘ê³„
  cards.forEach(card => {
    const teamA = card.dataset.teamA;
    const teamB = card.dataset.teamB;
    if (!teamA || !teamB) return;

    const rows = card.querySelectorAll("tbody tr");
    let wA=0, wB=0, sA=0, sB=0;

    rows.forEach(r => {
      const result = r.children[2].innerText.trim();
      if (!result.includes(":")) return;

      const [a,b] = result.split(":").map(Number);
      if (Number.isNaN(a) || Number.isNaN(b)) return;

      if (a>b) wA++; else if (b>a) wB++;
      sA += a; sB += b;
    });

    stats[teamA].win += wA; stats[teamA].lose += wB; stats[teamA].setDiff += (sA-sB);
    stats[teamB].win += wB; stats[teamB].lose += wA; stats[teamB].setDiff += (sB-sA);
  });

  const sorted = Object.entries(stats).sort((x,y)=>{
    if (y[1].win !== x[1].win) return y[1].win - x[1].win;
    return y[1].setDiff - x[1].setDiff;
  });

  let html = '<h3 style="text-align:center">ğŸ“Š íŒ€ë³„ ê²½ê¸°ê²°ê³¼ ë° ìˆœìœ„í‘œ</h3>';
  html += '<div class="scroll-table"><table><thead><tr><th>íŒ€ëª…</th><th>ìŠ¹</th><th>íŒ¨</th><th>ì„¸íŠ¸ë“ì‹¤</th><th>ìˆœìœ„</th></tr></thead><tbody>';
  sorted.forEach(([team, st], idx)=>{
    html += `<tr><td>${team}</td><td>${st.win}</td><td>${st.lose}</td><td>${st.setDiff}</td><td>${idx+1}</td></tr>`;
  });
  html += '</tbody></table></div>';
  document.getElementById("rankingArea").innerHTML = html;
}


/* ---------------- ì´ë¯¸ì§€ ì €ì¥ ---------------- */
function saveAsImage() {
  const captureArea = document.getElementById("captureArea");
  html2canvas(captureArea, {
    scale: 2,
    scrollX: 0,
    scrollY: 0,
    useCORS: true,
    width: captureArea.scrollWidth,   // ì¶”ê°€
     windowWidth: captureArea.scrollWidth, // ëª¨ë°”ì¼ì—ì„œ ì¶”ê°€ë¡œ ì•ˆì „í•˜
  }).then(canvas => {
    const link = document.createElement("a");
    link.download = `ë‹¨ì²´ì „_ëŒ€ì§„ê²°ê³¼_${new Date().toISOString().slice(0,10)}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
  });
}

function copyLink() {
  const url = "https://bit.ly/ë‹¨ì²´ì „ì§„í–‰";

  // URL ë³µì‚¬
  navigator.clipboard.writeText(url).then(() => {
    // âœ… ìˆœìˆ˜í•œ ì•ˆë‚´ ë©”ì‹œì§€ë§Œ ì¶œë ¥
    alert("ğŸ“‹ ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nì¹´í†¡ì— ë¶™ì—¬ë„£ê¸° í•´ì£¼ì„¸ìš”.");
  }).catch(err => {
    console.error("í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨:", err);

    // ì˜ˆì™¸ ì²˜ë¦¬: êµ¬í˜• ë¸Œë¼ìš°ì € ëŒ€ì‘
    const tempInput = document.createElement("input");
    tempInput.value = url;
    document.body.appendChild(tempInput);
    tempInput.select();
    document.execCommand("copy");
    document.body.removeChild(tempInput);

    // âœ… ë™ì¼í•œ ìˆœìˆ˜ ë©”ì‹œì§€ ì¶œë ¥
    alert("ğŸ“‹ ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nì¹´í†¡ì— ë¶™ì—¬ë„£ê¸° í•´ì£¼ì„¸ìš”.");
  });
}


function showQR() {
  const popup = document.getElementById("popup");
  popup.innerHTML = `
    <div style="text-align:center;">
      <h3>ğŸ“± QR ì½”ë“œ ìŠ¤ìº”</h3>
      <img src="images/qr.png" alt="QRì½”ë“œ" style="width:200px; height:auto; margin:10px 0; border:1px solid #ccc; border-radius:8px;">
      <p style="font-size:14px; color:#555;">ìŠ¤ë§ˆíŠ¸í° ì¹´ë©”ë¼ë¡œ ìŠ¤ìº”í•˜ì„¸ìš”.</p>
      <button class="btn-share" onclick="closePopup()">ë‹«ê¸°</button>
    </div>
  `;
  popup.style.display = "block";
}


async function deleteMatch(key) {
  const pw = prompt("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
  if (pw === null) return; // ì·¨ì†Œ ì‹œ ì¢…ë£Œ
  if (pw !== "7910") {
    alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.");
    return;
  }

  if (!confirm("ì •ë§ ì´ ê²½ê¸°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

  try {
    await db.ref(`matches/${key}`).remove();
    alert("í•´ë‹¹ ê²½ê¸°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
    calculateTeamResults(); // ë‚¨ì€ ê²½ê¸°ë¡œ ìˆœìœ„ ë‹¤ì‹œ ê³„ì‚°
  } catch (error) {
    console.error("ê²½ê¸° ì‚­ì œ ì˜¤ë¥˜:", error);
    alert("ê²½ê¸° ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
  }
}

/* ---------------- ê²½ê¸°ì‹œê°„ ê³„ì‚° ---------------- */
function estimateMatchTime() {
  const popup = document.getElementById("popup");
  
  popup.innerHTML = `
    <h3 style="text-align:center;">â±ï¸ ê²½ê¸°ì‹œê°„ ê³„ì‚°</h3>
    
    <div style="text-align:center; margin-bottom:10px;">
      <p><strong>ğŸ“ íƒêµ¬ ë‹¤ì´(íƒêµ¬ëŒ€) ê°œìˆ˜ ì„ íƒ</strong></p>
      <div id="tableButtons" style="display:flex; justify-content:center; flex-wrap:wrap; gap:8px;">
        ${[1,2,3,4,5,6,7,8].map(n => 
          `<button class="btn-save btn-option" onclick="selectTableCount(this, ${n})">${n}ëŒ€</button>`
        ).join('')}
      </div>
    </div>

    <div id="modeSelect" style="display:none; text-align:center; margin-top:10px;">
      <p><strong>ğŸ® ê²½ê¸° ë°©ì‹ ì„ íƒ</strong></p>
      <div id="modeButtons">
        <button class="btn-share btn-option" onclick="selectMatchMode(this, 1)">3íŒ 2ì„ ìŠ¹ì œ</button>
        <button class="btn-share btn-option" onclick="selectMatchMode(this, 2)">5íŒ 3ì„ ìŠ¹ì œ</button>
      </div>
    </div>

    <div id="calcResult" style="display:none; text-align:center; margin-top:15px; font-weight:bold; color:#0d47a1;"></div>

    <div style="text-align:center; margin-top:15px;">
      <button class="btn-generate" onclick="closePopup()">ë‹«ê¸°</button>
    </div>
  `;

  popup.dataset.tables = "";  // ì´ˆê¸°í™”
  popup.dataset.mode = "";
  popup.style.display = "block";
}

/* âœ… íƒêµ¬ëŒ€ ì„ íƒ ì‹œ ë²„íŠ¼ ìƒ‰ ë³€ê²½ */
function selectTableCount(btn, num) {
  const popup = document.getElementById("popup");
  popup.dataset.tables = num;

  // ëª¨ë“  ë²„íŠ¼ ë¹„í™œì„±í™” í›„ ì„ íƒ ë²„íŠ¼ ê°•ì¡°
  document.querySelectorAll("#tableButtons .btn-option").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");

  document.getElementById("modeSelect").style.display = "block";
}

/* âœ… ê²½ê¸°ë°©ì‹ ì„ íƒ ì‹œ ë²„íŠ¼ ìƒ‰ ë³€ê²½ ë° ê²°ê³¼ í‘œì‹œ */
function selectMatchMode(btn, mode) {
  const popup = document.getElementById("popup");
  popup.dataset.mode = mode;

  document.querySelectorAll("#modeButtons .btn-option").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");

  const numTables = parseInt(popup.dataset.tables);
  const totalMatches = Array.from(document.querySelectorAll(".match-card"))
    .reduce((sum, card) => sum + card.querySelectorAll("tbody tr").length, 0);

  if (totalMatches === 0) {
    alert("âš ï¸ ì•„ì§ ìƒì„±ëœ ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.");
    closePopup();
    return;
  }

  const avgTime = (mode === 1) ? 15 : 25;
  const totalMinutes = Math.ceil((totalMatches / numTables) * avgTime);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;

  const resultEl = document.getElementById("calcResult");
  resultEl.style.display = "block";
  resultEl.innerHTML = `
    ğŸ“Š ì´ ê²½ê¸° ìˆ˜: ${totalMatches}ê²½ê¸°<br>
    ğŸ“ íƒêµ¬ëŒ€: ${numTables}ê°œ<br>
    ğŸ® ë°©ì‹: ${mode === 1 ? "3íŒ 2ì„ ìŠ¹ì œ" : "5íŒ 3ì„ ìŠ¹ì œ"}<br>
    â±ï¸ ê²½ê¸°ë‹¹ í‰ê· : ${avgTime}ë¶„<br><br>
    ğŸ‘‰ ì˜ˆìƒ ì†Œìš”ì‹œê°„: ${hours > 0 ? hours + "ì‹œê°„ " : ""}${minutes}ë¶„
  `;
}

function openAutoModePopup() {
  const popup = document.getElementById("popup");

  popup.innerHTML = `
    <h3 style="text-align:center; margin-bottom:10px;">âš™ï¸ ìë™ ìƒì„± ë°©ì‹ ì„ íƒ</h3>

    <div style="text-align:center; margin-bottom:15px;">
      <button class="btn-save" onclick="selectAutoMode(0)">ì‹¤ë ¥ë§¤ì¹­</button>
      <p style="font-size:14px; color:#444;">â€¢ ê³ ìˆ˜ ì„ ìˆ˜ë¶€í„° ìš°ì„  ë°°ì •í•˜ëŠ” ë°©ì‹</p>

    </div>

    <div style="text-align:center; margin-bottom:15px;">
      <button class="btn-save" onclick="selectAutoMode(1)">ì¡°í•©ë§¤ì¹­</button>
      <p style="font-size:14px; color:#444;">â€¢ ìƒÂ·í•˜ìœ„ ì¡°í•©ì„ ì„ì–´ ë‹¤ì–‘í•œ ê²½ê¸° íë¦„ì„ ë§Œë“œëŠ” ë°©ì‹</p>

    </div>

    <div style="text-align:center;">
      <button class="btn-share" onclick="closePopup()">ë‹«ê¸°</button>
    </div>
  `;

  popup.style.display = "block";
}

function selectAutoMode(mode) {
  autoMode = mode;      // âœ… ì„ íƒëœ ëª¨ë“œ ì €ì¥
  closePopup();         // âœ… íŒì—… ë‹«ê¸°
  autoMatch();          // âœ… ìë™ ìƒì„± ì‹¤í–‰
}

async function addPlayerQuick() {
  if (!checkPassword()) return;

  const name = String(document.getElementById("addName").value || "").trim();
  const level = Number(document.getElementById("addLevel").value);
  const teamName = document.getElementById("addTeamSelect").value;

  if (!teamName) { alert("íŒ€ì„ ì„ íƒí•´ì£¼ì„¸ìš”."); return; }
  if (!name) { alert("ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }
  if (!Number.isFinite(level) || level <= 0) { alert("ë¶€ìˆ˜ë¥¼ ìˆ«ìë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }

  // âœ… íŒ€ ë‚´ ì´ë¦„ ì¤‘ë³µ ë°©ì§€
  const cur = (teamData[teamName]?.players || []).map(p => String(p.name||"").trim());
  if (cur.includes(name)) {
    alert("ì´ë¯¸ ê°™ì€ ì´ë¦„ì´ í•´ë‹¹ íŒ€ì— ìˆìŠµë‹ˆë‹¤.");
    return;
  }

  const teamId = teamData[teamName]?._id;
  if (!teamId) {
    alert("íŒ€ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. loadTeams()ì—ì„œ _id ì €ì¥ì´ í•„ìš”í•©ë‹ˆë‹¤.");
    return;
  }

  await requireAuth();

  const ref = db.ref(`teams/${teamId}/players`);
  const snap = await ref.once("value");
  const raw = snap.val();

  const list = Array.isArray(raw) ? raw.slice() : Object.values(raw || {});
  list.push({ name, level });

  await ref.set(list);

  // âœ… ì…ë ¥ì¹¸ ì •ë¦¬
  document.getElementById("addName").value = "";
  document.getElementById("addLevel").value = "";

  // âœ… ì¦‰ì‹œ ë°˜ì˜(íŒ€ ëª©ë¡ + íŒì—… ëª©ë¡ì—ë„ ë°˜ì˜)
  
  alert(`âœ… ${teamName}ì— ${name}(${level}) ì¶”ê°€ ì™„ë£Œ`);
}


</script>
</body>
</html>
