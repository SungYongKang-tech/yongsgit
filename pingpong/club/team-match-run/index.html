<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
 
   <!-- ✅ 카카오톡 미리보기 (Open Graph) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="단체전 진행 페이지">
  <meta property="og:description" content="탁구 단체전 실시간 경기 기록 및 순위 확인">
  <meta property="og:image" content="https://sensational-tulumba-65e97e.netlify.app/pingpong/club/team-match-run//images/sinyubin.png">
  <meta property="og:url" content="https://bit.ly/단체전진행">
 
   <title>단체전 진행</title>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <!-- html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
  /* 전체 화면 레이아웃 */
body {
  font-family: 'Segoe UI', sans-serif;
  padding: 10px;
  margin: 0;
  background: #f5f7fa;
}

/* 제목 */
h2 {
  text-align: center;
  color: #0d47a1;
  margin: 10px 0 20px;
  font-size: clamp(20px, 4vw, 26px);
}

/* ===== 컨트롤 영역 ===== */
.config {
  display: flex;
  flex-direction: column; /* ✅ 세로로 나란히 배치 */
  gap: 10px;
  max-width: 640px;
  margin: 0 auto 20px;
  align-items: center;
  background: #fff;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

.config label {
  font-weight: bold;
  color: #333;
  text-align: center;
  font-size: clamp(14px, 2.8vw, 16px);
}

/* ===== 버튼 공통 ===== */
button {
  padding: 12px 16px;
  font-size: clamp(15px, 3vw, 18px);
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
  font-weight: 600;
  color: #fff;
}

button:hover {
  transform: translateY(-2px);
}

/* 버튼 그룹 간 간격 */
.btn-group {
  display: flex;
  gap: 8px;
  justify-content: center;
}

/* ===== 생성 버튼 (초록색) ===== */
.btn-generate {
  font-size: 18px;     
  padding: 10px 10px;  /* 높이와 너비 */
  background-color: #e7160f; /* 기본 빨강 */
  min-width: 90px;  /* ✅ 모바일 대응 */
  text-align: center;
}
.btn-generate:hover {
  background-color: #43a047;
}

/* ===== 결과 저장 버튼 (파랑색) ===== */
.btn-save {
  font-size: 18px;     
  padding: 10px 10px;  /* 높이와 너비 */
  background-color: #1976d2; /* 기본 파랑 */
  min-width: 90px;  /* ✅ 모바일 대응 */
  text-align: center;
}
.btn-save:hover {
  background-color: #1565c0;
}

/* ===== 공유 버튼 (보라색) ===== */
.btn-share {
  font-size: 18px;     
  padding: 10px 10px;  /* 높이와 너비 */
  background-color: #7b1fa2; /* 기본 보라 */
  min-width: 90px;  /* ✅ 모바일 대응 */
  text-align: center;
}
.btn-share:hover {
  background-color: #6a1b9a;
}


/* ===== 테이블 ===== */
table {
  border-collapse: collapse;
  width: 100%;
  background: #fff;
  font-size: clamp(14px, 3vw, 18px); /* 글씨 크기 확대 */
}
th, td {
  border: 1px solid #888;
  padding: clamp(6px, 2vw, 10px); /* 셀 높이 넉넉하게 */
  text-align: center;
}
th { background: #e3f2fd; }

/* ===== 대진표 카드 ===== */
.match-card {
  border: 2px solid #0d47a1;
  padding: 12px;
  margin: 15px auto;
  width: 100%;
  max-width: 640px;
  background: #fff;
  border-radius: 10px;
  box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
}
.match-card h3 {
  text-align: center;
  margin-bottom: 12px;
  font-size: clamp(18px, 4vw, 22px);
  color: #0d47a1;
}

/* ===== 순위표 ===== */
.scroll-table {
  border: 1px solid #ccc;
  border-radius: 8px;
  margin: 15px auto;
  width: 100%;
  max-width: 640px;
  overflow-x: auto;
}
.scroll-table table {
  border-collapse: collapse;
  width: 100%;
}
.scroll-table th:first-child,
.scroll-table td:first-child {
  background: #ffe082;
  font-weight: bold;
}

/* 모바일 화면 전용 */
@media (max-width: 400px) {
  .config {
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 6px;
    padding: 5px;
  }
  select, button {
    font-size: 14px;
    padding: 6px;
  }
}

/* ===== 팝업 (중앙 고정) ===== */
.popup {
  position: fixed; /* 화면 기준 고정 */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #fff;
  border: 2px solid #1976d2;
  border-radius: 8px;
  padding: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  z-index: 1001;
  width: 80%;
  max-width: 400px;
  display: none; /* 기본 숨김 */
}

/* 팝업 뒤 어두운 배경 */
#popupOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.4);
  z-index: 1000;
  display: none;
}

.popup button {
  font-size: 14px;
  padding: 6px 10px;
  margin: 3px;
  min-width: 40px;    /* 최소 버튼 가로폭 */
 /* max-width: 40px;   /* 최대 버튼 가로폭 */
  /*display: inline-block; /* 버튼이 자동으로 나란히 배치되도록 */
 } 



/* 버튼 그룹 (항상 한 줄 유지) */
.btn-group {
  display: flex;
  flex-wrap: nowrap; /* ✅ 줄바꿈 방지 */
  gap: 6px;          /* 버튼 간 간격 */
  justify-content: center;
}

/* 단식/복식 선택 영역 가로 배치 */
.config .match-count-group {
  display: flex;
  justify-content: center;   /* 가운데 정렬 */
  gap: 15px;                 /* 단식-복식 사이 간격 */
  width: 100%;
  margin-bottom: 10px;
}

.config .match-count-group label {
  font-size: 18px;
  display: flex;
  flex-direction: column;    /* 라벨 위, 셀렉트 아래 */
  align-items: center;
  font-weight: bold;
  color: #333;
  font-size: clamp(16px, 3vw, 18px);
  gap: 5px;       
}
.config .match-count-group select {
  font-size: 18px;
  padding: 3px 10px;  /* 버튼과 동일 padding 값 */
  border: 2px solid #1976d2;
  border-radius: 6px;
  min-width: 100px;
  text-align: center;
}

/* ❌ 삭제 버튼 */
.delete-btn {
  position: absolute;
  top: 4px;
  right: 6px;
  background: #e53935;
  color: white;
  border: none;
  font-size: 10px;
  padding: 2px 4px;
  border-radius: 3px;
  cursor: pointer;
  z-index: 10;
}
.delete-btn:hover {
  background: #b71c1c;
}
.match-card {
  position: relative; /* 버튼 위치 기준 */
}

/* 선택형 버튼 시각 효과 */
.btn-option {
  opacity: 0.6;
  transition: opacity 0.2s, transform 0.1s;
}
.btn-option:hover {
  transform: translateY(-2px);
}
.btn-option.active {
  opacity: 1;
  box-shadow: 0 0 8px rgba(0,0,0,0.2);
}

</style>

</head>
<body>
  <h2>단체전 진행(made by Sung-Yong)</h2>
  <div class="config">

   <div class="match-count-group">
  <label>단식
    <select id="singlesCnt">
      <option value="0">0경기</option>
      <option value="1">1경기</option>
      <option value="2">2경기</option>
      <option value="3" selected>3경기</option>
      <option value="4">4경기</option>
      <option value="5">5경기</option>
    </select>
  </label>

  <label>복식
    <select id="doublesCnt">
      <option value="0">0경기</option>
      <option value="1">1경기</option>
      <option value="2" selected>2경기</option>
      <option value="3">3경기</option>
      <option value="4">4경기</option>
      <option value="5">5경기</option>
    </select>
  </label>
  </div>

   <!-- ✅ 생성 버튼 -->
  <div class="btn-group">
    <button class="btn-generate" onclick="manualMatch()">수동 생성</button>
    <button class="btn-generate" onclick="autoMatch()">자동 생성</button>
  <!-- 🏓 경기시간 버튼 -->
  <button class="btn-generate" style="background-color:#009688" onclick="estimateMatchTime()">경기시간</button>
</div>

  <!-- ✅ 링크/QR 버튼 -->
  <div class="btn-group">
    <button class="btn-share" onclick="copyLink()">링크 복사</button>
    <button class="btn-share" onclick="showQR()">QR 보기</button>
  
<!-- ✅ 결과 저장 버튼 -->

    <button class="btn-save" onclick="saveAsImage()">대진결과 저장</button>
  </div>

</div>

  

<div id="popup" class="popup" style="display:none;"></div>
  <div id="captureArea">
    <div id="teamListArea" style="margin-bottom:30px;"></div>
    <div id="summaryArea"></div>
    <div id="rankingArea" style="margin-top:40px;"></div>
  </div>

<script>
/* ---------------- Firebase 초기화 ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyA-tp3iJ8-n0yrrd8lwE1IgOdsmDqyh69k",
  authDomain: "koen-teamleague.firebaseapp.com",
  projectId: "koen-teamleague",
  storageBucket: "koen-teamleague.appspot.com",
  messagingSenderId: "487164547059",
  appId: "1:487164547059:web:658a10c8bfe7272ca78c86",
  databaseURL: "https://koen-teamleague-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------------- 전역 상태 ---------------- */
let teamNames = [], teamData = {};
let autoMode = -1; 
const modeNames = ["고수 우선", "하수 우선", "조합 우선"];

/* ---------------- 비밀번호 확인 ---------------- */
function checkPassword() {
  const pw = prompt("비밀번호를 입력하세요:");
  
  // [추가] 취소 버튼을 눌렀을 때 아무 동작도 하지 않음
  if (pw === null) return false;

  if (pw === "7910") return true;

  // 비밀번호가 틀렸을 때만 메시지 표시
  alert("비밀번호가 틀렸습니다.");
  return false;
}


/* ---------------- 로그인 처리 ---------------- */
async function requireAuth() {
  const u = firebase.auth().currentUser;
  if (u) return u;
  await firebase.auth().signInAnonymously();
  return new Promise(resolve => {
    const unsub = firebase.auth().onAuthStateChanged(user => {
      if (user) { unsub(); resolve(user); }
    });
  });
}

firebase.auth().onAuthStateChanged(async (user) => {
  if (!user) {
    try { await firebase.auth().signInAnonymously(); }
    catch (e) { console.error("익명 로그인 실패:", e); }
    return;
  }
  await loadTeams();
  listenToMatchUpdates();
});

/* ---------------- 팀 로드 ---------------- */
function loadTeams() {
  return db.ref("teams").once("value").then(snap => {
    const raw = snap.val();
    teamData = {};
    teamNames = [];
    if (!raw) {
      alert("팀 정보가 없습니다. 먼저 팀을 구성해주세요.");
      return false;
    }
    Object.values(raw).forEach(team => {
      teamData[team.teamName] = team;
      teamNames.push(team.teamName);
    });
    renderTeamList();
    return true;
  });
}

function renderTeamList() {
  let html = '<h3 style="text-align:center">📋 팀 구성 현황</h3><table><tr><th>팀명</th><th>팀원</th></tr>';
  teamNames.forEach(team => {
    const players = (teamData[team].players||[]).map(p => `${p.name}(${p.level})`).join(', ');
    html += `<tr><td>${team}</td><td>${players}</td></tr>`;
  });
  html += '</table>';
  document.getElementById('teamListArea').innerHTML = html;
}

/* ---------------- 수동 대진 생성 ---------------- */
async function manualMatch() {
  if (!checkPassword()) return;
  const ok = await loadTeams();
  if (!ok || teamNames.length === 0) return;

  await requireAuth();
  await db.ref("matches").remove();

  const singles = parseInt(document.getElementById("singlesCnt").value, 10);
  const doubles = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  for (let i = 0; i < teamNames.length; i++) {
    for (let j = i + 1; j < teamNames.length; j++) {
      const matchList = [];
      for (let s = 0; s < singles; s++)
        matchList.push({ label: `${s + 1}단`, players: "미정 vs 미정", result: "-" });
      for (let d = 0; d < doubles; d++)
        matchList.push({ label: `${d + 1}복`, players: "미정/미정 vs 미정/미정", result: "-" });
      const key = `${teamNames[i]}_vs_${teamNames[j]}`;
      updates[`matches/${key}`] = { teamA: teamNames[i], teamB: teamNames[j], matchList };
    }
  }
  await db.ref().update(updates);
}

/* ---------------- 자동 대진 생성 ---------------- */
async function autoMatch() {
  if (!checkPassword()) return;
  const ok = await loadTeams();
  if (!ok || teamNames.length === 0) return;

  autoMode = (autoMode + 1) % 3;
  alert(`자동 생성 모드: ${modeNames[autoMode]}`);

  await requireAuth();
  await db.ref("matches").remove();

  const singlesCnt = parseInt(document.getElementById("singlesCnt").value, 10);
  const doublesCnt = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  for (let i = 0; i < teamNames.length; i++) {
    for (let j = i + 1; j < teamNames.length; j++) {
      const teamA = teamNames[i], teamB = teamNames[j];
      const A = [...(teamData[teamA].players||[])].sort((a,b)=>a.level-b.level);
      const B = [...(teamData[teamB].players||[])].sort((a,b)=>a.level-b.level);

      const singles = generateSinglesPairsByMode(A, B, singlesCnt, autoMode);
      const doubles = generateDoublesPairsByMode(A, B, doublesCnt, autoMode);

      const matchList = [];
      singles.forEach((m, idx) => {
        matchList.push({
          label: `${idx + 1}단`,
          players: `${m.a.name}(${m.a.level}) vs ${m.b.name}(${m.b.level})`,
          result: "-"
        });
      });
      doubles.forEach((m, idx) => {
        matchList.push({
          label: `${idx + 1}복`,
          players: `${m.a1.name}(${m.a1.level})/${m.a2.name}(${m.a2.level}) vs ${m.b1.name}(${m.b1.level})/${m.b2.name}(${m.b2.level})`,
          result: "-"
        });
      });

      const key = `${teamA}_vs_${teamB}`;
      updates[`matches/${key}`] = { teamA, teamB, matchList };
    }
  }
  await db.ref().update(updates);
}

/* -------- 단식: 중복 없는 조합 우선, 부족 시 중복 허용 -------- */
// ✅ 단식 생성 (최종 완성)
function generateSinglesPairsByMode(A, B, need, mode) {
  const result = [];
  const teamSize = Math.min(A.length, B.length);

  // ✅ 안전장치
  if (teamSize === 0) return [];

  // ✅ 선수 정렬 (기본 오름차순)
  A = [...A].sort((a,b)=>a.level - b.level);
  B = [...B].sort((a,b)=>a.level - b.level);

  // ✅ 1) 단식수 == 팀원수 → 전원 1번씩 출전
  if (need === teamSize) {
    for (let i = 0; i < teamSize; i++) {
      result.push({ a: A[i], b: B[i] });
    }
    return result;
  }

  // ✅ 2) 기본 단식(팀원수까지)은 기존 방식 유지 (모드 적용)
  for (let i = 0; i < Math.min(teamSize, need); i++) {
    result.push({ a: A[i], b: B[i] });
  }

  // ✅ 3) 추가 단식은 무조건 회전 배정 (모드와 무관)
  const extraCount = need - teamSize;
  if (extraCount <= 0) return result;

  // ✅ 후보는 전체 선수
  const candidatesA = [...A];  // [A0, A1, A2, A3]
  const candidatesB = [...B];

  // ✅ Firebase에서 로테이션 위치 가져오기
  // 저장 위치 예: /rotation/singles/teamA
  // (없으면 0에서 시작)
  const rotationA = window.singlesRotationA || 0;
  const rotationB = window.singlesRotationB || 0;

  for (let i = 0; i < extraCount; i++) {
    result.push({
      a: candidatesA[(rotationA + i) % candidatesA.length],
      b: candidatesB[(rotationB + i) % candidatesB.length]
    });
  }

  // ✅ 다음 경기 때 회전 시작 위치 계속 이어가기
  window.singlesRotationA = (rotationA + extraCount) % candidatesA.length;
  window.singlesRotationB = (rotationB + extraCount) % candidatesB.length;

  return result.slice(0, need);
}






/* -------- 복식: 동일팀/상대팀 중복 방지, 부족 시 중복 허용 -------- */
const strongFilter = (i, j, n) => (i < Math.ceil(n/2) && j < Math.ceil(n/2));
const weakFilter   = (i, j, n) => (i >= Math.floor(n/2) && j >= Math.floor(n/2));
const mixedFilter  = (i, j, n) => ((i < Math.ceil(n/2) && j >= Math.floor(n/2)) || (j < Math.ceil(n/2) && i >= Math.floor(n/2)));

function allTeamPairsFiltered(players, filterFn) {
  const res = [];
  const n = players.length;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (filterFn && !filterFn(i, j, n)) continue;
      const p1 = players[i], p2 = players[j];
      res.push({ p1, p2, sum: p1.level + p2.level, i, j });
    }
  }
  return res;
}

function allTeamPairs(players) { return allTeamPairsFiltered(players, null); }
function pairKeySorted(n1, n2) { return [n1, n2].sort().join('/'); }
function versusKey(a1,a2,b1,b2){ return `${pairKeySorted(a1.name,a2.name)}||${pairKeySorted(b1.name,b2.name)}`; }

function greedyMatchPairs(pairsA, pairsB, need, usedPlayersA, usedPlayersB, usedPairsA, usedPairsB, usedVersus, allowDuplicates = false, lockedPairs = new Set()) {
  const res = [];

  while (res.length < need) {
    let best = null;
    let bestDiff = Infinity;

    for (const a of pairsA) {
      const aPlayers = [a.p1.name, a.p2.name];
      const aKey = pairKeySorted(a.p1.name, a.p2.name);

      // A팀 동일 조합 방지
      if ((!allowDuplicates && usedPairsA.has(aKey)) || lockedPairs.has(aKey)) continue;

      // 선수 개별 중복 방지
      if (!allowDuplicates && (usedPlayersA.has(aPlayers[0]) || usedPlayersA.has(aPlayers[1]))) continue;

      for (const b of pairsB) {
        const bPlayers = [b.p1.name, b.p2.name];
        const bKey = pairKeySorted(b.p1.name, b.p2.name);

        // B팀 동일 조합 방지
        if ((!allowDuplicates && usedPairsB.has(bKey)) || lockedPairs.has(bKey)) continue;

        // 선수 개별 중복 방지
        if (!allowDuplicates && (usedPlayersB.has(bPlayers[0]) || usedPlayersB.has(bPlayers[1]))) continue;

        // 동일 상대 조합 방지
        const vKey = versusKey(a.p1, a.p2, b.p1, b.p2);
        if ((!allowDuplicates && usedVersus.has(vKey)) || lockedPairs.has(vKey)) continue;

        const diff = Math.abs(a.sum - b.sum);
        if (diff < bestDiff) {
          bestDiff = diff;
          best = { a, b, aPlayers, bPlayers, aKey, bKey, vKey };
        }
      }
    }

    if (!best) break; // 더 이상 조합이 없으면 종료

    // 확정
    res.push({
      a1: best.a.p1, a2: best.a.p2,
      b1: best.b.p1, b2: best.b.p2
    });

    // 사용 기록
    best.aPlayers.forEach(name => usedPlayersA.add(name));
    best.bPlayers.forEach(name => usedPlayersB.add(name));
    usedPairsA.add(best.aKey);
    usedPairsB.add(best.bKey);
    usedVersus.add(best.vKey);

    // 첫 두 경기 확정 조합은 lockedPairs에 추가 → 이후 절대 재사용 불가
    if (res.length <= 2) {
      lockedPairs.add(best.aKey);
      lockedPairs.add(best.bKey);
      lockedPairs.add(best.vKey);
    }
  }

  return res;
}


function generateDoublesPairsByMode(A, B, need, mode) {
  if (need <= 0) return [];

  const usedPlayersA = new Set();
  const usedPlayersB = new Set();

  const usedPairsA = new Set(); // 팀 내 동일 2명 조합 방지
  const usedPairsB = new Set();
  const usedVersus = new Set(); // 동일 상대팀 방지
  const lockedPairs = new Set(); // 1복, 2복 확정 후 고정

  let bucketOrder = [];

  // 모드별 우선순위
  if (mode === 0) { // 고수 우선
    bucketOrder = [
      { a: allTeamPairsFiltered(A, strongFilter), b: allTeamPairsFiltered(B, strongFilter) },
      { a: allTeamPairsFiltered(A, weakFilter),   b: allTeamPairsFiltered(B, weakFilter) },
      { a: allTeamPairs(A),                       b: allTeamPairs(B) }
    ];
  } else if (mode === 1) { // 하수 우선
    bucketOrder = [
      { a: allTeamPairsFiltered(A, weakFilter),   b: allTeamPairsFiltered(B, weakFilter) },
      { a: allTeamPairsFiltered(A, strongFilter), b: allTeamPairsFiltered(B, strongFilter) },
      { a: allTeamPairs(A),                       b: allTeamPairs(B) }
    ];
  } else { // 조합 우선
    bucketOrder = [
      { a: allTeamPairsFiltered(A, mixedFilter),  b: allTeamPairsFiltered(B, mixedFilter) },
      { a: allTeamPairs(A),                       b: allTeamPairs(B) }
    ];
  }

  let result = [];

  /* 1단계: 첫 두 경기는 완전 중복 금지 */
  for (const bucket of bucketOrder) {
    if (result.length >= 2 || result.length >= need) break;
    const add = greedyMatchPairs(
      bucket.a, bucket.b, 2 - result.length,
      usedPlayersA, usedPlayersB,
      usedPairsA, usedPairsB,
      usedVersus,
      false, // 완전 중복 금지
      lockedPairs
    );
    result = result.concat(add);
  }

/* 2단계: 남은 경기(3복 이후)는 먼저 '중복 없이' 시도하고, 부족할 때만 중복 허용 */
if (result.length < need) {
  for (const bucket of bucketOrder) {
    if (result.length >= need) break;

    const remaining = need - result.length;

    // 🟢 2-1단계: 중복 없이 최대한 채우기
    const noDupAdd = greedyMatchPairs(
      bucket.a, bucket.b, remaining,
      usedPlayersA, usedPlayersB,
      usedPairsA, usedPairsB,
      usedVersus,
      false,      // ❌ 중복 허용 안 함
      lockedPairs // 1복, 2복은 절대 재사용 금지
    );
    result = result.concat(noDupAdd);

    // 🟢 2-2단계: 그래도 부족하면 중복 허용으로 채우기
    if (result.length < need) {
      const stillRemaining = need - result.length;
      const dupAdd = greedyMatchPairs(
        bucket.a, bucket.b, stillRemaining,
        usedPlayersA, usedPlayersB,
        usedPairsA, usedPairsB,
        usedVersus,
        true,       // ✅ 중복 허용
        lockedPairs
      );
      result = result.concat(dupAdd);
    }
  }
}



/* 3단계: 그래도 경기 수가 부족하면 강제로 중복 허용 (최종 예외 처리) */
if (result.length < need) {
  console.warn("⚠️ 선수 부족으로 인해 복식 경기 강제 중복 생성");
  for (const bucket of bucketOrder) {
    if (result.length >= need) break;
    const add = greedyMatchPairs(
      bucket.a, bucket.b, need - result.length,
      new Set(), new Set(), // 완전히 초기화 → 중복 완전 허용
      new Set(), new Set(),
      new Set(),
      true, // 모든 중복 허용
      new Set()
    );
    result = result.concat(add);
  }
}

return result.slice(0, need);

}






/* ---------------- 경기 카드 출력 ---------------- */
function renderMatchCard(teamA, teamB, matchList, exchangeName = "") {
  let key = `${teamA}_vs_${teamB}`;
const titleText = exchangeName
  ? `${exchangeName}`
  : `${teamA} VS ${teamB}`;


  let html = `
    <div class='match-card'>
      <button class="delete-btn" onclick="deleteMatch('${key}')">❌</button>
      <h3>${titleText}</h3>

      <table>
        <thead><tr><th>경기</th><th>출전 선수</th><th>결과</th></tr></thead>
        <tbody>
  `;
  matchList.forEach((m) => {
    const players = m.players || "미정 vs 미정";
    html += `
      <tr>
        <td>${m.label}</td>
        <td onclick="openPlayerPopup('${teamA}','${teamB}',this)">${players}</td>
        <td onclick="openResultPopup(this)" style="cursor:pointer;">${m.result||"-"}</td>
      </tr>`;
  });
  html += `</tbody></table></div>`;
  document.getElementById("summaryArea").innerHTML += html;
}


/* ---------------- 선수 선택 팝업 ---------------- */
function openPlayerPopup(teamA, teamB, cell) {
  const popup = document.getElementById("popup");
  const isDoubles = cell.innerText.includes("/");
  const inputType = isDoubles ? 'checkbox' : 'radio';

  const playersA = (teamData[teamA].players||[]).map(p =>
    `<label><input type='${inputType}' name='teamA' value="${p.name}"> ${p.name}(${p.level})</label><br>`).join('');
  const playersB = (teamData[teamB].players||[]).map(p =>
    `<label><input type='${inputType}' name='teamB' value="${p.name}"> ${p.name}(${p.level})</label><br>`).join('');

  popup.innerHTML = `
  <h4>${teamA} ${isDoubles ? '(2명 선택)' : '(1명 선택)'}</h4>${playersA}
  <hr>
  <h4>${teamB} ${isDoubles ? '(2명 선택)' : '(1명 선택)'}</h4>${playersB}
  <br>
  <div style="text-align:center; margin-top:10px;">
    <button class="btn-generate" onclick="${isDoubles ? `setDoubles('${teamA}','${teamB}')` : `setSingles('${teamA}','${teamB}')`}">선택 완료</button>
    <button class="btn-share" onclick="closePopup()">닫기</button>
  </div>`;

  popup.targetCell = cell;
  popup.style.display = 'block';
}

function findLevel(teamName, playerName){
  const p = (teamData[teamName].players||[]).find(x=>x.name===playerName);
  return p ? p.level : '?';
}

async function setSingles(teamA, teamB) {
  await requireAuth();
  const popup = document.getElementById("popup");
  const cell = popup.targetCell;
  const selectedA = popup.querySelector("input[name='teamA']:checked");
  const selectedB = popup.querySelector("input[name='teamB']:checked");
  if (!selectedA || !selectedB) { alert("양 팀에서 각각 1명씩 선택해주세요."); return; }

  const aTxt = `${selectedA.value}(${findLevel(teamA, selectedA.value)})`;
  const bTxt = `${selectedB.value}(${findLevel(teamB, selectedB.value)})`;
  cell.innerText = `${aTxt} vs ${bTxt}`;

  const card = cell.closest(".match-card");
  const [aTeam,bTeam] = card.querySelector("h3").innerText.split(" VS ");
  const teamKey = `${aTeam}_vs_${bTeam}`;
  const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(cell.parentElement);
  await db.ref(`matches/${teamKey}/matchList/${rowIndex}/players`).set(`${aTxt} vs ${bTxt}`);

  popup.style.display = 'none';
}

async function setDoubles(teamA, teamB) {
  await requireAuth();
  const popup = document.getElementById("popup");
  const cell = popup.targetCell;

  const selectedA = Array.from(popup.querySelectorAll("input[name='teamA']:checked"));
  const selectedB = Array.from(popup.querySelectorAll("input[name='teamB']:checked"));
  if (selectedA.length !== 2 || selectedB.length !== 2) { alert("각 팀에서 2명씩 선택해주세요"); return; }

  const a1 = selectedA[0].value, a2 = selectedA[1].value;
  const b1 = selectedB[0].value, b2 = selectedB[1].value;

  const aTxt = `${a1}(${findLevel(teamA,a1)})/${a2}(${findLevel(teamA,a2)})`;
  const bTxt = `${b1}(${findLevel(teamB,b1)})/${b2}(${findLevel(teamB,b2)})`;
  cell.innerText = `${aTxt} vs ${bTxt}`;

  const card = cell.closest(".match-card");
  const [aTeam,bTeam] = card.querySelector("h3").innerText.split(" VS ");
  const teamKey = `${aTeam}_vs_${bTeam}`;
  const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(cell.parentElement);
  await db.ref(`matches/${teamKey}/matchList/${rowIndex}/players`).set(`${aTxt} vs ${bTxt}`);

  popup.style.display = 'none';
}

function closePopup(){ document.getElementById("popup").style.display = 'none'; }

/* ---------------- 경기 결과 팝업 ---------------- */
function openResultPopup(cell) {
  const popup = document.getElementById("popup");
  const playerText = cell.parentElement.children[1].innerText;
  const scores = ["3:2","3:1","3:0","0:0","0:3","1:3","2:3","2:1","2:0","0:2","1:2"];
  const buttons = scores.map(s =>
  `<button class="btn-save" onclick="setMatchResult('${s}')">${s}</button>`
).join(" ");

  popup.innerHTML = `
  <p style="font-weight:bold; text-align:center;">경기 결과 입력</p>
  <p style="text-align:center;">${playerText}</p>
  <div style="text-align:center; margin:10px 0;">${buttons}</div>
  <div style="text-align:center; margin-top:10px;">
    <button class="btn-share" onclick="closePopup()">닫기</button>
  </div>`;

  popup.targetCell = cell;
  popup.style.display = "block";
}

async function setMatchResult(score) {
  await requireAuth();
  const popup = document.getElementById("popup");
  const cell = popup.targetCell;

  const row = cell.parentElement;
  const playerCell = row.children[1];
  const text = playerCell.innerText;
  const [a,b] = score.split(":").map(Number);
  if (!isNaN(a) && !isNaN(b) && text.includes(" vs ")) {
    let [aNames, bNames] = text.split(" vs ");
    if (a>b) playerCell.innerHTML = `<strong>${aNames}</strong> vs ${bNames}`;
    else if (b>a) playerCell.innerHTML = `${aNames} vs <strong>${bNames}</strong>`;
    else playerCell.innerHTML = `${aNames} vs ${bNames}`;
  }
  cell.innerText = score;

  const card = cell.closest(".match-card");
  const [teamA, teamB] = card.querySelector("h3").innerText.split(" VS ");
  const teamKey = `${teamA}_vs_${teamB}`;
  const rowIndex = [...card.querySelectorAll("tbody tr")].indexOf(cell.parentElement);
  await db.ref(`matches/${teamKey}/matchList/${rowIndex}/result`).set(score);

  popup.style.display = "none";
  calculateTeamResults();
}

/* ---------------- 실시간 Firebase 리스너 ---------------- */
function listenToMatchUpdates() {
    db.ref("matches").on("value", snap => {
    const matches = snap.val();
    document.getElementById("summaryArea").innerHTML = "";

    if (!matches) {
      document.getElementById("rankingArea").innerHTML = "";
      document.querySelector("h2").innerText = "단체전 진행 (데이터 없음)";
      return;
    }

 // ✅ 모든 경기 표시
const keys = Object.keys(matches);
const titleEl = document.querySelector("h2");

// 첫 번째 경기의 교류전 이름만 상단에 표시
const first = matches[keys[0]];
titleEl.innerText = first.exchangeName
  ? `🏓 ${first.exchangeName}`
  : "단체전 진행";

keys.forEach(key => {
  const m = matches[key];
  const { exchangeName, teamA, teamB } = m;
  const list = Array.isArray(m.matchList)
    ? m.matchList
    : Object.values(m.matchList || {});
  renderMatchCard(teamA, teamB, list, exchangeName);
});


    calculateTeamResults();
  });
}


/* ---------------- 순위 계산 ---------------- */
function calculateTeamResults() {
  const cards = document.querySelectorAll(".match-card");
  const stats = {};
  const teams = new Set();

  cards.forEach(card => {
    const [a,b] = card.querySelector("h3").innerText.split(" VS ");
    teams.add(a); teams.add(b);
  });
  teams.forEach(t => stats[t] = { win:0, lose:0, setDiff:0 });

  cards.forEach(card => {
    const [teamA, teamB] = card.querySelector("h3").innerText.split(" VS ");
    const rows = card.querySelectorAll("tbody tr");
    let wA=0, wB=0, sA=0, sB=0;
    rows.forEach(r => {
      const result = r.children[2].innerText.trim();
      if (!result.includes(":")) return;
      const [a,b] = result.split(":").map(Number);
      if (a>b) wA++; else if (b>a) wB++;
      sA += a||0; sB += b||0;
    });
    stats[teamA].win += wA; stats[teamA].lose += wB; stats[teamA].setDiff += (sA-sB);
    stats[teamB].win += wB; stats[teamB].lose += wA; stats[teamB].setDiff += (sB-sA);
  });

  const sorted = Object.entries(stats).sort((x,y)=>{
    if (y[1].win !== x[1].win) return y[1].win - x[1].win;
    return y[1].setDiff - x[1].setDiff;
  });

  let html = '<h3 style="text-align:center">📊 팀별 경기결과 및 순위표</h3>';
  html += '<div class="scroll-table"><table><thead><tr><th>팀명</th><th>승</th><th>패</th><th>세트득실</th><th>순위</th></tr></thead><tbody>';
  sorted.forEach(([team, st], idx)=>{
    html += `<tr><td>${team}</td><td>${st.win}</td><td>${st.lose}</td><td>${st.setDiff}</td><td>${idx+1}</td></tr>`;
  });
  html += '</tbody></table></div>';
  document.getElementById("rankingArea").innerHTML = html;
}

/* ---------------- 이미지 저장 ---------------- */
function saveAsImage() {
  const captureArea = document.getElementById("captureArea");
  html2canvas(captureArea, {
    scale: 2,
    scrollX: 0,
    scrollY: 0,
    useCORS: true,
    width: captureArea.scrollWidth,   // 추가
     windowWidth: captureArea.scrollWidth, // 모바일에서 추가로 안전하
  }).then(canvas => {
    const link = document.createElement("a");
    link.download = `단체전_대진결과_${new Date().toISOString().slice(0,10)}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
  });
}

function copyLink() {
  const url = "https://bit.ly/단체전진행";

  // URL 복사
  navigator.clipboard.writeText(url).then(() => {
    // ✅ 순수한 안내 메시지만 출력
    alert("📋 링크가 복사되었습니다!\n카톡에 붙여넣기 해주세요.");
  }).catch(err => {
    console.error("클립보드 복사 실패:", err);

    // 예외 처리: 구형 브라우저 대응
    const tempInput = document.createElement("input");
    tempInput.value = url;
    document.body.appendChild(tempInput);
    tempInput.select();
    document.execCommand("copy");
    document.body.removeChild(tempInput);

    // ✅ 동일한 순수 메시지 출력
    alert("📋 링크가 복사되었습니다!\n카톡에 붙여넣기 해주세요.");
  });
}


function showQR() {
  const popup = document.getElementById("popup");
  popup.innerHTML = `
    <div style="text-align:center;">
      <h3>📱 QR 코드 스캔</h3>
      <img src="images/qr.png" alt="QR코드" style="width:200px; height:auto; margin:10px 0; border:1px solid #ccc; border-radius:8px;">
      <p style="font-size:14px; color:#555;">스마트폰 카메라로 스캔하세요.</p>
      <button class="btn-share" onclick="closePopup()">닫기</button>
    </div>
  `;
  popup.style.display = "block";
}


function closePopup() {
  document.getElementById("popup").style.display = "none";
}

async function deleteMatch(key) {
  const pw = prompt("비밀번호를 입력하세요:");
  if (pw === null) return; // 취소 시 종료
  if (pw !== "7910") {
    alert("비밀번호가 틀렸습니다.");
    return;
  }

  if (!confirm("정말 이 경기를 삭제하시겠습니까?")) return;

  try {
    await db.ref(`matches/${key}`).remove();
    alert("해당 경기가 삭제되었습니다.");
    calculateTeamResults(); // 남은 경기로 순위 다시 계산
  } catch (error) {
    console.error("경기 삭제 오류:", error);
    alert("경기 삭제 중 오류가 발생했습니다.");
  }
}

/* ---------------- 경기시간 계산 ---------------- */
function estimateMatchTime() {
  const popup = document.getElementById("popup");
  
  popup.innerHTML = `
    <h3 style="text-align:center;">⏱️ 경기시간 계산</h3>
    
    <div style="text-align:center; margin-bottom:10px;">
      <p><strong>🏓 탁구 다이(탁구대) 개수 선택</strong></p>
      <div id="tableButtons" style="display:flex; justify-content:center; flex-wrap:wrap; gap:8px;">
        ${[1,2,3,4,5,6,7,8].map(n => 
          `<button class="btn-save btn-option" onclick="selectTableCount(this, ${n})">${n}대</button>`
        ).join('')}
      </div>
    </div>

    <div id="modeSelect" style="display:none; text-align:center; margin-top:10px;">
      <p><strong>🎮 경기 방식 선택</strong></p>
      <div id="modeButtons">
        <button class="btn-share btn-option" onclick="selectMatchMode(this, 1)">3판 2선승제</button>
        <button class="btn-share btn-option" onclick="selectMatchMode(this, 2)">5판 3선승제</button>
      </div>
    </div>

    <div id="calcResult" style="display:none; text-align:center; margin-top:15px; font-weight:bold; color:#0d47a1;"></div>

    <div style="text-align:center; margin-top:15px;">
      <button class="btn-generate" onclick="closePopup()">닫기</button>
    </div>
  `;

  popup.dataset.tables = "";  // 초기화
  popup.dataset.mode = "";
  popup.style.display = "block";
}

/* ✅ 탁구대 선택 시 버튼 색 변경 */
function selectTableCount(btn, num) {
  const popup = document.getElementById("popup");
  popup.dataset.tables = num;

  // 모든 버튼 비활성화 후 선택 버튼 강조
  document.querySelectorAll("#tableButtons .btn-option").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");

  document.getElementById("modeSelect").style.display = "block";
}

/* ✅ 경기방식 선택 시 버튼 색 변경 및 결과 표시 */
function selectMatchMode(btn, mode) {
  const popup = document.getElementById("popup");
  popup.dataset.mode = mode;

  document.querySelectorAll("#modeButtons .btn-option").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");

  const numTables = parseInt(popup.dataset.tables);
  const totalMatches = Array.from(document.querySelectorAll(".match-card"))
    .reduce((sum, card) => sum + card.querySelectorAll("tbody tr").length, 0);

  if (totalMatches === 0) {
    alert("⚠️ 아직 생성된 경기가 없습니다.");
    closePopup();
    return;
  }

  const avgTime = (mode === 1) ? 15 : 25;
  const totalMinutes = Math.ceil((totalMatches / numTables) * avgTime);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;

  const resultEl = document.getElementById("calcResult");
  resultEl.style.display = "block";
  resultEl.innerHTML = `
    📊 총 경기 수: ${totalMatches}경기<br>
    🏓 탁구대: ${numTables}개<br>
    🎮 방식: ${mode === 1 ? "3판 2선승제" : "5판 3선승제"}<br>
    ⏱️ 경기당 평균: ${avgTime}분<br><br>
    👉 예상 소요시간: ${hours > 0 ? hours + "시간 " : ""}${minutes}분
  `;
}

</script>
</body>
</html>
