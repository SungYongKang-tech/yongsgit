<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>단체전 진행</title>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <!-- html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    body { font-family:'Segoe UI', sans-serif; padding:20px; background:#f5f7fa }
    h2 { text-align:center; color:#0d47a1; margin:10px 0 30px }
    .config { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:20px }
    select, button { padding:6px 14px; font-size:15px; cursor:pointer }
    table { border-collapse:collapse; width:100%; max-width:600px; margin:0 auto }
    th, td { border:1px solid #888; padding:8px 12px; text-align:center }
    th { background:#e3f2fd }
    .match-card { border:3px solid #0d47a1; padding:20px; margin:30px auto; max-width:720px; background:#fff; border-radius:14px; box-shadow:2px 2px 10px rgba(0,0,0,0.12) }
    .match-card h3 { text-align:center; margin-bottom:20px; font-size:20px; color:#0d47a1 }
    .scroll-table { overflow-x:auto; border:1px solid #ccc; border-radius:8px; margin:20px auto; width:100%; max-width:720px; }
    .scroll-table table { border-collapse:collapse; width:100%; min-width:500px; background:#fff; }
    .scroll-table th, .scroll-table td { border:1px solid #888; padding:16px 10px; text-align:center; font-size:16px; white-space:nowrap; }
    .scroll-table th:first-child, .scroll-table td:first-child { background:#ffe082; font-weight:bold; }
  </style>
</head>
<body>
  <div id="teamListArea" style="margin-bottom:30px;"></div>
  <h2>단체전 진행</h2>
  <div class="config">
    단식
    <select id="singlesCnt">
      <option value="0">0경기</option>
      <option value="1">1경기</option>
      <option value="2">2경기</option>
      <option value="3" selected>3경기</option>
      <option value="4">4경기</option>
      <option value="5">5경기</option>
    </select>
    복식
    <select id="doublesCnt">
      <option value="0">0경기</option>
      <option value="1">1경기</option>
      <option value="2" selected>2경기</option>
      <option value="3">3경기</option>
      <option value="4">4경기</option> <!-- 최대 4경기까지 지원 -->
    </select>

    <button onclick="manualMatch()">대진표 수동 생성</button>
    <button onclick="autoMatch()">대진표 자동 생성</button>
    <button onclick="saveAsImage()">대진결과 저장</button>
  </div>

  <div id="captureArea">
    <div id="summaryArea"></div>
    <div id="rankingArea" style="margin-top:40px;"></div>
  </div>

<script>
/* ---------------- Firebase 초기화 ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyA-tp3iJ8-n0yrrd8lwE1IgOdsmDqyh69k",
  authDomain: "koen-teamleague.firebaseapp.com",
  projectId: "koen-teamleague",
  storageBucket: "koen-teamleague.appspot.com",
  messagingSenderId: "487164547059",
  appId: "1:487164547059:web:658a10c8bfe7272ca78c86",
  databaseURL: "https://koen-teamleague-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------------- 전역 상태 ---------------- */
let teamNames = [], teamData = {};
let autoMode = -1; // 첫 클릭은 강자끼리

/* ---------------- 비밀번호 확인 ---------------- */
function checkPassword() {
  const pw = prompt("비밀번호를 입력하세요:");
  if (pw === "7910") return true;
  alert("비밀번호가 틀렸습니다.");
  return false;
}

/* ---------------- 로그인 처리 ---------------- */
async function requireAuth() {
  const u = firebase.auth().currentUser;
  if (u) return u;
  await firebase.auth().signInAnonymously();
  return new Promise(resolve => {
    const unsub = firebase.auth().onAuthStateChanged(user => {
      if (user) { unsub(); resolve(user); }
    });
  });
}

firebase.auth().onAuthStateChanged(async (user) => {
  if (!user) {
    try { await firebase.auth().signInAnonymously(); }
    catch (e) { console.error("익명 로그인 실패:", e); }
    return;
  }
  await loadTeams();
  listenToMatchUpdates();
});

/* ---------------- 팀 로드 ---------------- */
function loadTeams() {
  return db.ref("teams").once("value").then(snap => {
    const raw = snap.val();
    teamData = {};
    teamNames = [];
    if (!raw) {
      alert("팀 정보가 없습니다. 먼저 팀을 구성해주세요.");
      return false;
    }
    Object.values(raw).forEach(team => {
      teamData[team.teamName] = team;
      teamNames.push(team.teamName);
    });
    renderTeamList();
    return true;
  });
}

function renderTeamList() {
  let html = '<h3 style="text-align:center">📋 팀 구성 현황</h3><table><tr><th>팀명</th><th>팀원</th></tr>';
  teamNames.forEach(team => {
    const players = teamData[team].players.map(p => `${p.name}(${p.level})`).join(', ');
    html += `<tr><td>${team}</td><td>${players}</td></tr>`;
  });
  html += '</table>';
  document.getElementById('teamListArea').innerHTML = html;
}

/* ---------------- 수동 대진 생성 ---------------- */
async function manualMatch() {
  if (!checkPassword()) return;
  const ok = await loadTeams();
  if (!ok || teamNames.length === 0) return;
  await generateManualMatches();
}

async function generateManualMatches() {
  await requireAuth();
  await db.ref("matches").remove();

  const singles = parseInt(document.getElementById("singlesCnt").value, 10);
const doubles = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  document.getElementById("summaryArea").innerHTML = "";

  for (let i = 0; i < teamNames.length; i++) {
    for (let j = i + 1; j < teamNames.length; j++) {
      const matchList = [];
      for (let s = 0; s < singles; s++)
        matchList.push({ label: `${s + 1}단`, players: "미정 vs 미정", result: "-" });
      for (let d = 0; d < doubles; d++)
        matchList.push({ label: `${d + 1}복`, players: "미정/미정 vs 미정/미정", result: "-" });

      const key = `${teamNames[i]}_vs_${teamNames[j]}`;
      updates[`matches/${key}`] = { teamA: teamNames[i], teamB: teamNames[j], matchList };
      renderMatchCard(teamNames[i], teamNames[j], matchList);
    }
  }
  await db.ref().update(updates);
}

/* ---------------- 자동 대진 생성 ---------------- */
async function autoMatch() {
  if (!checkPassword()) return;
  const ok = await loadTeams();
  if (!ok || teamNames.length === 0) return;

  autoMode = (autoMode + 1) % 3;
  const modeNames = ["강자끼리", "약자끼리", "강약 혼합"];
  alert(`자동 생성 모드: ${modeNames[autoMode]}`);

  await requireAuth();
  await db.ref("matches").remove();
  const singles = parseInt(document.getElementById("singlesCnt").value, 10);
const doubles = parseInt(document.getElementById("doublesCnt").value, 10);

  const updates = {};
  document.getElementById("summaryArea").innerHTML = "";

  teamNames.forEach((teamA, i) => {
    for (let j = i + 1; j < teamNames.length; j++) {
      const teamB = teamNames[j];
      let playersA = [...teamData[teamA].players];
      let playersB = [...teamData[teamB].players];

      // 부수가 낮을수록 강자 → 오름차순
      if (autoMode === 0) { // 강자끼리
        playersA.sort((a,b) => a.level - b.level);
        playersB.sort((a,b) => a.level - b.level);
      } else if (autoMode === 1) { // 약자끼리
        playersA.sort((a,b) => b.level - a.level);
        playersB.sort((a,b) => b.level - a.level);
      } else {
        var singlesA = [...playersA].sort((a,b) => a.level - b.level); 
        var singlesB = [...playersB].sort((a,b) => a.level - b.level); 
        playersA.sort((a,b) => a.level - b.level); // 복식용 A팀 강자순
        playersB.sort((a,b) => b.level - a.level); // 복식용 B팀 약자순
      }

      const matchList = [];

      // 단식은 항상 강자순
      for (let s = 0; s < singles; s++) {
        const aPlayer = (autoMode === 2 ? singlesA : playersA)[s % playersA.length];
        const bPlayer = (autoMode === 2 ? singlesB : playersB)[s % playersB.length];
        matchList.push({
          label: `${s + 1}단`,
          players: `${aPlayer.name}(${aPlayer.level}) vs ${bPlayer.name}(${bPlayer.level})`,
          result: "-"
        });
      }

      // 복식 자동 조합
      const doublesList = pickDoublesPairs(playersA, playersB, doubles);
      doublesList.forEach((pair, index) => {
        matchList.push({
          label: `${index + 1}복`,
          players: `${pair.a1.name}(${pair.a1.level})/${pair.a2.name}(${pair.a2.level}) vs ` +
                   `${pair.b1.name}(${pair.b1.level})/${pair.b2.name}(${pair.b2.level})`,
          result: "-"
        });
      });

      const key = `${teamA}_vs_${teamB}`;
      updates[`matches/${key}`] = { teamA, teamB, matchList };
      renderMatchCard(teamA, teamB, matchList);
    }
  });
  await db.ref().update(updates);
}

/* ---------------- 복식 조합 함수 ---------------- */
function allPairs(players, used) {
  const res = [];
  for (let i = 0; i < players.length; i++) {
    for (let j = i + 1; j < players.length; j++) {
      if (used.has(players[i].name) || used.has(players[j].name)) continue;
      res.push({ pair: [players[i], players[j]], total: players[i].level + players[j].level });
    }
  }
  return res;
}

function pickDoublesPairs(playersA, playersB, need) {
  const usedPair = new Set(); // 같은 두 선수 조합 방지
  const res = [];

  for (let k = 0; k < need; k++) {
    let pairsA = allPairs(playersA, new Set()); // usedA 제거
    let pairsB = allPairs(playersB, new Set()); // usedB 제거

    // 같은 조합(두 사람) 반복 방지
    pairsA = pairsA.filter(pa => !usedPair.has(pa.pair.map(x=>x.name).sort().join('-')));
    pairsB = pairsB.filter(pb => !usedPair.has(pb.pair.map(x=>x.name).sort().join('-')));

    if (pairsA.length === 0 || pairsB.length === 0) {
      console.warn("복식 조합 부족, 일부 경기를 채우지 못했습니다.");
      continue; // break → continue
    }

    let best = null, bestDiff = Infinity;

    pairsA.forEach(pa => {
      pairsB.forEach(pb => {
        const diff = Math.abs(pa.total - pb.total);
        if (diff < bestDiff) {
          bestDiff = diff;
          best = { a: pa.pair, b: pb.pair };
        }
      });
    });

    if (!best) continue;

    const [a1, a2] = best.a, [b1, b2] = best.b;
    res.push({ a1, a2, b1, b2 });

    // 같은 팀에서 동일한 두 사람이 다시 팀을 이루는 것만 금지
    usedPair.add([a1.name, a2.name].sort().join('-'));
    usedPair.add([b1.name, b2.name].sort().join('-'));
  }

  return res;
}


/* ---------------- 경기 카드 출력 ---------------- */
function renderMatchCard(teamA, teamB, matchList) {
  let html = `<div class='match-card'><h3>${teamA} VS ${teamB}</h3><table>`;
  html += `<thead><tr><th>경기</th><th>출전 선수</th><th>결과</th></tr></thead><tbody>`;
  matchList.forEach(match => {
    html += `<tr>
      <td>${match.label}</td>
      <td>${match.players}</td>
      <td>${match.result}</td>
    </tr>`;
  });
  html += "</tbody></table></div>";
  document.getElementById("summaryArea").innerHTML += html;
}

/* ---------------- 순위 계산 ---------------- */
function calculateTeamResults() {
  const cards = document.querySelectorAll(".match-card");
  const stats = {};
  const allTeams = new Set();

  cards.forEach(card => {
    const [teamA, teamB] = card.querySelector("h3").innerText.split(" VS ");
    allTeams.add(teamA); allTeams.add(teamB);
  });

  allTeams.forEach(name => stats[name] = { win:0, lose:0, setDiff:0 });

  cards.forEach(card => {
    const [teamA, teamB] = card.querySelector("h3").innerText.split(" VS ");
    const rows = card.querySelectorAll("tbody tr");
    let teamAWin=0, teamBWin=0, teamASet=0, teamBSet=0;

    rows.forEach(row => {
      const result = row.children[2].innerText.trim();
      if (!result.includes(":")) return;
      const [a,b] = result.split(":").map(Number);
      if (a>b) teamAWin++; else if (b>a) teamBWin++;
      teamASet += a; teamBSet += b;
    });

    stats[teamA].win += teamAWin;
    stats[teamA].lose += teamBWin;
    stats[teamA].setDiff += teamASet - teamBSet;

    stats[teamB].win += teamBWin;
    stats[teamB].lose += teamAWin;
    stats[teamB].setDiff += teamBSet - teamASet;
  });

  const sorted = Object.entries(stats).sort((a,b)=>{
    if(b[1].win!==a[1].win) return b[1].win - a[1].win;
    return b[1].setDiff - a[1].setDiff;
  });

  let html = '<h3 style="text-align:center">📊 팀별 경기결과 및 순위표</h3>';
  html += '<div class="scroll-table"><table><thead><tr><th>팀명</th><th>승</th><th>패</th><th>세트득실</th><th>순위</th></tr></thead><tbody>';
  sorted.forEach(([team, stat], idx)=>{
    html += `<tr><td>${team}</td><td>${stat.win}</td><td>${stat.lose}</td><td>${stat.setDiff}</td><td>${idx+1}</td></tr>`;
  });
  html += '</tbody></table></div>';
  document.getElementById("rankingArea").innerHTML = html;
}

/* ---------------- 실시간 Firebase 리스너 ---------------- */
function listenToMatchUpdates() {
  db.ref("matches").on("value", snapshot => {
    const matches = snapshot.val();
    if (!matches) return;
    document.getElementById("summaryArea").innerHTML = "";
    for (const key in matches) {
      const {teamA, teamB, matchList} = matches[key];
      const safeList = Array.isArray(matchList) ? matchList : Object.values(matchList || {});
      renderMatchCard(teamA, teamB, safeList);
    }
    calculateTeamResults();
  });
}

/* ---------------- 이미지 저장 ---------------- */
function saveAsImage() {
  html2canvas(document.getElementById("captureArea")).then(canvas => {
    const link = document.createElement("a");
    link.download = `단체전_대진결과_${new Date().toISOString().slice(0,10)}.png`;
    link.href = canvas.toDataURL();
    link.click();
  });
}
</script>
</body>
</html>
