<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>탁구 단체전 생성기</title>
  <style>
    body { font-family: 'Segoe UI', sans-serif; padding: 20px; background-color: #f0f2f5; }
    h2 { text-align: center; color: #1a237e; }
    .section { margin-bottom: 20px; }
    .section h3 { text-align: center; color: #333; }
    .player-list { text-align: center; display: flex; flex-wrap: wrap; justify-content: center; gap: 0px; }
    .player { margin: 3px; padding: 4px 8px; font-size: 16px; border-radius: 6px; border: 1px solid #ccc; cursor: pointer; background: #ffffff; }
    .player.selected { background-color: #bbdefb; border: 2px solid #1e88e5; }

    /* 부수별 색상 */
    .lv1to6 { background-color: #e8f5e9; }
    .lv7to9 { background-color: #e3f2fd; }
    .lv10to12 { background-color: #fff8e1; }
    .lv13to15 { background-color: #fce4ec; }
    .lv16to20 { background-color: #eeeeee; }

    /* 새로 추가된 선수 강조 */
    .player.new-player {
      background-color: #fff176 !important;
      border: 3px solid #f57f17;
      font-weight: bold;
      box-shadow: 0 0 10px #f9a825;
      animation: highlightFlash 1.5s ease-in-out infinite alternate;
      color: black;
    }
    .player.new-player.selected {
      background-color: #fbc02d !important;
      border-color: #ff6f00;
      box-shadow: 0 0 12px #ffa000;
      color: black !important;
    }
    @keyframes highlightFlash { from { background-color: #fff59d; } to { background-color: #ffe082; } }

    .player.leader { font-weight: bold; background-color: #ffe082; }
    .player.candidate { background-color: #e3f2fd; }
    .player.non-candidate { background-color: #fce4ec; }

    button { padding: 10px 16px; font-size: 16px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; }

    .teams { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 20px; }
    .team-card { background: white; border: 1px solid #ccc; border-radius: 8px; padding: 10px 16px; box-shadow: 2px 2px 8px rgba(0,0,0,0.1); min-width: 180px; }
    .team-card h3 { margin-top: 0; color: #d32f2f; font-size: 18px; }
    .team-card ul { list-style: none; padding: 0; margin: 0; }
    .team-card li { margin: 4px 0; }

    .input-wrap { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
    .input-wrap input { padding: 6px; font-size: 14px; }
    .action-buttons { display: flex; justify-content: center; gap: 10px; margin: 20px 0; flex-wrap: wrap; }

    @media screen and (max-width: 600px) {
      .player { font-size: 14px; padding: 4px 8px; }
      .team-card { min-width: 90%; }
      .input-wrap { flex-direction: column; }
    }

    .scroll-table { overflow-x: auto; border: 1px solid #ccc; border-radius: 8px; margin-top: 20px; }
    .scroll-table table { border-collapse: collapse; width: 100%; min-width: 600px; background-color: white; }
    .scroll-table th, .scroll-table td { border: 1px solid #888; padding: 8px 12px; text-align: center; font-size: 16px; white-space: nowrap; }
    .scroll-table tr:nth-child(odd) td, .scroll-table tr:nth-child(odd) th { background-color: #f1f8ff; }
    .scroll-table tr:nth-child(even) td, .scroll-table tr:nth-child(even) th { background-color: #ffffff; }
    .scroll-table th:first-child, .scroll-table td:first-child { font-weight: bold; background-color: #ffe082 !important; }
    @media screen and (max-width: 600px) {
      .scroll-table th, .scroll-table td { font-size: 14px; padding: 6px 8px; }
    }
    #saveTeamImageButton { padding: 10px 16px; font-size: 16px; background-color: #43a047; color: white; border: none; border-radius: 4px; cursor: pointer; }

    .player-input-pair { display: flex; gap: 8px; align-items: center; }
    .player-input-pair input { padding: 6px; font-size: 14px; }
    #newName { width: 100px; }
    #newLevel { width: 60px; }
    .button-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    .button-group button { padding: 6px 12px; font-size: 14px; }
    .hidden { display: none !important; }
/* 수동배정: 교체 선택 하이라이트 */
.swap-pending { outline: 2px dashed #ff6f00; border-radius: 6px; }

 /* ===== 도움말 버튼 ===== */
    .help-button {
      position: fixed;
      top: 15px;
      right: 15px;
      background: #ffca28;
      color: #000;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transition: background 0.3s;
      z-index: 1001;
    }
    .help-button:hover {
      background: #ffc107;
    }

    /* ===== 모달 배경 ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000; /* 기존보다 높게 (도움말 버튼보다 우선) */
    }

    /* ===== 모달 창 ===== */
    .modal {
      background: #ffffff;
      border-radius: 12px;
      max-width: 420px;
      width: 90%;
      padding: 20px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
      animation: fadeIn 0.3s ease;
      position: relative;

      /* 추가된 부분 */
  max-height: 90vh;          /* 화면 높이의 90%까지만 표시 */
  overflow-y: auto;          /* 내용이 많으면 스크롤 가능 */
  box-sizing: border-box;    /* 패딩 포함 */
    }
    @keyframes fadeIn {
      from {opacity: 0; transform: scale(0.9);}
      to {opacity: 1; transform: scale(1);}
    }

    /* ===== 닫기 버튼 ===== */
    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #e53935;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .close-btn:hover {
      background: #d32f2f;
    }

    /* ===== 도움말 내용 ===== */
    .modal h2 {
      text-align: center;
      color: #1976d2;
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 20px;
    }

    .modal-section {
      margin-bottom: 14px;
    }

    .modal-section h3 {
      font-size: 16px;
      margin-bottom: 6px;
      color: #333;
    }

    .modal-section ul {
      margin: 0;
      padding-left: 18px;
    }

    .modal-section ul li {
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 4px;
    }

    /* 이모지 강조 */
    .emoji {
      font-weight: bold;
      margin-right: 4px;
    }
    



  </style>
</head>
<body>

  <h2>탁구 단체전 생성기</h2>

  <div class="input-wrap">
    <div class="player-input-pair">
      <input type="text" id="newName" placeholder="이름" />
      <input type="number" id="newLevel" placeholder="부수" min="1" max="20" />
    </div>
    <div class="button-group">
      <button onclick="addPlayer()">선수 추가</button>
      <button onclick="removeAddedPlayers()">추가 선수 삭제</button>
    </div>
  </div>


  <div class="section">
    <h3>참석자 목록</h3>
    <div class="player-list" id="playerList"></div>
  </div>

  <div class="action-buttons">
    <button onclick="assignTeams()">팀 자동 배정</button>
    <button onclick="startManualTeamAssign()">팀 수동 배정</button> <!-- ⬅️ 이 줄 추가 -->
    <button onclick="createExchangeMatch()">교류전 생성</button>
    <button onclick="resetAll()">전체 초기화</button>
    <button id="saveTeamImageButton" onclick="saveTeamsAsImage()">팀 이미지 저장</button>
    <button onclick="uploadTeamsToFirebase()" style="background-color:#f57f17;">경기 시작</button>
  </div>

  <div class="teams" id="teams"></div>

  <div class="action-buttons">
    <div id="matchSchedule"></div>
  </div>

  
  <!-- 도움말 버튼 -->
  <button class="help-button" onclick="openModal()">❔</button>

  <!-- 도움말 모달 -->
  <div class="modal-overlay" id="helpModal">
    <div class="modal">
      <button class="close-btn" onclick="closeModal()">✖</button>
      <h2>🏓 사용법 안내</h2>

      <div class="modal-section">
        <h3>1. 기본 사용</h3>
        <ul>
          <li><span class="emoji">➕</span> 이름, 부수 입력 → <b>선수 추가</b></li>
          <li><span class="emoji">⭐</span> 팀장 후보(1~6부) 선택 → <b>팀장 선정 완료</b> (선택 안 해도 됨)</li>
          <li><span class="emoji">👆</span> 참석자 클릭 시 파란색 → 선택</li>
          <li><span class="emoji">🗑️</span> 추가 선수 전체 삭제 가능</li>
        </ul>
      </div>

      <div class="modal-section">
        <h3>2. 팀 배정</h3>
        <ul>
          <li><b>자동 배정</b>  
            <ul>
              <li>- 팀장 O → 각 팀에 1명씩 고정</li>
              <li>- 팀장 X → 팝업에서 팀 수 입력</li>
              <li>- 부수 합 균등, 동일 부수는 무작위 배치</li>
            </ul>
          </li>
          <li><b>수동 배정</b>  
            <ul>
              <li>- 팀 수 입력(최대 8팀)</li>
              <li>- 참가자 버튼 클릭 → 팀에 직접 배정</li>
              <li>- <b>팀 카드</b>: ↔ 교체 / → 이동 / ✖ 해제 / + 선수 추가</li>
            </ul>
          </li>
        </ul>
      </div>

      <div class="modal-section">
        <h3>3. 경기 시작</h3>
        <ul>
          <li><span class="emoji">🚀</span> 팀 확정 후 <b>경기 시작</b> → Firebase 저장 & 경기 진행 화면 이동</li>
        </ul>
      </div>

      <div class="modal-section">
        <h3>4. 기타 기능</h3>
        <ul>
          <li><span class="emoji">🖼️</span> 팀 이미지 저장: PNG로 저장</li>
          <li><span class="emoji">🔄</span> 전체 초기화: 모든 데이터 초기화</li>
          <li><span class="emoji">📱</span> 신규 선수 = 노란색 강조, 모바일 대응</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- 라이브러리 스크립트들: body 닫기 전 로드 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Firebase SDK (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>

    let exchangeSwapBuffer = null; // 교체 기능 임시 저장 버퍼

    // Firebase 설정
    const firebaseConfig = {
      apiKey: "AIzaSyA-tp3iJ8-n0yrrd8lwE1IgOdsmDqyh69k",
      authDomain: "koen-teamleague.firebaseapp.com",
      projectId: "koen-teamleague",
      storageBucket: "koen-teamleague.appspot.com", // 사용 안 해도 무방
      messagingSenderId: "487164547059",
      appId: "1:487164547059:web:658a10c8bfe7272ca78c86",
      databaseURL: "https://koen-teamleague-default-rtdb.firebaseio.com"
    };

    // Firebase 초기화
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // --- 익명 로그인 유틸 ---
    // 페이지 로드 시 자동으로 익명 로그인 시도
    firebase.auth().onAuthStateChanged((user) => {
      if (user) {
        console.log("✅ 익명 로그인됨:", user.uid);
      } else {
        firebase.auth().signInAnonymously()
          .then(() => console.log("✅ 익명 로그인 성공"))
          .catch(err => console.error("❌ 익명 로그인 실패:", err));
      }
    });

    // 필요한 시점에 인증을 보장하는 헬퍼
    async function requireAuth() {
      const current = firebase.auth().currentUser;
      if (current) return current;
      await firebase.auth().signInAnonymously();
      return new Promise((resolve) => {
        const unsub = firebase.auth().onAuthStateChanged(u => {
          if (u) { unsub(); resolve(u); }
        });
      });
    }

    // ------ 앱 상태 ------
    let allPlayers = [
      { name: "노정림", level: 3 }, { name: "김희영", level: 4 }, { name: "강성용", level: 5 }, { name: "김범일", level: 5 },
      { name: "이영진", level: 6 }, { name: "박주민", level: 6 }, { name: "강다훈", level: 6 },
      { name: "박진우", level: 7 }, { name: "배성국", level: 7 }, { name: "이상준", level: 7 },
      { name: "황경진", level: 8 }, { name: "양충현", level: 8 }, { name: "박인찬", level: 8 },
      { name: "임춘근", level: 9 }, { name: "전성무", level: 9 }, { name: "송창근", level: 9 },
      { name: "김승일", level: 9 }, { name: "김현곤", level: 9 }, { name: "문우용", level: 9 },
      { name: "오국환", level: 9 }, { name: "조보미", level: 12 }, { name: "송은아", level: 13 },
      { name: "이낭주", level: 13 }, { name: "박승목", level: 14 }, { name: "박나령", level: 14 },
      { name: "고은선", level: 14 }, { name: "이세란", level: 14 }
    ];

    // 저장된 추가 선수 복원
    const savedAddedPlayers = JSON.parse(localStorage.getItem("addedPlayers") || "[]");
    savedAddedPlayers.forEach(p => allPlayers.push({ ...p, new: true }));

    let selected = [];
    let exchangeTeams = {
  ourTeams: [],
  opponentTeams: [],
  mixedTeams: []
};

// === 팀 색상 팔레트 & 가독성 보정 ===
const TEAM_COLORS = [
  "#1976d2", // 파랑
  "#2e7d32", // 초록
  "#ef6c00", // 주황
  "#6a1b9a", // 보라
  "#c62828", // 빨강
  "#00897b", // 청록
  "#283593", // 인디고
  "#f9a825"  // 노랑
];
    let latestTeams = []; // 업로드용 전역 저장소

    function renderPlayers() {
  const playerList = document.getElementById("playerList");
  playerList.innerHTML = "";

  allPlayers.forEach((p, i) => {
    const el = document.createElement("span");
    el.className = "player";
    el.textContent = `${p.name}(${p.level}부)`;
    el.onclick = () => toggleSelect(i, el);

    if (p.level <= 6) el.classList.add("lv1to6");
    else if (p.level <= 9) el.classList.add("lv7to9");
    else if (p.level <= 12) el.classList.add("lv10to12");
    else if (p.level <= 15) el.classList.add("lv13to15");
    else el.classList.add("lv16to20");

    if (p.new) el.classList.add("new-player");
    if (selected.includes(i)) el.classList.add("selected");  // 🔹 선택 상태 복원

   
    playerList.appendChild(el);
  });
}

function renderExchangeTeams() {
  const teamBox = document.getElementById("teams");
  teamBox.innerHTML = "";

  const renderGroup = (group, title) => {
    if (group.length === 0) return;
    const groupHeader = document.createElement("h3");
    groupHeader.textContent = title;
    teamBox.appendChild(groupHeader);

    group.forEach((team, idx) => {
      const div = document.createElement("div");
      div.className = "team-card";
      div.style.borderTop = `4px solid ${team.color}`;

      // 🔹 버튼 3개로 교체
      div.innerHTML = `
        <h3>${team.name}</h3>
       <ul>
  ${team.members.map((p, i) => `
<li id="ex-${title}-${idx}-p${i}" 
    style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
  <span>${p.name}(${p.level}부)</span>
  <span style="display:flex;gap:6px;">
    <button onclick="beginExchangeSwap('${title}', ${idx}, ${i})" style="font-size:12px;padding:4px 8px;">↔ 교체</button>
    <button onclick="moveExchangePlayer('${title}', ${idx}, ${i})" style="font-size:12px;padding:4px 8px;">→ 이동</button>
    <button onclick="removeExchangePlayer('${title}', ${idx}, ${i})" style="font-size:12px;padding:4px 8px;">✖ 해제</button>
  </span>
</li>
  `).join('')}
</ul>

        <p><small>부수합: ${team.sum}</small></p>
      `;
      teamBox.appendChild(div);
    });
  };

  

  renderGroup(exchangeTeams.ourTeams, "우리팀");
  renderGroup(exchangeTeams.opponentTeams, "상대팀");
  renderGroup(exchangeTeams.mixedTeams, "혼합팀");
  latestTeams = [
  ...exchangeTeams.ourTeams,
  ...exchangeTeams.opponentTeams,
  ...exchangeTeams.mixedTeams
];

}

function removeExchangePlayer(groupType, teamIdx, playerIdx) {
  let group;
  if (groupType === "우리팀") group = exchangeTeams.ourTeams;
  else if (groupType === "상대팀") group = exchangeTeams.opponentTeams;
  else group = exchangeTeams.mixedTeams;

  const player = group[teamIdx].members[playerIdx];
  group[teamIdx].members.splice(playerIdx, 1);
  group[teamIdx].sum -= player.level;

  renderExchangeTeams();
}

// (B) 이동: 한 선수를 다른 팀으로 이동
function moveExchangePlayer(groupType, teamIdx, playerIdx) {
  // 현재 선택된 팀 그룹 가져오기
  const sourceGroup = getExchangeGroup(groupType);
  const player = sourceGroup[teamIdx].members[playerIdx];

  // 모든 팀 목록을 하나로 합치기 (우리팀 + 상대팀 + 혼합팀)
  const allGroups = [
    ...exchangeTeams.ourTeams.map((t, i) => ({ group: "우리팀", teamIdx: i, name: t.name })),
    ...exchangeTeams.opponentTeams.map((t, i) => ({ group: "상대팀", teamIdx: i, name: t.name })),
    ...exchangeTeams.mixedTeams.map((t, i) => ({ group: "혼합팀", teamIdx: i, name: t.name }))
  ];

  // 팀 목록을 prompt에 표시
  const options = allGroups.map((g, i) => `${i}: [${g.group}] ${g.name}`).join("\n");
  const choice = prompt(`'${player.name}' 이동할 팀 선택:\n${options}`);
  if (choice === null) return; // 취소 시 종료

  const selected = allGroups[parseInt(choice, 10)];
  if (!selected) {
    alert("잘못된 선택입니다.");
    return;
  }

  // 동일 팀으로 이동하려는 경우 방지
  if (selected.group === groupType && selected.teamIdx === teamIdx) {
    alert("같은 팀으로 이동할 수 없습니다.");
    return;
  }

  // ---- 이동 처리 ----
  // 기존 팀에서 제거
  sourceGroup[teamIdx].members.splice(playerIdx, 1);
  sourceGroup[teamIdx].sum -= player.level;

  // 새로운 팀으로 추가
  const targetGroup = getExchangeGroup(selected.group);
  targetGroup[selected.teamIdx].members.push(player);
  targetGroup[selected.teamIdx].sum += player.level;

  // 화면 갱신
  renderExchangeTeams();
}


function beginExchangeSwap(groupType, teamIdx, playerIdx) {
  const liId = `ex-${groupType}-${teamIdx}-p${playerIdx}`;
  const li = document.getElementById(liId);

  // 첫 번째 선택
  if (!exchangeSwapBuffer) {
    exchangeSwapBuffer = { groupType, teamIdx, playerIdx, liId };
    if (li) li.classList.add('swap-pending');
    return;
  }

  // 동일한 선수 클릭 → 취소
  if (exchangeSwapBuffer.groupType === groupType &&
      exchangeSwapBuffer.teamIdx === teamIdx &&
      exchangeSwapBuffer.playerIdx === playerIdx) {
    const prevLi = document.getElementById(exchangeSwapBuffer.liId);
    if (prevLi) prevLi.classList.remove('swap-pending');
    exchangeSwapBuffer = null;
    return;
  }

  // 두 번째 선택 → 스왑
  const aTeam = getExchangeGroup(exchangeSwapBuffer.groupType)[exchangeSwapBuffer.teamIdx];
  const bTeam = getExchangeGroup(groupType)[teamIdx];
  const a = aTeam.members[exchangeSwapBuffer.playerIdx];
  const b = bTeam.members[playerIdx];

  // 합계 갱신
  aTeam.sum = aTeam.sum - a.level + b.level;
  bTeam.sum = bTeam.sum - b.level + a.level;

  // 스왑
  aTeam.members[exchangeSwapBuffer.playerIdx] = b;
  bTeam.members[playerIdx] = a;

  renderExchangeTeams();
  exchangeSwapBuffer = null;
}


   function toggleSelect(i, el) {
  if (selected.includes(i)) {
    // 이미 선택되어 있으면 선택 해제
    selected = selected.filter(v => v !== i);
    el.classList.remove("selected");
  } else {
    // 선택되지 않았다면 선택
    selected.push(i);
    el.classList.add("selected");
  }
}

    function shuffle(arr) {
      return arr.map(a => [Math.random(), a]).sort((a, b) => a[0] - b[0]).map(a => a[1]);
    }

    function assignTeams() {
  // 전체 또는 선택 인원 기준으로 팀 구성
  let pool = selected.length ? [...selected] : allPlayers.map((_, i) => i);

  if (pool.length < 2) {
    alert("선수가 2명 이상 있어야 합니다.");
    return;
  }

  const teamCount = parseInt(prompt("몇 팀으로 구성하시겠습니까?"));
  if (isNaN(teamCount) || teamCount < 2 || teamCount > 8) {
    alert("2~8 사이의 숫자를 입력해주세요.");
    return;
  }

  const teams = [];
  for (let i = 0; i < teamCount; i++) {
    teams.push({ name: `${i + 1}팀`, members: [], sum: 0 });
  }

  // 부수 높은 사람부터 순서대로 팀 배치
  const playersSorted = pool
    .map(i => allPlayers[i])
    .sort((a, b) => a.level - b.level);

  playersSorted.forEach(player => {
    teams.sort((a, b) => a.sum - b.sum);
    teams[0].members.push(player);
    teams[0].sum += player.level;
  });

  // 출력
  const teamBox = document.getElementById("teams");
  teamBox.innerHTML = "";
  teams.forEach(team => {
    const sortedMembers = [...team.members].sort((a, b) => a.level - b.level);
    const div = document.createElement("div");
    div.className = "team-card";
    div.innerHTML = `
      <h3>${team.name}</h3>
      <ul>
        ${sortedMembers.map(m => `<li>${m.name}(${m.level}부)</li>`).join('')}
      </ul>
      <p><small>부수합: ${team.sum}</small></p>
    `;
    teamBox.appendChild(div);
  });

  latestTeams = teams;
}


function pickMixedPlayers(ourPlayers, opponentPlayers, mixedCount, totalTeams) {
  const mixedPlayers = [];
  const totalPlayers = ourPlayers.length + opponentPlayers.length;

  // 혼합팀 총 인원 = 혼합팀 수 × 한 팀당 목표 인원
  const playersPerTeam = Math.floor(totalPlayers / totalTeams);
  const totalMixedPlayers = playersPerTeam * mixedCount;

  // 1. 우리팀, 상대팀 각각 부수 오름차순(강자 우선) 정렬
  ourPlayers.sort((a, b) => a.level - b.level);
  opponentPlayers.sort((a, b) => a.level - b.level);

  // 2. 초기에는 우리팀/상대팀 번갈아 뽑기 → 50:50 비율
  const half = Math.floor(totalMixedPlayers / 2);
  for (let i = 0; i < half; i++) {
    if (ourPlayers.length > 0) mixedPlayers.push(ourPlayers.shift()); // 강자 우선
    if (opponentPlayers.length > 0) mixedPlayers.push(opponentPlayers.shift());
  }

  // 3. 혼합팀의 평균 부수 계산
  const getAverageLevel = (arr) => arr.reduce((sum, p) => sum + p.level, 0) / arr.length;
  let avgLevel = getAverageLevel(mixedPlayers);

  // 4. 경기 가능한 범위 확인 (예: 평균 부수 8 이하 유지)
  const MAX_AVG = 8; // 이 값은 경기 상황에 맞게 조정 가능
  if (avgLevel > MAX_AVG) {
    console.log("⚠ 혼합팀 평균 부수가 너무 높음 → 강자 추가 배치 시도");

    // 부족한 강자 보충: 남아있는 강한 선수 중에서 추가
    while (avgLevel > MAX_AVG && (ourPlayers.length > 0 || opponentPlayers.length > 0)) {
      // 양쪽에서 가장 강한 선수 중 하나 선택
      let candidate = null;
      if (ourPlayers.length > 0 && opponentPlayers.length > 0) {
        candidate = (ourPlayers[0].level < opponentPlayers[0].level)
          ? ourPlayers.shift()
          : opponentPlayers.shift();
      } else if (ourPlayers.length > 0) {
        candidate = ourPlayers.shift();
      } else if (opponentPlayers.length > 0) {
        candidate = opponentPlayers.shift();
      }

      if (candidate) {
        mixedPlayers.push(candidate);
        avgLevel = getAverageLevel(mixedPlayers);
      } else {
        break;
      }
    }
  }

  return mixedPlayers;
}



// 그룹 내부에서만 인원 균형 → 부수 균형
function distributePlayers(players, teams) {
  if (!teams || teams.length === 0 || players.length === 0) return;

  // 1. 부수 낮은 선수(실력 높은 선수)부터 배치
  players.sort((a, b) => {
    if (a.level === b.level) return Math.random() - 0.5; 
    return a.level - b.level; // 낮은 부수(강자)가 먼저
  });

  const totalPlayers = players.length;
  const teamCount = teams.length;

  // 2. 팀 목표 인원수 계산 (예: 17명 3팀 → [6, 6, 5])
  const baseSize = Math.floor(totalPlayers / teamCount);
  let remainder = totalPlayers % teamCount;
  const targetSizes = new Array(teamCount).fill(baseSize).map(size => {
    if (remainder > 0) {
      remainder--;
      return size + 1;
    }
    return size;
  });

  // 3. 선수 배치
  players.forEach(player => {
    teams.sort((a, b) => {
      const aIdx = teams.indexOf(a);
      const bIdx = teams.indexOf(b);

      const aCount = a.members.length;
      const bCount = b.members.length;

      const aTarget = targetSizes[aIdx];
      const bTarget = targetSizes[bIdx];

      // ---- 1순위: 목표 인원 미달 팀 우선 ----
      if (aCount < aTarget && bCount >= bTarget) return -1;
      if (bCount < bTarget && aCount >= aTarget) return 1;

      // ---- 2순위: 평균 부수 낮은 팀(강팀) 먼저 배정 ----
      const aAvg = aCount === 0 ? 0 : a.sum / aCount;
      const bAvg = bCount === 0 ? 0 : b.sum / bCount;
      if (aAvg !== bAvg) return aAvg - bAvg;

      // ---- 3순위: 인원이 적은 팀 우선 ----
      if (aCount !== bCount) return aCount - bCount;

      // ---- 4순위: 마지막으로 부수 합이 낮은 팀 ----
      return a.sum - b.sum;
    });

    // 최종 선택된 팀에 선수 추가
    teams[0].members.push(player);
    teams[0].sum += player.level;
  });
}



function createExchangeMatch() {
  const ourCount = parseInt(prompt("우리팀 몇 팀으로 구성할까요?"), 10);
  const opponentCount = parseInt(prompt("상대팀 몇 팀으로 구성할까요?"), 10);
  const mixedCount = parseInt(prompt("혼합팀 몇 팀으로 구성할까요? (없으면 0 입력)"), 10) || 0;

  if (isNaN(ourCount) || isNaN(opponentCount)) {
    alert("⚠️ 숫자를 정확히 입력해주세요.");
    return;
  }

  // === 팀 초기화 ===
  exchangeTeams = { ourTeams: [], opponentTeams: [], mixedTeams: [] };
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

  const createTeams = (count, prefix, startColorIdx = 0) =>
    Array.from({ length: count }, (_, i) => ({
      name: `${prefix} ${alphabet[i]}`,
      members: [],
      sum: 0,
      color: TEAM_COLORS[(i + startColorIdx) % TEAM_COLORS.length]
    }));

  exchangeTeams.ourTeams = createTeams(ourCount, "우리팀", 0);
  exchangeTeams.opponentTeams = createTeams(opponentCount, "상대팀", ourCount);
  exchangeTeams.mixedTeams = createTeams(mixedCount, "혼합팀", ourCount + opponentCount);

  // === 선수 분류 ===
  const selectedPlayers = selected.length ? selected.map(idx => allPlayers[idx]) : [...allPlayers];
  const ourPlayers = selectedPlayers.filter(p => !p.new);     // 기존 선수 = 우리팀
  const opponentPlayers = selectedPlayers.filter(p => p.new); // 신규 선수 = 상대팀

  /* ---------- 1) 혼합팀 인원 추출 ---------- */
  const totalTeams = ourCount + opponentCount + mixedCount;
  const mixedPlayers = mixedCount > 0
    ? pickMixedPlayers(ourPlayers, opponentPlayers, mixedCount, totalTeams)
    : [];

  // 혼합팀 인원은 우리팀/상대팀에서 제거
  mixedPlayers.forEach(mixed => {
    const ourIdx = ourPlayers.findIndex(p => p.name === mixed.name && p.level === mixed.level);
    if (ourIdx !== -1) ourPlayers.splice(ourIdx, 1);

    const oppIdx = opponentPlayers.findIndex(p => p.name === mixed.name && p.level === mixed.level);
    if (oppIdx !== -1) opponentPlayers.splice(oppIdx, 1);
  });

  /* ---------- 2) 각 그룹별 독립 배치 ---------- */
  distributePlayers(mixedPlayers, exchangeTeams.mixedTeams);        // 혼합팀
  distributePlayers(ourPlayers, exchangeTeams.ourTeams);            // 우리팀
  distributePlayers(opponentPlayers, exchangeTeams.opponentTeams);  // 상대팀

  renderExchangeTeams(); // 결과 화면 출력

  balanceFinalMixedTeams(exchangeTeams);
renderExchangeTeams(); // 조정된 결과 다시 출력

}






    function saveTeamsAsImage() {
      const teamsArea = document.getElementById("teams");
      if (!teamsArea || teamsArea.innerHTML.trim() === "") {
        alert("팀이 먼저 생성되어야 저장할 수 있습니다.");
        return;
      }
      html2canvas(teamsArea).then(canvas => {
        const link = document.createElement("a");
        link.download = "탁구_팀_구성.png";
        link.href = canvas.toDataURL();
        link.click();
      });
    }

    function addPlayer() {
      const nameInput = document.getElementById("newName");
      const levelInput = document.getElementById("newLevel");

      const name = nameInput.value.trim();
      const level = parseInt(levelInput.value, 10);

      if (!name || isNaN(level) || level < 1 || level > 20) {
        alert("이름과 부수를 올바르게 입력해주세요. (부수는 1~20)");
        return;
      }

      const newPlayer = { name, level, new: true };
      allPlayers.push(newPlayer);

      const stored = JSON.parse(localStorage.getItem("addedPlayers") || "[]");
      stored.push(newPlayer);
      localStorage.setItem("addedPlayers", JSON.stringify(stored));

      nameInput.value = "";
      levelInput.value = "";
      renderPlayers();
    }

    async function uploadTeamsToFirebase() {
  if (!latestTeams || latestTeams.length === 0) {
    alert("⚠️ 팀이 먼저 생성되어야 업로드할 수 있습니다.");
    return;
  }

  // 인증 보장
  await requireAuth();

  const firebaseData = {};
  latestTeams.forEach((team, idx) => {
    const isAuto = team.leader && typeof team.leader.level === "number";
    const teamName = team.teamName
      ? team.teamName
      : (isAuto ? `${team.leader.name} 팀` : `팀${idx + 1}`);
    const teamLeader = isAuto ? team.leader.name : (team.teamLeader || "");

    // ✅ 부수 낮은 순(강자 우선)으로 정렬
    const players = isAuto
      ? [team.leader, ...team.members].sort((a, b) => a.level - b.level)
      : [...team.members].sort((a, b) => a.level - b.level);

    firebaseData[`team${idx + 1}`] = {
      teamName,
      teamLeader,
      players
    };
  });

  db.ref("teams").set(firebaseData)
    .then(() => {
      setTimeout(() => {
        window.location.href = "https://sensational-tulumba-65e97e.netlify.app/pingpong/club/team-match-run/";
      }, 500);
    })
    .catch((err) => {
      console.error("❌ 업로드 실패:", err);
      alert("❌ Firebase 업로드에 실패했습니다.\n콘솔 오류를 확인해주세요.");
    });
}


    function removeAddedPlayers() {
      if (!confirm("추가한 선수들을 모두 삭제하시겠습니까?")) return;
      allPlayers = allPlayers.filter(p => !p.new);
      localStorage.removeItem("addedPlayers");
      renderPlayers();
    }

    // 최초 렌더
    renderPlayers();

    // ✅ 수동 팀 구성 상태
let manualTeams = [];
let manualAssigned = new Set(); // 중복 배정 방지
let manualPool = [];      // 수동배정 풀(미배정/참가자 목록) 인덱스 보관
let swapBuffer = null;    // { teamIdx, playerIdx } 형태로 1차 선택 저장



// 배경색에 맞춰 글자색(검/흰) 결정
function contrastText(hex) {
  const c = hex.replace("#",""); 
  const r = parseInt(c.substr(0,2),16);
  const g = parseInt(c.substr(2,2),16);
  const b = parseInt(c.substr(4,2),16);
  // YIQ 대비
  const yiq = (r*299 + g*587 + b*114)/1000;
  return yiq >= 128 ? "#000000" : "#ffffff";
}

// ✅ 수동 배정 시작 (팀장 선정 불필요)
function startManualTeamAssign() {
  // 참석자 선택이 있으면 그 집합으로, 없으면 전체 인원으로
  manualPool = selected.length ? [...selected] : allPlayers.map((_, i) => i);

  if (manualPool.length < 2) {
    alert("선수가 2명 이상 있어야 합니다. (참석자 선택이 없으면 전체 명단을 사용합니다)");
    return;
  }

  const count = parseInt(prompt("몇 팀으로 구성하시겠습니까? (예: 4)"));
  if (isNaN(count) || count < 2 || count > 8) {
    alert("2~8 사이의 숫자를 입력해주세요.");
    return;
  }

  // 팀명 A팀, B팀...
  const names = [];
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let i = 0; i < count; i++) names.push(`${alphabet[i]}팀`);

  // 상태 초기화
  manualTeams = names.map((n, i) => ({
    name: n,
    members: [],
    sum: 0,
    color: TEAM_COLORS[i % TEAM_COLORS.length]
  }));
  manualAssigned.clear();
  swapBuffer = null;

  enterManualAssignMode();
  renderManualTeamUI(); // ← manualPool을 내부에서 참조
}



function resetAll() {
  exitManualAssignMode(); // ⬅️ 추가

  selected = [];
  document.getElementById("teams").innerHTML = "";
  document.getElementById("matchSchedule").innerHTML = "";
  renderPlayers();
}

// ✅ 수동 배정 UI 렌더링
function renderManualTeamUI() {
  const teamBox = document.getElementById("teams");
  teamBox.innerHTML = "";

  // 팀 카드
  manualTeams.forEach((team, teamIdx) => {
    const div = document.createElement("div");
    div.className = "team-card";
    div.id = `team-${teamIdx}`;
    div.style.borderTop = `4px solid ${team.color || '#1976d2'}`;
    const fg = contrastText(team.color || '#1976d2');
    div.innerHTML = `
      <h3 style="display:flex;align-items:center;gap:8px;justify-content:space-between;">
        <span style="display:flex;align-items:center;gap:8px;">
          <span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:${team.color || '#1976d2'}"></span>
          ${team.name}
        </span>
        <button onclick="promptAddPlayerToTeam(${teamIdx})"
                style="font-size:12px;padding:6px 10px;background:${team.color || '#1976d2'};color:${fg};border:1px solid rgba(0,0,0,.15);border-radius:6px;cursor:pointer">
          + 팀에 선수 추가
        </button>
      </h3>
      <ul id="team-list-${teamIdx}"></ul>
      <p><small>부수합: <span id="team-sum-${teamIdx}">0</span></small></p>
    `;
    teamBox.appendChild(div);

    // 팀원 목록 초기 렌더
    renderTeamMembers(teamIdx);
  });

  // 참가자 목록 영역을 "수동배정 모드"로 전환
  const list = document.getElementById("playerList");
  list.innerHTML = "";

  manualPool.forEach((idx) => {
    const p = allPlayers[idx];
    if (manualAssigned.has(idx)) return; // 이미 배정된 사람은 숨김

    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.alignItems = "center";
    wrapper.style.gap = "8px";
    wrapper.style.margin = "4px 6px";

    const tag = document.createElement("div");
    tag.className = "player";
    tag.textContent = `${p.name}(${p.level}부)`;

    const btns = document.createElement("div");
    manualTeams.forEach((team, i) => {
      const btn = document.createElement("button");
      const bg = team.color || TEAM_COLORS[i % TEAM_COLORS.length];
      btn.textContent = `→ ${team.name}`;
      btn.style.fontSize = "12px";
      btn.style.backgroundColor = bg;
      btn.style.color = contrastText(bg);
      btn.style.border = "1px solid rgba(0,0,0,0.15)";
      btn.style.padding = "6px 10px";
      btn.style.borderRadius = "6px";
      btn.style.cursor = "pointer";
      btn.onclick = () => {
        if (manualAssigned.has(idx)) return;
        manualTeams[i].members.push({ name: p.name, level: p.level, _srcIdx: idx });
        manualTeams[i].sum += p.level;
        manualAssigned.add(idx);
        renderTeamMembers(i);
        wrapper.style.opacity = "0.4";
        wrapper.style.pointerEvents = "none";
      };
      btns.appendChild(btn);
    });

    wrapper.appendChild(tag);
    wrapper.appendChild(btns);
    list.appendChild(wrapper);
  });

  // 저장/업로드 버튼
  const controls = document.createElement("div");
  controls.style.display = "flex";
  controls.style.gap = "10px";
  controls.style.justifyContent = "center";
  controls.style.marginTop = "10px";

  const saveBtn = document.createElement("button");
  saveBtn.textContent = "✅ 수동 팀 저장";
  saveBtn.onclick = () => {
    latestTeams = manualTeams.map(t => ({
      teamName: t.name,
      members: t.members.map(m => ({ name: m.name, level: m.level })),
      sum: t.sum,
      color: t.color
    }));
    alert("저장 완료! 이제 '경기 시작'을 누르면 저장된 팀으로 진행됩니다.");
  };

  const uploadBtn = document.createElement("button");
  uploadBtn.textContent = "⚡ 저장 후 즉시 경기 시작";
  uploadBtn.onclick = () => {
    latestTeams = manualTeams.map(t => ({
      teamName: t.name,
      members: t.members.map(m => ({ name: m.name, level: m.level })),
      sum: t.sum,
      color: t.color
    }));
    uploadTeamsToFirebase();
  };

  const addAnyBtn = document.createElement("button");
  addAnyBtn.textContent = "➕ (신규) 선수 직접 추가";
  addAnyBtn.onclick = () => promptAddPlayer();

  controls.appendChild(saveBtn);
  controls.appendChild(uploadBtn);
  controls.appendChild(addAnyBtn);
  teamBox.appendChild(controls);
}


// ✅ 팀 카드 내용 갱신
function renderTeamMembers(teamIdx) {
  const ul = document.getElementById(`team-list-${teamIdx}`);
  ul.innerHTML = manualTeams[teamIdx].members
    .map((p, idx) => {
      return `
        <li id="t${teamIdx}-p${idx}" style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
          <span>${p.name}(${p.level}부)</span>
          <span style="display:flex;gap:6px;">
            <button onclick="beginSwap(${teamIdx}, ${idx})" style="font-size:12px;padding:4px 8px;">↔ 교체</button>
            <button onclick="movePlayer(${teamIdx}, ${idx})" style="font-size:12px;padding:4px 8px;">→ 이동</button>
            <button onclick="removePlayerFromTeam(${teamIdx}, ${idx})" style="font-size:12px;padding:4px 8px;">✖ 해제</button>
          </span>
        </li>
      `;
    }).join('');
  document.getElementById(`team-sum-${teamIdx}`).textContent = manualTeams[teamIdx].sum;
}


function enterManualAssignMode() {
  const inputWrap = document.querySelector('.input-wrap');
  if (inputWrap) inputWrap.classList.add('hidden');
}

function exitManualAssignMode() {
  const inputWrap = document.querySelector('.input-wrap');
  if (inputWrap) inputWrap.classList.remove('hidden');
}


// (A) 교체: 첫 선수 선택 → 두 번째 선수 선택 시 서로 스왑
function beginSwap(teamIdx, playerIdx) {
  // 같은 li DOM 얻기
  const liId = `t${teamIdx}-p${playerIdx}`;
  const li = document.getElementById(liId);

  if (!swapBuffer) {
    swapBuffer = { teamIdx, playerIdx, liId };
    if (li) li.classList.add('swap-pending');
    return;
  }

  // 동일 항목이면 취소
  if (swapBuffer.teamIdx === teamIdx && swapBuffer.playerIdx === playerIdx) {
    const prevLi = document.getElementById(swapBuffer.liId);
    if (prevLi) prevLi.classList.remove('swap-pending');
    swapBuffer = null;
    return;
  }

  // 두 번째 선택 → 스왑
  const aTeam = manualTeams[swapBuffer.teamIdx];
  const bTeam = manualTeams[teamIdx];
  const a = aTeam.members[swapBuffer.playerIdx];
  const b = bTeam.members[playerIdx];

  // 합계 수정
  aTeam.sum = aTeam.sum - a.level + b.level;
  bTeam.sum = bTeam.sum - b.level + a.level;

  // 실제 스왑
  aTeam.members[swapBuffer.playerIdx] = b;
  bTeam.members[playerIdx] = a;

  // UI 갱신
  renderTeamMembers(swapBuffer.teamIdx);
  renderTeamMembers(teamIdx);

  // 선택 초기화
  const prevLi = document.getElementById(swapBuffer.liId);
  if (prevLi) prevLi.classList.remove('swap-pending');
  swapBuffer = null;
}

// (B) 이동: 한 선수를 다른 팀으로 이동
function movePlayer(fromTeamIdx, playerIdx, toTeamIdx = null) {
  const player = manualTeams[fromTeamIdx].members[playerIdx];

  if (toTeamIdx === null) {
    const teamNames = manualTeams.map((t, i) => `${i}: ${t.name}`).join("\n");
    const input = prompt(`'${player.name}' 이동할 팀 번호를 입력하세요:\n${teamNames}`);
    if (input === null) return;
    toTeamIdx = parseInt(input, 10);
  }

  if (isNaN(toTeamIdx) || toTeamIdx < 0 || toTeamIdx >= manualTeams.length) {
    alert("잘못된 팀 번호입니다.");
    return;
  }
  if (toTeamIdx === fromTeamIdx) {
    alert("같은 팀으로는 이동할 수 없습니다.");
    return;
  }

  // 합계/배열 갱신
  manualTeams[fromTeamIdx].members.splice(playerIdx, 1);
  manualTeams[fromTeamIdx].sum -= player.level;

  manualTeams[toTeamIdx].members.push(player);
  manualTeams[toTeamIdx].sum += player.level;

  renderTeamMembers(fromTeamIdx);
  renderTeamMembers(toTeamIdx);

  // 스왑중 표시 초기화
  if (swapBuffer) {
    const prevLi = document.getElementById(swapBuffer.liId);
    if (prevLi) prevLi.classList.remove('swap-pending');
    swapBuffer = null;
  }
}

// (C) 해제: 팀에서 빼서 ‘미배정’ 상태로 복귀
function removePlayerFromTeam(teamIdx, playerIdx) {
  const player = manualTeams[teamIdx].members[playerIdx];

  // 합계/배열 갱신
  manualTeams[teamIdx].members.splice(playerIdx, 1);
  manualTeams[teamIdx].sum -= player.level;
  renderTeamMembers(teamIdx);

  // 참가자 풀에서의 인덱스 추정: 최초 배정 때 저장한 _srcIdx가 있으면 그걸 복귀
  // (신규 추가한 선수라면 _srcIdx가 없으므로 풀에는 안 돌아가고, 화면 유지)
  if (typeof player._srcIdx === 'number') {
    manualAssigned.delete(player._srcIdx);
  }

  // 참가자 목록 재렌더
  renderManualTeamUI();
}

// (D) 팀에 신규 선수 추가 (즉석 입력)
function promptAddPlayerToTeam(teamIdx) {
  const name = prompt("새 선수 이름:");
  if (!name) return;

  const level = parseInt(prompt("새 선수 부수 (1~20):"), 10);
  if (isNaN(level) || level < 1 || level > 20) {
    alert("부수는 1~20 사이 숫자로 입력해주세요.");
    return;
  }

  addPlayerToTeam(teamIdx, name.trim(), level);
}

// (E) 전역 ‘신규 선수 추가’ 버튼 (팀 먼저 고르고 입력)
function promptAddPlayer() {
  const teamNames = manualTeams.map((t, i) => `${i}: ${t.name}`).join("\n");
  const input = prompt(`선수를 추가할 팀 번호를 선택하세요:\n${teamNames}`);
  if (input === null) return;
  const teamIdx = parseInt(input, 10);
  if (isNaN(teamIdx) || teamIdx < 0 || teamIdx >= manualTeams.length) {
    alert("잘못된 팀 번호입니다.");
    return;
  }
  promptAddPlayerToTeam(teamIdx);
}

// (F) 실제 추가 로직
function addPlayerToTeam(teamIdx, name, level) {
  manualTeams[teamIdx].members.push({ name, level });
  manualTeams[teamIdx].sum += level;
  renderTeamMembers(teamIdx);
}

  // 모달 열기
    function openModal() {
      document.getElementById('helpModal').style.display = 'flex';
    }

    // 모달 닫기
    function closeModal() {
      document.getElementById('helpModal').style.display = 'none';
    }

    // ESC 키로 모달 닫기
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') closeModal();
    });

    // 모달 바깥 클릭 시 닫기
    document.getElementById('helpModal').addEventListener('click', function(e) {
      if (e.target === this) closeModal();
    });

 function getExchangeGroup(groupType) {
  if (groupType === "우리팀") return exchangeTeams.ourTeams;
  if (groupType === "상대팀") return exchangeTeams.opponentTeams;
  return exchangeTeams.mixedTeams;
}

function balanceFinalMixedTeams(exchangeTeams) {
  const allGroups = [exchangeTeams.ourTeams, exchangeTeams.opponentTeams, exchangeTeams.mixedTeams];

  // 합계 계산 함수
  const calcSum = (teams) => teams.reduce((sum, t) => sum + t.sum, 0);
  const calcCount = (teams) => teams.reduce((cnt, t) => cnt + t.members.length, 0);
  const calcAvg = (teams) => (calcCount(teams) > 0 ? calcSum(teams) / calcCount(teams) : 0);

  const avgOur = calcAvg(exchangeTeams.ourTeams);
  const avgOpponent = calcAvg(exchangeTeams.opponentTeams);
  let avgMixed = calcAvg(exchangeTeams.mixedTeams);

  console.log("초기 평균 부수", { avgOur, avgOpponent, avgMixed });

  // 허용 편차: 우리팀/상대팀 평균과 혼합팀 평균의 차이가 이 값 이하면 OK
  const TOLERANCE = 1.5;

  // 조정 반복
  let attempts = 0;
  while ((Math.abs(avgMixed - avgOur) > TOLERANCE || Math.abs(avgMixed - avgOpponent) > TOLERANCE) && attempts < 20) {
    attempts++;

    // 혼합팀에서 가장 부수가 높은 선수와,
    // 우리팀 또는 상대팀에서 가장 부수가 낮은 선수 교체
    const mixedTeam = exchangeTeams.mixedTeams.flatMap(t => t.members);
    const ourTeam = exchangeTeams.ourTeams.flatMap(t => t.members);
    const opponentTeam = exchangeTeams.opponentTeams.flatMap(t => t.members);

    const highestMixed = mixedTeam.reduce((max, p) => (p.level > max.level ? p : max), mixedTeam[0]);
    const lowestOur = ourTeam.reduce((min, p) => (p.level < min.level ? p : min), ourTeam[0]);
    const lowestOpponent = opponentTeam.reduce((min, p) => (p.level < min.level ? p : min), opponentTeam[0]);

    // 혼합팀 평균이 너무 높으면 → 강한 선수 넣기
    if (avgMixed > Math.max(avgOur, avgOpponent) + TOLERANCE) {
      if (lowestOur && lowestOur.level < highestMixed.level) {
        swapPlayers(highestMixed, lowestOur, exchangeTeams);
      } else if (lowestOpponent && lowestOpponent.level < highestMixed.level) {
        swapPlayers(highestMixed, lowestOpponent, exchangeTeams);
      }
    }
    // 혼합팀 평균이 너무 낮으면 → 약한 선수 넣기
    else if (avgMixed < Math.min(avgOur, avgOpponent) - TOLERANCE) {
      const weakestMixed = mixedTeam.reduce((min, p) => (p.level < min.level ? p : min), mixedTeam[0]);
      const highestOur = ourTeam.reduce((max, p) => (p.level > max.level ? p : max), ourTeam[0]);
      const highestOpponent = opponentTeam.reduce((max, p) => (p.level > max.level ? p : max), opponentTeam[0]);

      if (highestOur && highestOur.level > weakestMixed.level) {
        swapPlayers(weakestMixed, highestOur, exchangeTeams);
      } else if (highestOpponent && highestOpponent.level > weakestMixed.level) {
        swapPlayers(weakestMixed, highestOpponent, exchangeTeams);
      }
    }

    // 평균 다시 계산
    avgMixed = calcAvg(exchangeTeams.mixedTeams);
  }

  console.log("조정 후 평균 부수", { avgOur, avgOpponent, avgMixed });
}

function swapPlayers(mixedPlayer, otherPlayer, exchangeTeams) {
  // 어떤 팀에 속해있는지 찾기
  function findPlayerTeam(player) {
    for (const groupName of ['ourTeams', 'opponentTeams', 'mixedTeams']) {
      for (const team of exchangeTeams[groupName]) {
        const idx = team.members.indexOf(player);
        if (idx !== -1) return { groupName, team, idx };
      }
    }
    return null;
  }

  const mixedInfo = findPlayerTeam(mixedPlayer);
  const otherInfo = findPlayerTeam(otherPlayer);

  if (!mixedInfo || !otherInfo) return;

  // 교환
  mixedInfo.team.members[mixedInfo.idx] = otherPlayer;
  otherInfo.team.members[otherInfo.idx] = mixedPlayer;

  // 부수합 갱신
  mixedInfo.team.sum = mixedInfo.team.members.reduce((sum, p) => sum + p.level, 0);
  otherInfo.team.sum = otherInfo.team.members.reduce((sum, p) => sum + p.level, 0);

  console.log(`교환됨: ${mixedPlayer.name} ↔ ${otherPlayer.name}`);
}


  </script>
</body>
</html>
