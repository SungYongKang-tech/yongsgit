<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>월간 일정 캘린더</title>
  <style>
    :root{
      --bg:#f3f5f8;
      --card:#ffffff;
      --bd:#e5e8ef;
      --txt:#1f2430;
      --mut:#6b7280;
      --accent:#2563eb;
      --danger:#dc2626;
      --sat:#2563eb;
      --sun:#dc2626;
      --shadow: 0 10px 24px rgba(0,0,0,.06);
      --radius:14px;

      /* 멀티바 레인 */
      --laneH: 22px;
      --laneGap: 4px;
      --lanes: 3;
    }

    *{box-sizing:border-box}
    html,body{margin:0; background:var(--bg); color:var(--txt); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;}
    button, input, select{font:inherit}
    a{color:inherit; text-decoration:none}

    .wrap{max-width:900px; margin:0 auto; padding:12px;}
    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(243,245,248,.92);
      backdrop-filter: blur(10px);
      padding:10px 0;
    }
    .toprow{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .title{
      font-weight:800; letter-spacing:-.3px;
      font-size:18px;
    }
    .actions{display:flex; gap:8px; align-items:center;}
    .btn{
      border:1px solid var(--bd);
      background:var(--card);
      border-radius:12px;
      padding:9px 12px;
      box-shadow: 0 1px 0 rgba(0,0,0,.02);
      cursor:pointer;
      color:var(--txt);
      font-weight:650;
      line-height:1;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active{transform:translateY(1px)}
    .btn.primary{border-color: rgba(37,99,235,.25); color:var(--accent)}
    .btn.icon{width:40px; padding:9px 0; text-align:center}

    .hint{
      margin-top:8px;
      color:var(--mut);
      font-size:12px;
      display:flex; gap:8px; align-items:center;
    }
    .chip{
      display:inline-flex; gap:6px; align-items:center;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--bd); background:rgba(255,255,255,.7);
    }

    /* Calendar */
    .calCard{
      margin-top:10px;
      background:var(--card);
      border:1px solid var(--bd);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      touch-action: pan-y; /* allow vertical scroll, we handle horizontal */
    }
    .dow{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      border-bottom:1px solid var(--bd);
      background: #fbfcfe;
    }
    .dow div{
      padding:10px 0;
      text-align:center;
      font-weight:800;
      font-size:12px;
      color:var(--mut);
      letter-spacing:-.2px;
    }
    .dow .sun{color:var(--sun)}
    .dow .sat{color:var(--sat)}

    .grid{
      display:flex;
      flex-direction:column;
    }

    .week{
      position:relative;
      border-bottom:1px solid var(--bd);
    }
    .week:last-child{border-bottom:none}

    .days{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      min-height: 118px;
    }
    .day{
      border-right:1px solid var(--bd);
      padding:8px 8px 6px;
      position:relative;
      background: var(--card);
    }
    .day:last-child{border-right:none}
    .day.out{
      background: #fafbfe;
      color: rgba(31,36,48,.45);
    }
    .day .dnum{
      font-weight:900;
      font-size:13px;
      letter-spacing:-.2px;
      width:max-content;
      padding:2px 0;
    }
    .day.sun .dnum{color:var(--sun)}
    .day.sat .dnum{color:var(--sat)}
    .day.today{
      outline: 2px solid rgba(37,99,235,.25);
      outline-offset:-2px;
      background: linear-gradient(180deg, rgba(37,99,235,.06), rgba(255,255,255,0));
    }

    .holidayTag{
      margin-top:4px;
      display:inline-block;
      font-size:11px;
      font-weight:800;
      color: var(--danger);
      border:1px solid rgba(220,38,38,.18);
      background: rgba(220,38,38,.06);
      padding:3px 8px;
      border-radius:999px;
    }

    /* space reserved for bars */
    .barSpace{
      height: calc((var(--laneH) * var(--lanes)) + (var(--laneGap) * (var(--lanes) - 1)) + 10px);
      margin-top:6px;
    }

    .more{
      position:absolute;
      left:8px;
      right:8px;
      bottom:6px;
      display:flex;
      justify-content:flex-start;
    }
    .moreBtn{
      border:none;
      background: rgba(17,24,39,.06);
      color: rgba(17,24,39,.8);
      font-weight:800;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      cursor:pointer;
    }
    .moreBtn:active{transform:translateY(1px)}

    /* Bars overlay */
    .bars{
      position:absolute;
      left:0; right:0;
      top:34px; /* below date row */
      padding:0 6px;
      pointer-events:none; /* bars won't block day tap */
    }
    .bar{
      position:absolute;
      height: var(--laneH);
      border-radius: 10px;
      border:1px solid rgba(37,99,235,.18);
      background: rgba(37,99,235,.12);
      display:flex;
      align-items:center;
      padding:0 8px;
      overflow:hidden;
      pointer-events:none;
    }
    .bar .t{
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      color: rgba(31,36,48,.92);
      max-width:100%;
      letter-spacing:-.2px;
    }
    .bar .time{
      font-size:11px;
      font-weight:800;
      margin-left:6px;
      color: rgba(31,36,48,.60);
      flex:0 0 auto;
    }

    /* subtle animation */
    .fadeIn{animation:fadeIn .14s ease-out}
    @keyframes fadeIn{from{opacity:.45}to{opacity:1}}

    /* Modal */
    .backdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.42);
      display:none;
      align-items:flex-end;
      justify-content:center;
      z-index:100;
    }
    .backdrop.show{display:flex}
    .sheet{
      width:100%;
      max-width:900px;
      background:var(--card);
      border-top-left-radius:18px;
      border-top-right-radius:18px;
      border:1px solid var(--bd);
      box-shadow: 0 -18px 50px rgba(0,0,0,.22);
      max-height: 86vh;
      overflow:auto;
    }
    .sheetHead{
      position:sticky; top:0;
      background:rgba(255,255,255,.95);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--bd);
      padding:12px 12px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .sheetTitle{
      font-weight:950;
      letter-spacing:-.3px;
      font-size:16px;
    }
    .sheetSub{
      font-size:12px; color:var(--mut); margin-top:2px;
    }
    .sheetBody{padding:12px}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .section{
      border:1px solid var(--bd);
      border-radius:14px;
      padding:12px;
      background:#fbfcfe;
      margin-bottom:10px;
    }
    .section h3{
      margin:0 0 8px;
      font-size:13px; letter-spacing:-.2px;
    }
    .list{
      display:flex; flex-direction:column; gap:8px;
    }
    .item{
      border:1px solid var(--bd);
      border-radius:14px;
      padding:10px 10px;
      background: var(--card);
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
    }
    .item .meta{min-width:0}
    .item .name{
      font-weight:900;
      letter-spacing:-.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .item .desc{
      margin-top:3px;
      color:var(--mut);
      font-size:12px;
      line-height:1.25;
    }
    .item .btns{display:flex; gap:6px; flex:0 0 auto;}
    .mini{
      border:1px solid var(--bd);
      background:#fff;
      border-radius:12px;
      padding:7px 10px;
      font-weight:850;
      font-size:12px;
      cursor:pointer;
    }
    .mini.danger{border-color: rgba(220,38,38,.28); color:var(--danger); background: rgba(220,38,38,.04);}
    .mini.primary{border-color: rgba(37,99,235,.25); color:var(--accent); background: rgba(37,99,235,.04);}

    .formGrid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .field{display:flex; flex-direction:column; gap:6px;}
    label{font-size:12px; color:var(--mut); font-weight:800}
    input, select{
      border:1px solid var(--bd);
      border-radius:12px;
      padding:10px 10px;
      background:#fff;
      outline:none;
    }
    input:focus, select:focus{
      border-color: rgba(37,99,235,.45);
      box-shadow: 0 0 0 3px rgba(37,99,235,.12);
    }
    .full{grid-column:1/-1}

    .hr{height:1px; background:var(--bd); margin:10px 0;}
    .note{color:var(--mut); font-size:12px; line-height:1.35}

    /* admin */
    .adminList{
      display:flex; flex-direction:column; gap:8px;
    }
    .pill{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid var(--bd);
      border-radius:999px;
      background:#fff;
      padding:8px 10px;
      font-size:12px;
      font-weight:800;
    }
    .pill .date{color:rgba(31,36,48,.92)}
    .pill .x{
      border:none; cursor:pointer;
      background: rgba(220,38,38,.10);
      color: var(--danger);
      border-radius:999px;
      padding:6px 10px;
      font-weight:950;
    }

    @media (min-width: 720px){
      .days{min-height:132px}
      .wrap{padding:16px}
      .title{font-size:20px}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="wrap">
      <div class="toprow">
        <div>
          <div class="title" id="monthTitle">YYYY년 M월</div>
          <div class="hint">
            <span class="chip">좌/우 스와이프로 월 이동</span>
            <span class="chip">일정 입력: 날짜 탭</span>
          </div>
        </div>
        <div class="actions">
          <button class="btn primary" id="todayBtn" aria-label="오늘로 이동">오늘</button>
          <button class="btn icon" id="adminBtn" aria-label="관리자(휴일 설정)">⚙️</button>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="calCard" id="calCard" aria-label="월간 캘린더">
      <div class="dow">
        <div class="sun">일</div><div>월</div><div>화</div><div>수</div><div>목</div><div>금</div><div class="sat">토</div>
      </div>
      <div class="grid fadeIn" id="grid"></div>
    </div>
  </div>

  <!-- Day Modal -->
  <div class="backdrop" id="dayModalBack" role="dialog" aria-modal="true" aria-label="일정 상세">
    <div class="sheet">
      <div class="sheetHead">
        <div>
          <div class="sheetTitle" id="dayModalTitle">YYYY-MM-DD</div>
          <div class="sheetSub" id="dayModalSub">이 날짜에 포함되는 일정</div>
        </div>
        <div class="row">
          <button class="btn" id="dayModalClose" aria-label="닫기">닫기</button>
        </div>
      </div>
      <div class="sheetBody">
        <div class="section">
          <div class="row" style="justify-content:space-between">
            <h3 style="margin:0">일정 목록</h3>
            <button class="mini primary" id="showAddBtn">+ 일정 추가</button>
          </div>
          <div class="list" id="eventList"></div>
          <div class="note" id="emptyNote" style="display:none; margin-top:8px;">표시할 일정이 없습니다.</div>
        </div>

        <div class="section" id="formSection" style="display:none;">
          <div class="row" style="justify-content:space-between">
            <h3 style="margin:0" id="formTitle">일정 추가</h3>
            <button class="mini" id="cancelFormBtn">취소</button>
          </div>

          <div class="hr"></div>

          <form id="eventForm">
            <input type="hidden" id="editId" value="" />

            <div class="field">
              <label>제목(필수)</label>
              <input id="fTitle" type="text" placeholder="예: 설비 점검" required />
            </div>

            <div class="formGrid" style="margin-top:10px;">
              <div class="field">
                <label>시작일</label>
                <input id="fStart" type="date" required />
              </div>
              <div class="field">
                <label>종료일</label>
                <input id="fEnd" type="date" required />
              </div>

              <div class="field">
                <label>시작시간(선택)</label>
                <input id="fTStart" type="time" />
              </div>
              <div class="field">
                <label>종료시간(선택)</label>
                <input id="fTEnd" type="time" />
              </div>

              <div class="field full">
                <label>반복</label>
                <select id="fFreq">
                  <option value="none">없음</option>
                  <option value="daily">매일</option>
                  <option value="weekly">매주</option>
                  <option value="monthly">매월</option>
                  <option value="yearly">매년</option>
                </select>
              </div>

              <div class="field full" id="monthlyByWrap" style="display:none;">
                <label>매월 방식</label>
                <select id="fMonthlyBy">
                  <option value="date">날짜 기준(매월 같은 날짜)</option>
                  <option value="nthWeekday">n번째 요일(예: 2번째 화요일)</option>
                </select>
              </div>

              <div class="formGrid full" id="nthWrap" style="display:none;">
                <div class="field">
                  <label>n번째</label>
                  <select id="fNth">
                    <option value="1">1번째</option>
                    <option value="2">2번째</option>
                    <option value="3">3번째</option>
                    <option value="4">4번째</option>
                    <option value="5">5번째</option>
                  </select>
                </div>
                <div class="field">
                  <label>요일</label>
                  <select id="fWeekday">
                    <option value="0">일</option>
                    <option value="1">월</option>
                    <option value="2">화</option>
                    <option value="3">수</option>
                    <option value="4">목</option>
                    <option value="5">금</option>
                    <option value="6">토</option>
                  </select>
                </div>
              </div>

              <div class="formGrid full">
                <div class="field">
                  <label>반복 종료일(선택)</label>
                  <input id="fUntil" type="date" />
                </div>
                <div class="field">
                  <label>반복 횟수(선택)</label>
                  <input id="fCount" type="number" min="1" placeholder="예: 10" />
                </div>
              </div>

              <div class="field full">
                <div class="note">
                  * 종료일과 횟수를 둘 다 입력하면 “먼저 도달하는 조건”으로 종료합니다.<br/>
                  * 매월 31일 같은 경우 해당 월에 날짜가 없으면 그 달은 발생하지 않도록 처리합니다.
                </div>
              </div>
            </div>

            <div class="row" style="margin-top:12px; justify-content:flex-end;">
              <button type="submit" class="btn primary" id="saveBtn">저장</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Admin Modal -->
  <div class="backdrop" id="adminBack" role="dialog" aria-modal="true" aria-label="관리자">
    <div class="sheet">
      <div class="sheetHead">
        <div>
          <div class="sheetTitle">관리자(휴일/휴무일)</div>
          <div class="sheetSub">휴일로 등록된 날짜는 캘린더에 ‘휴일’ 라벨로 표시됩니다.</div>
        </div>
        <button class="btn" id="adminClose" aria-label="닫기">닫기</button>
      </div>
      <div class="sheetBody">
        <div class="section">
          <h3>휴일 등록</h3>
          <div class="row">
            <input type="date" id="hDate" />
            <button class="btn primary" id="addHolidayBtn">추가</button>
          </div>
          <div class="hr"></div>
          <h3>등록된 휴일</h3>
          <div class="adminList" id="holidayList"></div>
          <div class="note" id="holidayEmpty" style="display:none; margin-top:8px;">등록된 휴일이 없습니다.</div>
        </div>

        <div class="section">
          <h3>Firebase 연결(나중에)</h3>
          <div class="note">
            현재는 LocalStorage를 사용합니다.<br/>
            나중에 Firebase로 바꾸려면 <b>loadData/saveData</b> 및 <b>add/update/delete</b> 함수 내부만 교체하면 되도록 구조화되어 있습니다.
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   Utilities: Date
========================= */
const pad2 = (n) => String(n).padStart(2, "0");
const ymd = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
const parseYMD = (s) => {
  const [y,m,d] = s.split("-").map(Number);
  return new Date(y, m-1, d, 12, 0, 0, 0); // noon avoids DST edge
};
const addDays = (d, days) => {
  const x = new Date(d);
  x.setDate(x.getDate() + days);
  return x;
};
const diffDays = (a, b) => { // b - a in days
  const A = new Date(a.getFullYear(), a.getMonth(), a.getDate(), 12);
  const B = new Date(b.getFullYear(), b.getMonth(), b.getDate(), 12);
  return Math.round((B - A) / (1000*60*60*24));
};
const clampDateOrder = (startStr, endStr) => {
  const s = parseYMD(startStr);
  const e = parseYMD(endStr);
  if (e < s) return [startStr, startStr];
  return [startStr, endStr];
};
const sameYMD = (a, b) => ymd(a) === ymd(b);

const dowKo = ["일","월","화","수","목","금","토"];

/* =========================
   Storage (LocalStorage now)
   (Firebase later: replace internals)
========================= */
const LS_KEY = "mcal_v1_data";

function defaultData(){
  return { events: [], holidays: {} };
}
function loadData(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return defaultData();
    const obj = JSON.parse(raw);
    if(!obj || typeof obj !== "object") return defaultData();
    obj.events = Array.isArray(obj.events) ? obj.events : [];
    obj.holidays = obj.holidays && typeof obj.holidays === "object" ? obj.holidays : {};
    return obj;
  }catch(e){
    return defaultData();
  }
}
function saveData(){
  localStorage.setItem(LS_KEY, JSON.stringify(DB));
}
function uuid(){
  return "e_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}

function addEvent(evt){
  DB.events.push(evt);
  saveData();
}
function updateEvent(id, patch){
  const idx = DB.events.findIndex(e => e.id === id);
  if(idx >= 0){
    DB.events[idx] = { ...DB.events[idx], ...patch, updatedAt: Date.now() };
    saveData();
  }
}
function deleteEvent(id){
  DB.events = DB.events.filter(e => e.id !== id);
  saveData();
}

function addHoliday(dateStr){
  DB.holidays[dateStr] = true;
  saveData();
}
function deleteHoliday(dateStr){
  delete DB.holidays[dateStr];
  saveData();
}

/* =========================
   Recurrence / Instances
   - store rule, render instances for current month range
========================= */
function normalizeRepeatForSave(freq, monthlyBy, nth, weekday, untilDate, count, startDateStr){
  // weekly default weekday = startDate weekday if not provided
  const sd = parseYMD(startDateStr);
  const baseWeekday = sd.getDay();

  const rep = {
    freq: freq || "none",
    monthlyBy: (freq === "monthly") ? (monthlyBy || "date") : "date",
    nth: (freq === "monthly" && monthlyBy === "nthWeekday") ? Number(nth || 1) : null,
    weekday: null,
    untilDate: untilDate || null,
    count: (count !== "" && count != null) ? Number(count) : null,
  };

  if(rep.freq === "weekly"){
    rep.weekday = Number(weekday ?? baseWeekday);
  } else if(rep.freq === "monthly" && rep.monthlyBy === "nthWeekday"){
    rep.weekday = Number(weekday ?? baseWeekday);
    rep.nth = Number(nth || 1);
  } else if(rep.freq === "daily" || rep.freq === "monthly" || rep.freq === "yearly" || rep.freq === "none"){
    rep.weekday = null;
  }

  return rep;
}

function isAfterYMD(aStr, bStr){ // a > b
  return parseYMD(aStr).getTime() > parseYMD(bStr).getTime();
}

/**
 * Generate occurrences (instances) for a base event within [rangeStart, rangeEnd] inclusive.
 * Each instance includes:
 * - baseId
 * - startDate, endDate (ymd strings)
 * - title, time
 */
function expandEventInstances(base, rangeStart, rangeEnd){
  const out = [];
  const freq = base.repeat?.freq || "none";

  const baseStart = parseYMD(base.startDate);
  const baseEnd = parseYMD(base.endDate);
  const duration = Math.max(0, diffDays(baseStart, baseEnd)); // inclusive span end = start + duration

  const untilStr = base.repeat?.untilDate || null;
  const countMax = base.repeat?.count ?? null;

  // safety cap: if no until/count, limit generation window to 1 year from rangeStart
  const safetyEnd = addDays(parseYMD(rangeStart), 366);

  const hardEndDate = (() => {
    const rangeEndD = parseYMD(rangeEnd);
    let end = rangeEndD;
    if(!untilStr && !countMax){
      if(end > safetyEnd) end = safetyEnd;
    }
    if(untilStr){
      const u = parseYMD(untilStr);
      if(u < end) end = u;
    }
    return end;
  })();

  const inRangeOverlap = (sD, eD) => !(eD < parseYMD(rangeStart) || sD > parseYMD(rangeEnd));

  // helpers for monthly nth weekday
  function nthWeekdayOfMonth(year, monthIndex, weekday, nth){
    // monthIndex: 0-11
    const first = new Date(year, monthIndex, 1, 12);
    const firstDow = first.getDay();
    const delta = (weekday - firstDow + 7) % 7;
    const day = 1 + delta + (nth - 1) * 7;
    const candidate = new Date(year, monthIndex, day, 12);
    if(candidate.getMonth() !== monthIndex) return null; // overflow
    return candidate;
  }

  // compute first occurrence that could possibly overlap rangeStart
  // We'll iterate forward, but we can start at baseStart and push until hardEndDate
  let occStart = new Date(baseStart);

  // For weekly, align to weekday.
  // For monthly, generate per month.
  // For yearly, per year.

  let generated = 0;

  if(freq === "none"){
    const sD = baseStart, eD = addDays(baseStart, duration);
    if(inRangeOverlap(sD, eD)){
      out.push({ baseId: base.id, startDate: ymd(sD), endDate: ymd(eD), title: base.title, time: base.time });
    }
    return out;
  }

  if(freq === "daily"){
    // start from max(baseStart, rangeStart - duration) to catch overlaps
    const startFrom = parseYMD(rangeStart);
    let cur = baseStart < startFrom ? baseStart : baseStart;
    // advance until cur >= (rangeStart - duration)
    const minStart = addDays(startFrom, -duration);
    if(cur < minStart){
      cur = new Date(minStart);
      // ensure daily series alignment: baseStart + k days, so we need k = diffDays(baseStart, cur) rounded
      const k = Math.max(0, diffDays(baseStart, cur));
      cur = addDays(baseStart, k);
      while(cur < minStart) cur = addDays(cur, 1);
    }

    while(cur <= hardEndDate){
      const sD = cur;
      const eD = addDays(cur, duration);

      // stop by count
      generated++;
      if(countMax && generated > countMax) break;

      if(inRangeOverlap(sD, eD)){
        out.push({ baseId: base.id, startDate: ymd(sD), endDate: ymd(eD), title: base.title, time: base.time });
      }
      cur = addDays(cur, 1);
    }
    return out;
  }

  if(freq === "weekly"){
    const w = Number(base.repeat?.weekday ?? baseStart.getDay());
    // find first occurrence on/after (rangeStart - duration) that matches weekday and is >= baseStart
    const minStart = addDays(parseYMD(rangeStart), -duration);
    let cur = new Date(baseStart);

    if(cur < minStart){
      cur = new Date(minStart);
    }
    // align to weekday
    const delta = (w - cur.getDay() + 7) % 7;
    cur = addDays(cur, delta);
    // ensure not before baseStart
    while(cur < baseStart) cur = addDays(cur, 7);

    while(cur <= hardEndDate){
      const sD = cur;
      const eD = addDays(cur, duration);

      generated++;
      if(countMax && generated > countMax) break;

      if(inRangeOverlap(sD, eD)){
        out.push({ baseId: base.id, startDate: ymd(sD), endDate: ymd(eD), title: base.title, time: base.time });
      }
      cur = addDays(cur, 7);
    }
    return out;
  }

  if(freq === "monthly"){
    // We generate month-by-month in the displayed range window, but also start a bit earlier to include overlaps
    const minStart = addDays(parseYMD(rangeStart), -duration);
    const startYear = minStart.getFullYear();
    const startMonth = minStart.getMonth();

    const endYear = hardEndDate.getFullYear();
    const endMonth = hardEndDate.getMonth();

    // derive rule
    const monthlyBy = base.repeat?.monthlyBy || "date";

    for(let y = startYear, m = startMonth; (y < endYear) || (y === endYear && m <= endMonth); ){
      let occ = null;

      if(monthlyBy === "date"){
        const dayOfMonth = parseYMD(base.startDate).getDate();
        // if that date doesn't exist in this month, skip (do not clamp)
        const test = new Date(y, m, dayOfMonth, 12);
        if(test.getMonth() === m) occ = test;
      }else{
        const nth = Number(base.repeat?.nth || 1);
        const weekday = Number(base.repeat?.weekday ?? parseYMD(base.startDate).getDay());
        occ = nthWeekdayOfMonth(y, m, weekday, nth);
      }

      if(occ){
        if(occ >= baseStart){ // don't create before initial start
          generated++;
          if(countMax && generated > countMax) break;

          const sD = occ;
          const eD = addDays(occ, duration);
          if(inRangeOverlap(sD, eD)){
            out.push({ baseId: base.id, startDate: ymd(sD), endDate: ymd(eD), title: base.title, time: base.time });
          }
        }
      }

      // move next month
      m++;
      if(m > 11){ m = 0; y++; }

      // if untilDate exists and month start is after it, can stop
      if(untilStr){
        const u = parseYMD(untilStr);
        const monthStart = new Date(y, m, 1, 12);
        if(monthStart > u) break;
      }
    }
    return out;
  }

  if(freq === "yearly"){
    const minStart = addDays(parseYMD(rangeStart), -duration);
    let y = minStart.getFullYear();
    const endY = hardEndDate.getFullYear();
    const baseM = parseYMD(base.startDate).getMonth();
    const baseD = parseYMD(base.startDate).getDate();

    while(y <= endY){
      const cand = new Date(y, baseM, baseD, 12);
      // if base date doesn't exist (Feb 29 on non-leap): skip (do not clamp)
      if(cand.getMonth() === baseM){
        if(cand >= baseStart){
          generated++;
          if(countMax && generated > countMax) break;

          const sD = cand;
          const eD = addDays(cand, duration);
          if(inRangeOverlap(sD, eD)){
            out.push({ baseId: base.id, startDate: ymd(sD), endDate: ymd(eD), title: base.title, time: base.time });
          }
        }
      }
      y++;

      if(untilStr){
        const u = parseYMD(untilStr);
        const nextYearStart = new Date(y, 0, 1, 12);
        if(nextYearStart > u) break;
      }
    }
    return out;
  }

  return out;
}

/* =========================
   Rendering: Month Grid + Bars
========================= */
const $ = (id) => document.getElementById(id);
const gridEl = $("grid");
const monthTitleEl = $("monthTitle");
const calCard = $("calCard");

let DB = loadData();
let curMonth = new Date(); // points to some day in current month
curMonth = new Date(curMonth.getFullYear(), curMonth.getMonth(), 1, 12);

let lastRenderedRange = null; // {startYMD,endYMD, days[]}

function monthLabel(d){
  return `${d.getFullYear()}년 ${d.getMonth()+1}월`;
}

function getGridRange(monthDate){
  const first = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1, 12);
  const last = new Date(monthDate.getFullYear(), monthDate.getMonth()+1, 0, 12);
  // Sunday-start: grid starts on Sunday before/at first
  const start = addDays(first, -first.getDay());
  // grid ends on Saturday after/at last
  const end = addDays(last, (6 - last.getDay()));
  return { start, end };
}

function buildDayArray(range){
  const days = [];
  let d = new Date(range.start);
  while(d <= range.end){
    days.push(new Date(d));
    d = addDays(d, 1);
  }
  return days;
}

function getAllInstancesForRange(rangeStartStr, rangeEndStr){
  // Expand all base events into instances intersecting this range
  const all = [];
  for(const base of DB.events){
    const inst = expandEventInstances(base, rangeStartStr, rangeEndStr);
    for(const i of inst) all.push(i);
  }
  // sort by startDate, then duration desc (nice stacking)
  all.sort((a,b)=>{
    if(a.startDate !== b.startDate) return a.startDate < b.startDate ? -1 : 1;
    const ad = diffDays(parseYMD(a.startDate), parseYMD(a.endDate));
    const bd = diffDays(parseYMD(b.startDate), parseYMD(b.endDate));
    return bd - ad;
  });
  return all;
}

function render(){
  monthTitleEl.textContent = monthLabel(curMonth);

  const {start, end} = getGridRange(curMonth);
  const startStr = ymd(start);
  const endStr = ymd(end);
  lastRenderedRange = { startStr, endStr };

  const days = buildDayArray({start, end});

  // Prepare instances for this display range
  const instances = getAllInstancesForRange(startStr, endStr);

  // Map day -> counts + visible counts (computed after lane assignment)
  const dayTotalCount = {};   // ymd -> total instances covering that date
  const dayVisibleCount = {}; // ymd -> visible (lane < 3)

  // total count
  for(const inst of instances){
    const s = parseYMD(inst.startDate);
    const e = parseYMD(inst.endDate);
    const d0 = new Date(s);
    while(d0 <= e){
      const k = ymd(d0);
      if(k >= startStr && k <= endStr){
        dayTotalCount[k] = (dayTotalCount[k] || 0) + 1;
      }
      d0.setDate(d0.getDate()+1);
    }
  }

  // Build weeks
  gridEl.innerHTML = "";
  gridEl.classList.remove("fadeIn");
  void gridEl.offsetWidth;
  gridEl.classList.add("fadeIn");

  const weeks = [];
  for(let w=0; w<days.length/7; w++){
    const weekDays = days.slice(w*7, w*7+7);
    weeks.push(weekDays);
  }

  const todayStr = ymd(new Date());

  weeks.forEach((weekDays) => {
    const weekEl = document.createElement("div");
    weekEl.className = "week";

    const daysEl = document.createElement("div");
    daysEl.className = "days";

    // day cells
    weekDays.forEach((d, idx) => {
      const cell = document.createElement("div");
      cell.className = "day";

      const inMonth = d.getMonth() === curMonth.getMonth();
      if(!inMonth) cell.classList.add("out");

      if(idx === 0) cell.classList.add("sun");
      if(idx === 6) cell.classList.add("sat");

      const ds = ymd(d);
      cell.dataset.date = ds;

      if(ds === todayStr) cell.classList.add("today");

      const dnum = document.createElement("div");
      dnum.className = "dnum";
      dnum.textContent = String(d.getDate());
      cell.appendChild(dnum);

      // holiday label (B 방식)
      if(DB.holidays[ds]){
        const tag = document.createElement("div");
        tag.className = "holidayTag";
        tag.textContent = "휴일";
        cell.appendChild(tag);
      }

      // reserved bar space (consistent height)
      const space = document.createElement("div");
      space.className = "barSpace";
      cell.appendChild(space);

      // click handler opens modal
      cell.addEventListener("click", (ev) => {
        // ignore if user is scrolling; we keep simple
        openDayModal(ds);
      });

      daysEl.appendChild(cell);
    });

    // bars overlay
    const barsEl = document.createElement("div");
    barsEl.className = "bars";
    barsEl.style.height = `calc((var(--laneH) * var(--lanes)) + (var(--laneGap) * (var(--lanes) - 1)))`;

    weekEl.appendChild(daysEl);
    weekEl.appendChild(barsEl);
    gridEl.appendChild(weekEl);

    // Now compute and draw bars for this week
    drawWeekBars(weekDays, barsEl, instances, dayVisibleCount);
  });

  // After bars computed, add +N more buttons per day
  weeks.forEach((weekDays) => {
    weekDays.forEach((d) => {
      const ds = ymd(d);
      const total = dayTotalCount[ds] || 0;
      const vis = dayVisibleCount[ds] || 0;
      const extra = total - vis;
      if(extra > 0){
        const cell = gridEl.querySelector(`.day[data-date="${ds}"]`);
        if(cell){
          const moreWrap = document.createElement("div");
          moreWrap.className = "more";
          const btn = document.createElement("button");
          btn.className = "moreBtn";
          btn.type = "button";
          btn.textContent = `+${extra} 더보기`;
          btn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            openDayModal(ds);
          });
          moreWrap.appendChild(btn);
          cell.appendChild(moreWrap);
        }
      }
    });
  });
}

function drawWeekBars(weekDays, barsEl, instances, dayVisibleCount){
  // Determine segments that overlap this week
  const wStart = weekDays[0];
  const wEnd = weekDays[6];
  const wStartStr = ymd(wStart);
  const wEndStr = ymd(wEnd);

  const segs = [];
  for(const inst of instances){
    // overlap check
    if(inst.endDate < wStartStr || inst.startDate > wEndStr) continue;

    // segment start/end indexes within this week
    const s = parseYMD(inst.startDate);
    const e = parseYMD(inst.endDate);

    const segStart = s < wStart ? wStart : s;
    const segEnd = e > wEnd ? wEnd : e;

    const startIdx = diffDays(wStart, segStart); // 0..6
    const endIdx = diffDays(wStart, segEnd);     // 0..6

    segs.push({
      inst,
      startIdx,
      endIdx,
      // for sorting: earlier start first, longer first
      sortKey: inst.startDate,
      len: endIdx - startIdx
    });
  }

  segs.sort((a,b)=>{
    if(a.sortKey !== b.sortKey) return a.sortKey < b.sortKey ? -1 : 1;
    return b.len - a.len;
  });

  // Assign lanes avoiding overlaps (simple interval graph coloring)
  const lanes = []; // each lane is array of placed segments intervals
  const placed = []; // {seg, lane}

  function overlaps(aStart, aEnd, bStart, bEnd){
    return !(aEnd < bStart || bEnd < aStart);
  }

  for(const seg of segs){
    let lane = 0;
    while(true){
      if(!lanes[lane]) lanes[lane] = [];
      const conflict = lanes[lane].some(p => overlaps(seg.startIdx, seg.endIdx, p.startIdx, p.endIdx));
      if(!conflict){
        lanes[lane].push(seg);
        placed.push({ seg, lane });
        break;
      }
      lane++;
    }
  }

  // Render visible lanes only (0..2)
  const visibleMax = 3;
  const rowRect = barsEl.getBoundingClientRect();
  const parentWeek = barsEl.parentElement;
  const daysRow = parentWeek.querySelector(".days");
  const daysRect = daysRow.getBoundingClientRect();
  // width per day based on actual element
  const dayW = daysRect.width / 7;

  for(const {seg, lane} of placed){
    if(lane >= visibleMax) continue;

    const left = 6 + (seg.startIdx * dayW); // barsEl padding left approx
    const width = (seg.endIdx - seg.startIdx + 1) * dayW - 6; // slight inset
    const top = lane * (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--laneH')) +
                        parseInt(getComputedStyle(document.documentElement).getPropertyValue('--laneGap')));

    const bar = document.createElement("div");
    bar.className = "bar";
    bar.style.left = `${left}px`;
    bar.style.top = `${top}px`;
    bar.style.width = `${Math.max(18, width)}px`;

    // text
    const t = document.createElement("div");
    t.className = "t";
    t.textContent = seg.inst.title || "(제목 없음)";

    bar.appendChild(t);

    // time shown only on segment start cell (nice & simple)
    const time = seg.inst.time || {};
    if((time.start || time.end) && seg.startIdx === Math.max(0, diffDays(parseYMD(ymd(weekDays[0])), parseYMD(seg.inst.startDate))) ){
      const tm = document.createElement("div");
      tm.className = "time";
      const s = time.start ? time.start : "";
      const e = time.end ? time.end : "";
      tm.textContent = (s && e) ? `${s}~${e}` : (s ? s : (e ? e : ""));
      bar.appendChild(tm);
    }

    barsEl.appendChild(bar);

    // mark visible count for each day in segment
    for(let i=seg.startIdx; i<=seg.endIdx; i++){
      const ds = ymd(weekDays[i]);
      dayVisibleCount[ds] = (dayVisibleCount[ds] || 0) + 1;
    }
  }
}

/* =========================
   Day Modal: list + add/edit/delete
========================= */
const dayModalBack = $("dayModalBack");
const dayModalTitle = $("dayModalTitle");
const dayModalSub = $("dayModalSub");
const dayModalClose = $("dayModalClose");
const eventListEl = $("eventList");
const emptyNoteEl = $("emptyNote");
const showAddBtn = $("showAddBtn");

const formSection = $("formSection");
const formTitle = $("formTitle");
const cancelFormBtn = $("cancelFormBtn");

const eventForm = $("eventForm");
const editIdEl = $("editId");
const fTitle = $("fTitle");
const fStart = $("fStart");
const fEnd = $("fEnd");
const fTStart = $("fTStart");
const fTEnd = $("fTEnd");
const fFreq = $("fFreq");
const monthlyByWrap = $("monthlyByWrap");
const fMonthlyBy = $("fMonthlyBy");
const nthWrap = $("nthWrap");
const fNth = $("fNth");
const fWeekday = $("fWeekday");
const fUntil = $("fUntil");
const fCount = $("fCount");

let selectedDateStr = null;

function openDayModal(dateStr){
  selectedDateStr = dateStr;
  dayModalTitle.textContent = dateStr;
  const d = parseYMD(dateStr);
  dayModalSub.textContent = `${d.getMonth()+1}월 ${d.getDate()}일(${dowKo[d.getDay()]})에 포함되는 일정`;

  // reset form
  hideForm();

  // render list
  renderDayList(dateStr);

  dayModalBack.classList.add("show");
}
function closeDayModal(){
  dayModalBack.classList.remove("show");
  selectedDateStr = null;
}

function renderDayList(dateStr){
  const { startStr, endStr } = lastRenderedRange || (() => {
    const r = getGridRange(curMonth);
    return { startStr: ymd(r.start), endStr: ymd(r.end) };
  })();

  // We want list for that date (include repeated instances)
  const instances = getAllInstancesForRange(startStr, endStr);
  const list = instances.filter(i => i.startDate <= dateStr && i.endDate >= dateStr);

  // For editing, we show base event references
  const baseById = new Map(DB.events.map(e => [e.id, e]));

  // Sort: those that start earlier first
  list.sort((a,b)=>{
    if(a.startDate !== b.startDate) return a.startDate < b.startDate ? -1 : 1;
    if(a.endDate !== b.endDate) return a.endDate > b.endDate ? -1 : 1;
    return (a.title||"").localeCompare(b.title||"");
  });

  eventListEl.innerHTML = "";
  emptyNoteEl.style.display = list.length ? "none" : "block";

  for(const inst of list){
    const base = baseById.get(inst.baseId);
    if(!base) continue;

    const item = document.createElement("div");
    item.className = "item";

    const meta = document.createElement("div");
    meta.className = "meta";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = base.title;

    const desc = document.createElement("div");
    desc.className = "desc";

    const time = base.time || {};
    const timeText = (time.start || time.end)
      ? ` · 시간: ${(time.start||"")} ${(time.start && time.end) ? "~" : ""} ${(time.end||"")}`.replace(/\s+/g," ").trim()
      : "";

    const rep = base.repeat?.freq && base.repeat.freq !== "none"
      ? ` · 반복: ${repeatLabel(base.repeat, base.startDate)}`
      : "";

    desc.textContent = `기간: ${base.startDate} ~ ${base.endDate}${timeText}${rep}`;

    meta.appendChild(name);
    meta.appendChild(desc);

    const btns = document.createElement("div");
    btns.className = "btns";

    const editBtn = document.createElement("button");
    editBtn.className = "mini primary";
    editBtn.type = "button";
    editBtn.textContent = "수정";
    editBtn.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      showFormForEdit(base);
    });

    const delBtn = document.createElement("button");
    delBtn.className = "mini danger";
    delBtn.type = "button";
    delBtn.textContent = "삭제";
    delBtn.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      if(confirm("이 일정을 삭제할까요? (반복 일정이면 규칙 전체가 삭제됩니다)")){
        deleteEvent(base.id);
        render();
        renderDayList(dateStr);
      }
    });

    btns.appendChild(editBtn);
    btns.appendChild(delBtn);

    item.appendChild(meta);
    item.appendChild(btns);
    eventListEl.appendChild(item);
  }
}

function repeatLabel(rep, startDateStr){
  const f = rep.freq;
  if(f === "daily") return "매일";
  if(f === "weekly"){
    const wd = rep.weekday ?? parseYMD(startDateStr).getDay();
    return `매주(${dowKo[wd]})`;
  }
  if(f === "monthly"){
    if(rep.monthlyBy === "nthWeekday"){
      return `매월 ${rep.nth}번째 ${dowKo[rep.weekday ?? 0]}`;
    }
    return "매월(날짜)";
  }
  if(f === "yearly") return "매년";
  return "없음";
}

function showForm(){
  formSection.style.display = "block";
}
function hideForm(){
  formSection.style.display = "none";
  eventForm.reset();
  editIdEl.value = "";
  formTitle.textContent = "일정 추가";
  monthlyByWrap.style.display = "none";
  nthWrap.style.display = "none";
}

function showFormForNew(){
  hideForm();
  formTitle.textContent = "일정 추가";
  editIdEl.value = "";

  // default dates: selected date
  const ds = selectedDateStr || ymd(new Date());
  fStart.value = ds;
  fEnd.value = ds;

  // default: no repeat
  fFreq.value = "none";
  monthlyByWrap.style.display = "none";
  nthWrap.style.display = "none";

  showForm();
  fTitle.focus();
}
function showFormForEdit(base){
  hideForm();
  formTitle.textContent = "일정 수정";
  editIdEl.value = base.id;

  fTitle.value = base.title || "";
  fStart.value = base.startDate;
  fEnd.value = base.endDate;
  fTStart.value = base.time?.start || "";
  fTEnd.value = base.time?.end || "";

  const rep = base.repeat || { freq:"none" };
  fFreq.value = rep.freq || "none";

  // Show monthly controls if needed
  if(fFreq.value === "monthly"){
    monthlyByWrap.style.display = "block";
    fMonthlyBy.value = rep.monthlyBy || "date";
    if(fMonthlyBy.value === "nthWeekday"){
      nthWrap.style.display = "grid";
      fNth.value = String(rep.nth || 1);
      fWeekday.value = String(rep.weekday ?? parseYMD(base.startDate).getDay());
    }else{
      nthWrap.style.display = "none";
      fWeekday.value = String(parseYMD(base.startDate).getDay());
      fNth.value = "1";
    }
  }else{
    monthlyByWrap.style.display = "none";
    nthWrap.style.display = "none";
    // weekly uses weekday
    if(fFreq.value === "weekly"){
      fWeekday.value = String(rep.weekday ?? parseYMD(base.startDate).getDay());
    }else{
      fWeekday.value = String(parseYMD(base.startDate).getDay());
    }
    fNth.value = "1";
    fMonthlyBy.value = "date";
  }

  fUntil.value = rep.untilDate || "";
  fCount.value = (rep.count != null) ? String(rep.count) : "";

  showForm();
  fTitle.focus();
}

/* form dynamic controls */
fFreq.addEventListener("change", ()=>{
  const v = fFreq.value;
  if(v === "monthly"){
    monthlyByWrap.style.display = "block";
    if(fMonthlyBy.value === "nthWeekday"){
      nthWrap.style.display = "grid";
    }else{
      nthWrap.style.display = "none";
    }
  }else{
    monthlyByWrap.style.display = "none";
    nthWrap.style.display = "none";
  }
});
fMonthlyBy.addEventListener("change", ()=>{
  if(fFreq.value === "monthly" && fMonthlyBy.value === "nthWeekday"){
    nthWrap.style.display = "grid";
  }else{
    nthWrap.style.display = "none";
  }
});

eventForm.addEventListener("submit", (ev)=>{
  ev.preventDefault();

  const title = (fTitle.value || "").trim();
  if(!title){
    alert("제목을 입력해 주세요.");
    fTitle.focus();
    return;
  }

  const sVal = fStart.value;
  const eVal = fEnd.value;
  if(!sVal || !eVal){
    alert("시작일/종료일을 입력해 주세요.");
    return;
  }
  const [startDate, endDate] = clampDateOrder(sVal, eVal);

  // time optional
  const time = {
    start: fTStart.value || null,
    end: fTEnd.value || null
  };

  // Repeat rule
  const freq = fFreq.value;
  const monthlyBy = fMonthlyBy.value;
  const nth = fNth.value;
  const weekday = fWeekday.value;
  const untilDate = fUntil.value || null;
  const count = fCount.value;

  const repeat = normalizeRepeatForSave(freq, monthlyBy, nth, weekday, untilDate, count, startDate);

  // If weekly and user didn't manually set weekday, keep startDate weekday.
  // If monthly nthWeekday: keep selected.

  // Validate untilDate relative to start
  if(repeat.untilDate && isAfterYMD(startDate, repeat.untilDate)){
    alert("반복 종료일은 시작일보다 이전일 수 없습니다.");
    return;
  }

  const id = editIdEl.value;

  if(!id){
    const evt = {
      id: uuid(),
      title,
      startDate,
      endDate,
      time,
      repeat,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    addEvent(evt);
  }else{
    updateEvent(id, { title, startDate, endDate, time, repeat });
  }

  render();
  renderDayList(selectedDateStr);
  hideForm();
});

showAddBtn.addEventListener("click", showFormForNew);
cancelFormBtn.addEventListener("click", hideForm);

dayModalClose.addEventListener("click", closeDayModal);
dayModalBack.addEventListener("click", (e)=>{
  if(e.target === dayModalBack) closeDayModal();
});

document.addEventListener("keydown", (e)=>{
  if(e.key === "Escape"){
    if(dayModalBack.classList.contains("show")) closeDayModal();
    if(adminBack.classList.contains("show")) closeAdmin();
  }
});

/* =========================
   Admin modal (holidays)
========================= */
const adminBack = $("adminBack");
const adminBtn = $("adminBtn");
const adminClose = $("adminClose");
const hDate = $("hDate");
const addHolidayBtn = $("addHolidayBtn");
const holidayList = $("holidayList");
const holidayEmpty = $("holidayEmpty");

function openAdmin(){
  renderHolidayList();
  adminBack.classList.add("show");
}
function closeAdmin(){
  adminBack.classList.remove("show");
}
adminBtn.addEventListener("click", openAdmin);
adminClose.addEventListener("click", closeAdmin);
adminBack.addEventListener("click", (e)=>{
  if(e.target === adminBack) closeAdmin();
});
addHolidayBtn.addEventListener("click", ()=>{
  const ds = hDate.value;
  if(!ds) return alert("날짜를 선택해 주세요.");
  addHoliday(ds);
  renderHolidayList();
  render();
});
function renderHolidayList(){
  const keys = Object.keys(DB.holidays).sort();
  holidayList.innerHTML = "";
  holidayEmpty.style.display = keys.length ? "none" : "block";
  for(const ds of keys){
    const pill = document.createElement("div");
    pill.className = "pill";
    const left = document.createElement("div");
    left.className = "date";
    left.textContent = ds;
    const x = document.createElement("button");
    x.className = "x";
    x.type = "button";
    x.textContent = "삭제";
    x.addEventListener("click", ()=>{
      deleteHoliday(ds);
      renderHolidayList();
      render();
    });
    pill.appendChild(left);
    pill.appendChild(x);
    holidayList.appendChild(pill);
  }
}

/* =========================
   Month navigation (no buttons)
   - Today button
   - Swipe left/right
========================= */
$("todayBtn").addEventListener("click", ()=>{
  const t = new Date();
  curMonth = new Date(t.getFullYear(), t.getMonth(), 1, 12);
  render();
});

function shiftMonth(delta){
  curMonth = new Date(curMonth.getFullYear(), curMonth.getMonth()+delta, 1, 12);
  render();
}

// Swipe handling (touch + optional mouse drag)
let swiping = false;
let sx=0, sy=0, mx=0, my=0;
let moved = false;

function onStart(x,y){
  swiping = true;
  sx = x; sy = y;
  mx = x; my = y;
  moved = false;
}
function onMove(x,y){
  if(!swiping) return;
  mx = x; my = y;
  const dx = mx - sx;
  const dy = my - sy;
  if(Math.abs(dx) > 6 || Math.abs(dy) > 6) moved = true;
}
function onEnd(){
  if(!swiping) return;
  swiping = false;
  if(!moved) return;

  const dx = mx - sx;
  const dy = my - sy;

  // prevent conflict with vertical scroll: if vertical dominates, ignore
  if(Math.abs(dy) > Math.abs(dx) * 1.2) return;

  // threshold
  if(Math.abs(dx) < 40) return;

  if(dx < 0){
    shiftMonth(1); // left swipe => next
  }else{
    shiftMonth(-1); // right swipe => prev
  }
}

calCard.addEventListener("touchstart", (e)=>{
  if(e.touches.length !== 1) return;
  const t = e.touches[0];
  onStart(t.clientX, t.clientY);
}, {passive:true});
calCard.addEventListener("touchmove", (e)=>{
  if(!swiping || e.touches.length !== 1) return;
  const t = e.touches[0];
  onMove(t.clientX, t.clientY);
}, {passive:true});
calCard.addEventListener("touchend", ()=>onEnd(), {passive:true});

// Optional mouse drag on desktop (nice-to-have)
let mouseDown = false;
calCard.addEventListener("mousedown", (e)=>{
  mouseDown = true;
  onStart(e.clientX, e.clientY);
});
window.addEventListener("mousemove", (e)=>{
  if(!mouseDown) return;
  onMove(e.clientX, e.clientY);
});
window.addEventListener("mouseup", ()=>{
  if(!mouseDown) return;
  mouseDown = false;
  onEnd();
});

/* =========================
   Initialize
========================= */
render();

/* =========================
   Notes for Firebase migration
========================= */
/*
Firebase Realtime Database로 바꾸려면:
- loadData() / saveData() 내부를 Firebase read/write로 교체
- addEvent/updateEvent/deleteEvent, addHoliday/deleteHoliday 에서 LocalStorage 대신 DB 업데이트
- 렌더링은 DB(메모리) 갱신 후 render() 호출 구조 유지
*/
</script>
</body>
</html>
