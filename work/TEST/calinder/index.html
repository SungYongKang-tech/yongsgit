<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>업무 일정 공유 캘린더</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --border-color: #e2e8f0;
            --text-main: #1e293b;
            --text-muted: #64748b;
            --sunday-color: #ef4444;
            --saturday-color: #3b82f6;
            --holiday-bg: #fee2e2;
            --holiday-text: #b91c1c;
            --bar-height: 22px;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background-color: var(--bg-color); 
            color: var(--text-main);
            margin: 0; padding: 0; overflow-x: hidden;
        }

        /* Layout */
        .app-container { max-width: 800px; margin: 0 auto; background: var(--card-bg); min-height: 100vh; display: flex; flex-direction: column; }
        
        /* Header */
        header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 16px; border-bottom: 1px solid var(--border-color);
            position: sticky; top: 0; background: #fff; z-index: 10;
        }
        .month-title { font-size: 1.25rem; font-weight: 700; }
        .header-btns button {
            padding: 6px 12px; border: 1px solid var(--border-color);
            background: #fff; border-radius: 6px; cursor: pointer; font-size: 0.9rem;
        }

        /* Calendar Grid */
        .calendar-grid {
            display: grid; grid-template-columns: repeat(7, 1fr);
            flex: 1; border-bottom: 1px solid var(--border-color);
            touch-action: pan-y; /* 수직 스크롤 허용, 수평은 JS 처리 */
            transition: opacity 0.2s ease-in-out;
        }
        .day-header {
            text-align: center; padding: 8px 0; font-size: 0.75rem;
            font-weight: 600; border-bottom: 1px solid var(--border-color);
            background: #fdfdfd;
        }
        .day-header.sun { color: var(--sunday-color); }
        .day-header.sat { color: var(--saturday-color); }

        .day-cell {
            min-height: 100px; border-right: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            position: relative; padding-top: 24px; /* 숫자 자리 확보 */
        }
        .day-cell:nth-child(7n) { border-right: none; }
        .day-num {
            position: absolute; top: 4px; left: 4px;
            font-size: 0.85rem; font-weight: 500; width: 20px; height: 20px;
            display: flex; align-items: center; justify-content: center;
        }
        .day-cell.today .day-num { background: var(--primary-color); color: #fff; border-radius: 50%; }
        .day-cell.other-month { opacity: 0.3; }
        
        /* Holiday Label */
        .holiday-label {
            position: absolute; top: 4px; right: 4px;
            font-size: 0.7rem; padding: 1px 4px;
            background: var(--holiday-bg); color: var(--holiday-text);
            border-radius: 4px; font-weight: bold;
        }

        /* Event Bars */
        .event-bars-container {
            display: flex; flex-direction: column; gap: 2px;
            padding: 0 2px;
        }
        .event-bar {
            height: var(--bar-height); font-size: 0.7rem;
            color: #fff; padding: 0 6px; border-radius: 4px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            display: flex; align-items: center; z-index: 1;
            cursor: pointer;
        }
        .event-bar.start-cap { border-top-left-radius: 4px; border-bottom-left-radius: 4px; margin-left: 2px; }
        .event-bar.end-cap { border-top-right-radius: 4px; border-bottom-right-radius: 4px; margin-right: 2px; }
        .more-count {
            font-size: 0.7rem; color: var(--text-muted); padding-left: 4px; margin-top: 2px;
            cursor: pointer; font-weight: 600;
        }

        /* Modal Styles */
        .modal {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.5); z-index: 100;
            align-items: flex-end; justify-content: center;
        }
        .modal-content {
            background: #fff; width: 100%; max-width: 500px;
            border-top-left-radius: 16px; border-top-right-radius: 16px;
            padding: 20px; max-height: 90vh; overflow-y: auto;
            animation: slideUp 0.3s ease-out;
        }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }

        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; font-size: 0.85rem; margin-bottom: 4px; color: var(--text-muted); }
        .form-group input, .form-group select {
            width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem;
        }
        .btn-group { display: flex; gap: 8px; margin-top: 16px; }
        .btn { flex: 1; padding: 12px; border-radius: 8px; border: none; font-weight: 600; cursor: pointer; }
        .btn-primary { background: var(--primary-color); color: #fff; }
        .btn-secondary { background: #e2e8f0; color: var(--text-main); }
        .btn-danger { background: #fee2e2; color: #ef4444; }

        .event-list-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px; border-bottom: 1px solid var(--border-color);
        }
    </style>
</head>
<body>

<div class="app-container">
    <header>
        <div class="month-title" id="currentMonthYear">2026년 2월</div>
        <div class="header-btns">
            <button onclick="goToday()">오늘</button>
            <button onclick="openAdminModal()">⚙️</button>
        </div>
    </header>

    <div class="calendar-grid" id="calendarGrid">
        </div>
</div>

<div id="dayModal" class="modal" onclick="if(event.target===this) closeModal('dayModal')">
    <div class="modal-content">
        <h3 id="modalDateTitle">날짜</h3>
        <div id="dayEventList"></div>
        <hr style="border:0; border-top:1px solid #eee; margin:16px 0;">
        <h4 id="formTitle">일정 추가</h4>
        <form id="eventForm">
            <input type="hidden" id="editEventId">
            <div class="form-group">
                <label>제목*</label>
                <input type="text" id="eventTitle" required placeholder="일정 제목을 입력하세요">
            </div>
            <div style="display:flex; gap:8px;">
                <div class="form-group" style="flex:1;">
                    <label>시작일</label>
                    <input type="date" id="eventStartDate" required>
                </div>
                <div class="form-group" style="flex:1;">
                    <label>종료일</label>
                    <input type="date" id="eventEndDate" required>
                </div>
            </div>
            <div style="display:flex; gap:8px;">
                <div class="form-group" style="flex:1;">
                    <label>시작 시간(선택)</label>
                    <input type="time" id="eventStartTime">
                </div>
                <div class="form-group" style="flex:1;">
                    <label>종료 시간(선택)</label>
                    <input type="time" id="eventEndTime">
                </div>
            </div>
            <div class="form-group">
                <label>반복 규칙</label>
                <select id="eventRepeat">
                    <option value="none">반복 안 함</option>
                    <option value="daily">매일</option>
                    <option value="weekly">매주</option>
                    <option value="monthlyDate">매월(날짜 기준)</option>
                    <option value="monthlyNth">매월(n번째 요일)</option>
                    <option value="yearly">매년</option>
                </select>
            </div>
            <div id="repeatEndOption" class="form-group" style="display:none;">
                <label>반복 종료일</label>
                <input type="date" id="eventUntilDate">
            </div>
            <div class="btn-group">
                <button type="button" class="btn btn-secondary" onclick="closeModal('dayModal')">닫기</button>
                <button type="submit" class="btn btn-primary">저장</button>
            </div>
        </form>
    </div>
</div>

<div id="adminModal" class="modal" onclick="if(event.target===this) closeModal('adminModal')">
    <div class="modal-content">
        <h3>⚙️ 관리자 설정 (휴일 관리)</h3>
        <div class="form-group">
            <label>휴일 등록</label>
            <div style="display:flex; gap:4px;">
                <input type="date" id="holidayDate">
                <button class="btn btn-primary" onclick="handleAddHoliday()" style="flex:0.3; padding:5px;">추가</button>
            </div>
        </div>
        <div id="holidayList" style="max-height: 200px; overflow-y: auto; margin-top:10px;"></div>
        <div class="btn-group">
            <button class="btn btn-secondary" onclick="closeModal('adminModal')">닫기</button>
        </div>
    </div>
</div>

<script>
/**
 * [FIREBASE 연동 가이드]
 * 향후 Firebase 연동 시, 아래 DB_SERVICE 내의 
 * localStorage 관련 로직을 firebase realtime db API로 교체하세요.
 */
const DB_SERVICE = {
    saveData: (key, data) => localStorage.setItem(key, JSON.stringify(data)),
    loadData: (key) => JSON.parse(localStorage.getItem(key)) || [],
    
    getEvents: () => DB_SERVICE.loadData('events'),
    addEvent: (event) => {
        const events = DB_SERVICE.getEvents();
        events.push({...event, id: Date.now().toString(), createdAt: Date.now()});
        DB_SERVICE.saveData('events', events);
    },
    updateEvent: (updated) => {
        const events = DB_SERVICE.getEvents().map(e => e.id === updated.id ? {...e, ...updated, updatedAt: Date.now()} : e);
        DB_SERVICE.saveData('events', events);
    },
    deleteEvent: (id) => {
        const events = DB_SERVICE.getEvents().filter(e => e.id !== id);
        DB_SERVICE.saveData('events', events);
    },
    getHolidays: () => DB_SERVICE.loadData('holidays'),
    addHoliday: (date) => {
        const h = DB_SERVICE.getHolidays();
        if(!h.includes(date)) { h.push(date); DB_SERVICE.saveData('holidays', h); }
    },
    deleteHoliday: (date) => {
        const h = DB_SERVICE.getHolidays().filter(d => d !== date);
        DB_SERVICE.saveData('holidays', h);
    }
};

// --- 앱 상태 ---
let currentViewDate = new Date(); // 현재 보고 있는 달
const COLORS = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4'];

// --- 초기화 ---
window.onload = () => {
    renderCalendar();
    initSwipeEvents();
    
    document.getElementById('eventForm').onsubmit = handleEventSubmit;
    document.getElementById('eventRepeat').onchange = (e) => {
        document.getElementById('repeatEndOption').style.display = e.target.value === 'none' ? 'none' : 'block';
    };
};

function renderCalendar() {
    const grid = document.getElementById('calendarGrid');
    const title = document.getElementById('currentMonthYear');
    grid.innerHTML = '';
    
    const year = currentViewDate.getFullYear();
    const month = currentViewDate.getMonth();
    title.innerText = `${year}년 ${month + 1}월`;

    // 헤더 (일~토)
    const days = ['일', '월', '화', '수', '목', '금', '토'];
    days.forEach((d, i) => {
        const div = document.createElement('div');
        div.className = `day-header ${i===0?'sun':i===6?'sat':''}`;
        div.innerText = d;
        grid.appendChild(div);
    });

    const firstDay = new Date(year, month, 1).getDay();
    const lastDate = new Date(year, month + 1, 0).getDate();
    const prevLastDate = new Date(year, month, 0).getDate();
    
    // 캘린더 칸 생성 (6주 고정 42칸)
    const cells = [];
    for(let i = 0; i < 42; i++) {
        let dateNum, isOther = false, dateObj;
        if(i < firstDay) {
            dateNum = prevLastDate - firstDay + i + 1;
            isOther = true;
            dateObj = new Date(year, month - 1, dateNum);
        } else if(i >= firstDay + lastDate) {
            dateNum = i - (firstDay + lastDate) + 1;
            isOther = true;
            dateObj = new Date(year, month + 1, dateNum);
        } else {
            dateNum = i - firstDay + 1;
            dateObj = new Date(year, month, dateNum);
        }
        
        const dateStr = formatDate(dateObj);
        const cell = document.createElement('div');
        cell.className = `day-cell ${isOther ? 'other-month' : ''} ${isToday(dateObj) ? 'today' : ''}`;
        cell.innerHTML = `<div class="day-num">${dateNum}</div>`;
        cell.dataset.date = dateStr;
        cell.onclick = () => openDayModal(dateStr);
        
        // 휴일 표시
        if(DB_SERVICE.getHolidays().includes(dateStr)) {
            cell.innerHTML += `<span class="holiday-label">휴일</span>`;
        }

        const barContainer = document.createElement('div');
        barContainer.className = 'event-bars-container';
        cell.appendChild(barContainer);

        grid.appendChild(cell);
        cells.push({ dateStr, element: cell, bars: [] });
    }

    renderEventBars(cells, year, month);
}

// --- 일정 멀티바 렌더링 로직 ---
function renderEventBars(cells, viewYear, viewMonth) {
    const rawEvents = DB_SERVICE.getEvents();
    const holidays = DB_SERVICE.getHolidays();
    let instances = [];

    // 반복 일정 인스턴스 생성 (현재 보고 있는 달 앞뒤 1주일 포함 범위)
    const rangeStart = new Date(viewYear, viewMonth, -7);
    const rangeEnd = new Date(viewYear, viewMonth + 1, 7);

    rawEvents.forEach(ev => {
        instances = instances.concat(generateInstances(ev, rangeStart, rangeEnd));
    });

    // 시작일 순 정렬
    instances.sort((a, b) => new Date(a.start) - new Date(b.start));

    // 주 단위(7일)로 슬라이싱하여 렌더링
    for(let row = 0; row < 6; row++) {
        const weekCells = cells.slice(row * 7, (row + 1) * 7);
        const weekStart = new Date(weekCells[0].dateStr);
        const weekEnd = new Date(weekCells[6].dateStr);

        // 이번 주에 걸쳐 있는 일정 필터
        const weekEvents = instances.filter(ev => {
            const s = new Date(ev.start);
            const e = new Date(ev.end);
            return s <= weekEnd && e >= weekStart;
        });

        // 레인 배정 (Greedy)
        const lanes = [[], [], []]; // 기본 3레인
        const overflows = new Array(7).fill(0);

        weekEvents.forEach(ev => {
            const s = new Date(ev.start);
            const e = new Date(ev.end);
            const startIdx = Math.max(0, Math.floor((s - weekStart) / 86400000));
            const endIdx = Math.min(6, Math.floor((e - weekStart) / 86400000));

            let assignedLane = -1;
            for(let l=0; l<3; l++) {
                if(!lanes[l].some(occ => startIdx <= occ.end && endIdx >= occ.start)) {
                    assignedLane = l;
                    lanes[l].push({start: startIdx, end: endIdx, ev});
                    break;
                }
            }

            if(assignedLane !== -1) {
                // 바 그리기
                const bar = document.createElement('div');
                bar.className = `event-bar ${s >= weekStart ? 'start-cap' : ''} ${e <= weekEnd ? 'end-cap' : ''}`;
                bar.style.backgroundColor = COLORS[ev.id.length % COLORS.length];
                bar.style.gridColumn = `${startIdx + 1} / span ${endIdx - startIdx + 1}`;
                bar.style.marginTop = `${assignedLane * (22 + 2)}px`;
                bar.style.position = 'absolute';
                bar.style.width = `calc(${(endIdx - startIdx + 1) * 100}% - 4px)`;
                bar.innerText = (ev.time?.start ? ev.time.start + ' ' : '') + ev.title;
                
                weekCells[startIdx].element.querySelector('.event-bars-container').appendChild(bar);
            } else {
                // 3개 초과 시 카운트
                for(let i=startIdx; i<=endIdx; i++) overflows[i]++;
            }
        });

        // 더보기 표시
        overflows.forEach((count, i) => {
            if(count > 0) {
                const more = document.createElement('div');
                more.className = 'more-count';
                more.innerText = `+${count} 더보기`;
                weekCells[i].element.appendChild(more);
            }
        });
    }
}

// --- 반복 일정 인스턴스 생성기 ---
function generateInstances(ev, rangeStart, rangeEnd) {
    const insts = [];
    const start = new Date(ev.startDate);
    const end = new Date(ev.endDate);
    const duration = end - start;
    
    let curr = new Date(start);
    let count = 0;
    const maxSafety = 400; // 무한루프 방지

    while(curr <= rangeEnd && count < maxSafety) {
        if(ev.repeat.untilDate && curr > new Date(ev.repeat.untilDate)) break;
        if(ev.repeat.count && count >= ev.repeat.count) break;

        const instEnd = new Date(curr.getTime() + duration);
        if(instEnd >= rangeStart) {
            insts.push({
                ...ev,
                start: formatDate(curr),
                end: formatDate(instEnd)
            });
        }

        if(ev.repeat.freq === 'none') break;
        
        // 다음 날짜 계산
        if(ev.repeat.freq === 'daily') curr.setDate(curr.getDate() + 1);
        else if(ev.repeat.freq === 'weekly') curr.setDate(curr.getDate() + 7);
        else if(ev.repeat.freq === 'monthlyDate') curr.setMonth(curr.getMonth() + 1);
        else if(ev.repeat.freq === 'monthlyNth') {
            curr.setMonth(curr.getMonth() + 1);
            // n번째 요일 로직 생략(간소화 구현)
        }
        else if(ev.repeat.freq === 'yearly') curr.setFullYear(curr.getFullYear() + 1);
        
        count++;
    }
    return insts;
}

// --- 스와이프 구현 ---
function initSwipeEvents() {
    let startX = 0, startY = 0;
    const grid = document.getElementById('calendarGrid');

    grid.addEventListener('touchstart', e => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });

    grid.addEventListener('touchend', e => {
        const diffX = e.changedTouches[0].clientX - startX;
        const diffY = e.changedTouches[0].clientY - startY;
        
        // 수평 이동이 수직 이동보다 클 때만 월 이동
        if(Math.abs(diffX) > 50 && Math.abs(diffX) > Math.abs(diffY)) {
            if(diffX > 0) moveMonth(-1); // 오른쪽 스와이프 -> 이전달
            else moveMonth(1); // 왼쪽 스와이프 -> 다음달
        }
    });
}

function moveMonth(offset) {
    currentViewDate.setMonth(currentViewDate.getMonth() + offset);
    const grid = document.getElementById('calendarGrid');
    grid.style.opacity = 0;
    setTimeout(() => {
        renderCalendar();
        grid.style.opacity = 1;
    }, 150);
}

// --- 모달 관리 ---
function openDayModal(dateStr) {
    document.getElementById('modalDateTitle').innerText = dateStr;
    document.getElementById('eventStartDate').value = dateStr;
    document.getElementById('eventEndDate').value = dateStr;
    document.getElementById('editEventId').value = '';
    document.getElementById('formTitle').innerText = '일정 추가';
    
    renderDayEventList(dateStr);
    document.getElementById('dayModal').style.display = 'flex';
}

function renderDayEventList(dateStr) {
    const list = document.getElementById('dayEventList');
    list.innerHTML = '';
    
    // 해당 날짜 인스턴스 찾기
    const d = new Date(dateStr);
    const events = DB_SERVICE.getEvents().flatMap(ev => generateInstances(ev, d, d))
                   .filter(inst => new Date(inst.start) <= d && new Date(inst.end) >= d);

    if(events.length === 0) {
        list.innerHTML = '<p style="color:#999; font-size:0.9rem;">일정이 없습니다.</p>';
        return;
    }

    events.forEach(ev => {
        const item = document.createElement('div');
        item.className = 'event-list-item';
        item.innerHTML = `
            <div>
                <strong>${ev.title}</strong><br>
                <small>${ev.startDate} ~ ${ev.endDate}</small>
            </div>
            <div class="btn-group" style="flex:0.5;">
                <button class="btn btn-secondary" onclick="editEvent('${ev.id}')" style="padding:4px;">수정</button>
                <button class="btn btn-danger" onclick="deleteEvent('${ev.id}')" style="padding:4px;">삭제</button>
            </div>
        `;
        list.appendChild(item);
    });
}

function handleEventSubmit(e) {
    e.preventDefault();
    const id = document.getElementById('editEventId').value;
    const startDate = document.getElementById('eventStartDate').value;
    let endDate = document.getElementById('eventEndDate').value;
    
    if(new Date(endDate) < new Date(startDate)) endDate = startDate;

    const eventData = {
        title: document.getElementById('eventTitle').value,
        startDate,
        endDate,
        time: {
            start: document.getElementById('eventStartTime').value || null,
            end: document.getElementById('eventEndTime').value || null
        },
        repeat: {
            freq: document.getElementById('eventRepeat').value,
            untilDate: document.getElementById('eventUntilDate').value || null
        }
    };

    if(id) {
        DB_SERVICE.updateEvent({id, ...eventData});
    } else {
        DB_SERVICE.addEvent(eventData);
    }

    closeModal('dayModal');
    renderCalendar();
    e.target.reset();
}

function deleteEvent(id) {
    if(confirm('일정을 삭제하시겠습니까?')) {
        DB_SERVICE.deleteEvent(id);
        closeModal('dayModal');
        renderCalendar();
    }
}

function editEvent(id) {
    const ev = DB_SERVICE.getEvents().find(e => e.id === id);
    if(!ev) return;
    
    document.getElementById('editEventId').value = ev.id;
    document.getElementById('eventTitle').value = ev.title;
    document.getElementById('eventStartDate').value = ev.startDate;
    document.getElementById('eventEndDate').value = ev.endDate;
    document.getElementById('eventStartTime').value = ev.time?.start || '';
    document.getElementById('eventEndTime').value = ev.time?.end || '';
    document.getElementById('eventRepeat').value = ev.repeat.freq;
    document.getElementById('eventUntilDate').value = ev.repeat.untilDate || '';
    document.getElementById('formTitle').innerText = '일정 수정';
    document.getElementById('repeatEndOption').style.display = ev.repeat.freq === 'none' ? 'none' : 'block';
}

// --- 관리자 기능 ---
function openAdminModal() {
    renderHolidayList();
    document.getElementById('adminModal').style.display = 'flex';
}

function handleAddHoliday() {
    const date = document.getElementById('holidayDate').value;
    if(date) {
        DB_SERVICE.addHoliday(date);
        renderHolidayList();
        renderCalendar();
    }
}

function renderHolidayList() {
    const list = document.getElementById('holidayList');
    list.innerHTML = '';
    DB_SERVICE.getHolidays().forEach(d => {
        const item = document.createElement('div');
        item.style = 'display:flex; justify-content:space-between; padding:8px; border-bottom:1px solid #eee;';
        item.innerHTML = `<span>${d}</span> <button onclick="removeHoliday('${d}')" style="color:red; border:none; background:none;">삭제</button>`;
        list.appendChild(item);
    });
}

function removeHoliday(d) {
    DB_SERVICE.deleteHoliday(d);
    renderHolidayList();
    renderCalendar();
}

// --- 유틸리티 ---
function formatDate(d) {
    return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
}
function isToday(d) { return formatDate(d) === formatDate(new Date()); }
function goToday() { currentViewDate = new Date(); renderCalendar(); }
function closeModal(id) { document.getElementById(id).style.display = 'none'; }

// ESC로 모달 닫기
window.onkeydown = (e) => { if(e.key === 'Escape') { closeModal('dayModal'); closeModal('adminModal'); } };
</script>

</body>
</html>