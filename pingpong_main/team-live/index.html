<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸ“ ê²½ê¸° ì§„í–‰ (team-live)</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --bd:#e6e8ef;
      --txt:#0f172a; --mut:#64748b; --r:16px;
      --accent:#2563eb; --ok:#16a34a; --danger:#ef4444; --warn:#f59e0b;
      --shadow:0 10px 28px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;background:var(--bg);color:var(--txt)}
    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    h2{margin:6px 0 12px;font-size:16px;font-weight:950;text-align:center}

    .card{background:var(--card);border:1px solid var(--bd);border-radius:var(--r);box-shadow:var(--shadow);padding:12px;margin-bottom:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}
    .row.between{justify-content:space-between}
    .input, select{
      padding:10px 12px;border:1px solid var(--bd);border-radius:12px;background:#fff;font-size:14px
    }
    .btn{
      padding:10px 14px;border:1px solid rgba(37,99,235,.25);
      background:linear-gradient(180deg,#2b74ff,#2563eb);
      color:#fff;border-radius:12px;cursor:pointer;font-weight:950;
    }
    .btn.secondary{background:#fff;color:#0f172a;border:1px solid var(--bd)}
    .btn.ok{background:linear-gradient(180deg,#22c55e,#16a34a);border:1px solid rgba(22,163,74,.25)}
    .btn.danger{background:linear-gradient(180deg,#ff5a5a,#ef4444);border:1px solid rgba(239,68,68,.25)}
    .btn.warn{background:linear-gradient(180deg,#fbbf24,#f59e0b);border:1px solid rgba(245,158,11,.25)}

    .mut{color:var(--mut);font-weight:750;font-size:12px;margin-top:8px;text-align:center}
    .err{color:#b91c1c;font-weight:950;text-align:center}
    .oktxt{color:#166534;font-weight:950;text-align:center}

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){ .grid2{grid-template-columns:1fr} }

    .box{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:12px}
    .box h3{margin:0 0 10px;font-size:14px;font-weight:1000}

    .chip{display:inline-flex;align-items:center;padding:6px 10px;border:1px solid var(--bd);
      border-radius:999px;background:#f8fafc;margin:4px 6px 0 0;font-weight:900}
    .pill{padding:6px 10px;border:1px solid var(--bd);border-radius:999px;background:#f8fafc;font-weight:900}

    .teams{display:flex;flex-direction:column;gap:10px}
    .team{border:1px solid var(--bd);border-radius:14px;padding:10px;background:#f8fafc}
    .team .tline{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
    .team .name{font-weight:950}
    .team .meta{color:var(--mut);font-weight:800;font-size:12px}

    table{width:100%;border-collapse:separate;border-spacing:0}
    th,td{border-bottom:1px solid var(--bd);padding:10px 8px;text-align:center;font-size:13px}
    th{position:sticky;top:0;background:#f2f4f8;z-index:1;font-weight:950}
    tr:last-child td{border-bottom:none}

    .matchCard{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:10px;margin-bottom:10px}
    .matchTop{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;font-weight:950}
    .matchMid{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;margin-top:8px}
    .side{border:1px solid var(--bd);border-radius:12px;padding:10px;background:#f8fafc;font-weight:900;line-height:1.45}
    .vs{font-weight:1000;color:#ef4444;text-align:center}

    .scoreRow{display:flex;gap:8px;justify-content:center;align-items:center;margin-top:10px;flex-wrap:wrap}
    .scoreInput{width:56px;padding:8px 6px;text-align:center;font-weight:900;font-size:13px}
    .colon{font-weight:900;font-size:18px;margin:0 6px}
    .small{font-size:12px;color:var(--mut);font-weight:800}

    .bracket{display:flex;flex-direction:column;gap:10px}
    .bmatch{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:10px}
    .bmatch .line{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}

    .divider{height:1px;background:var(--bd);margin:10px 0}
    .hidden{display:none !important}

    /* ë‹¨ì²´ì „ ë³´ë“œ(ë‹¨/ë³µ) */
    .board{border:1px dashed #cbd5e1;background:#f8fafc;border-radius:12px;padding:10px;margin-top:10px}
    .boardTop{display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap;align-items:center}
    .boardTitle{font-weight:1000}
    .pickRow{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center;margin-top:8px}
    .pickRow select{min-width:120px}
    .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid var(--bd);border-radius:999px;background:#fff;font-weight:950}
  </style>
</head>

<body>
  <div class="wrap">
    <h2>ğŸ“ ê²½ê¸° ì§„í–‰ (team-live)</h2>

    <!-- ìƒë‹¨: ëª¨ë“œ/ì„¸íŠ¸ë°©ì‹/ë‹¨ì²´ì „ ì„¤ì • í‘œì‹œ -->
    <div class="card">
      <div class="row" style="gap:8px">
        <span class="pill" id="modePill">ëª¨ë“œ: -</span>
        <span class="pill" id="rulePill">-</span>
        <span class="pill hidden" id="teamRulePill">-</span>

        <label style="font-weight:950">
          ì„¸íŠ¸ ê·œì¹™
          <select id="bestOf" class="input">
            <option value="5" selected>5íŒ 3ì„ ìŠ¹</option>
            <option value="3">3íŒ 2ì„ ìŠ¹</option>
          </select>
        </label>
      </div>
      <div class="mut" id="status">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
    </div>

    <div class="grid2">
      <div class="box">
        <h3 id="leftTitle">í˜„ì¬ êµ¬ì„±</h3>
        <div class="teams" id="teamsBox"><div class="mut">ë°ì´í„° ì—†ìŒ</div></div>
      </div>
      <div class="box" id="groupsWrap">
        <h3>ì¡° êµ¬ì„±</h3>
        <div id="groupsBox"><div class="mut">ì¡° ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¦¬ê·¸/í† ë„ˆë¡œ ì§„í–‰í•˜ì‹œë©´ ë©ë‹ˆë‹¤.</div></div>
      </div>
    </div>

    <!-- ì§„í–‰ ë°©ì‹(ê°œì¸ì „ë§Œ ì„ íƒ ê°€ëŠ¥í•˜ê²Œ / ë‹¨ì²´ì „ì€ íŒ€ì „ ë¦¬ê·¸/í† ë„ˆ/ì¡°+í† ë„ˆ ìœ ì§€) -->
    <div class="card" id="formatCard">
      <div class="row">
        <label style="font-weight:950">
          ì§„í–‰ ë°©ì‹
          <select id="format" class="input">
            <option value="league">ë¦¬ê·¸ì „(ì „ì²´ í’€ë¦¬ê·¸)</option>
            <option value="tournament">í† ë„ˆë¨¼íŠ¸(ë‹¨íŒ)</option>
            <option value="groups_to">ì¡°ë³„ë¦¬ê·¸ + í† ë„ˆë¨¼íŠ¸</option>
          </select>
        </label>

        <label style="font-weight:950" id="advWrap">
          ì¡°ë³„ë¦¬ê·¸ â†’ í† ë„ˆ ì§„ì¶œ(ì¡°ë‹¹)
          <select id="advancePerGroup" class="input">
            <option value="1">1ìœ„ë§Œ</option>
            <option value="2" selected>1Â·2ìœ„</option>
            <option value="3">1Â·2Â·3ìœ„</option>
          </select>
        </label>

        <button class="btn ok" id="buildBtn">ëŒ€ì§„ ìƒì„±</button>
        <button class="btn secondary" id="resetRunBtn">ì§„í–‰ ë°ì´í„° ì´ˆê¸°í™”</button>
      </div>
      <div class="mut" id="formatHint">-</div>
    </div>

    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">ìˆœìœ„í‘œ</div>
      <div id="standingsBox"><div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div></div>
    </div>

    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">ê²½ê¸° ì§„í–‰</div>
      <div id="matchesBox"><div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div></div>
    </div>

    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">í† ë„ˆë¨¼íŠ¸</div>
      <div id="bracketBox"><div class="mut">í† ë„ˆë¨¼íŠ¸ ì„ íƒ(ë˜ëŠ” ì¡°ë³„+í† ë„ˆ) ì‹œ í‘œì‹œë©ë‹ˆë‹¤.</div></div>
    </div>
  </div>

  <script type="module">
    import { db, auth } from "../firebase.js";
    import { ref, onValue, set, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
    import { signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

    const $ = (id)=>document.getElementById(id);
    const PATH = { current:"teamLive/current", run:"teamLive/run" };

    const esc = (s)=>String(s??"")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");

    const nowId = ()=> `M${Date.now()}_${Math.random().toString(16).slice(2,8)}`;

    let current = null;
    let run = null;

    function setStatus(msg, cls="mut"){
      const el = $("status");
      el.className = cls;
      el.textContent = msg;
    }

    function bestOfInfo(bestOf){
      const need = Math.ceil(bestOf/2);
      return { bestOf, need, label: `BO${bestOf} (${bestOf}íŒ ${need}ì„ ìŠ¹)` };
    }

    function teamById(id){
      return (current?.teams||[]).find(t=>t.id===id) || null;
    }

    function playerTag(p){
      const busu = p?.busu ?? p?.busuText ?? p?.grade ?? "";
      return `${p?.name ?? ""}${busu ? `(${busu})` : ""}`;
    }

    function teamLabel(team){
      const names = (team.players||[]).map(p=>playerTag(p)).join(" Â· ");
      return `${team.id}: ${names}`;
    }

    // ----- ì„¸íŠ¸ ìŠ¤ì½”ì–´ ê²€ì¦ (bestOf=3/5)
    function validateMatchSets(aSets, bSets, bestOf){
      if(!Number.isInteger(aSets) || !Number.isInteger(bSets)) return {ok:false, msg:"ì •ìˆ˜ë¡œ ì…ë ¥"};
      if(aSets<0 || bSets<0) return {ok:false, msg:"0 ì´ìƒ"};
      if(aSets===bSets) return {ok:false, msg:"ë™ì  ë¶ˆê°€"};
      if(aSets>bestOf || bSets>bestOf) return {ok:false, msg:`ìµœëŒ€ ${bestOf}ì„¸íŠ¸`};

      const need = Math.ceil(bestOf/2);
      const w = Math.max(aSets,bSets);
      const l = Math.min(aSets,bSets);

      if(w < need) return {ok:false, msg:`ìŠ¹ìëŠ” ìµœì†Œ ${need}ì„¸íŠ¸ í•„ìš”`};
      if(w + l > bestOf) return {ok:false, msg:`í•©ê³„ëŠ” ${bestOf} ì´í•˜ì—¬ì•¼ í•¨`};

      return {ok:true};
    }
    function winnerFromSets(aSets,bSets){ return (aSets>bSets) ? "A" : "B"; }

    // ----- schedule (íŒ€ vs íŒ€ / ê°œì¸ì „ ê³µìš©)
    function roundRobin(ids){
      const ms = [];
      for(let i=0;i<ids.length;i++){
        for(let j=i+1;j<ids.length;j++){
          ms.push({ id: nowId(), type:"match", group:null, A:ids[i], B:ids[j], score:null, done:false });
        }
      }
      return ms;
    }
    function groupRoundRobin(groupsObj){
      const ms = [];
      for(const [g, ids] of Object.entries(groupsObj||{})){
        const rr = roundRobin(ids);
        rr.forEach(m=>m.group=g);
        ms.push(...rr);
      }
      return ms;
    }
    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // ----- bracket (ê¸°ì¡´ ìœ ì§€)
    function buildBracketFromPositions(seeded){
      const pow2 = seeded.length;
      const first = [];
      for(let i=0;i<pow2/2;i++){
        const A = seeded[i];
        const B = seeded[pow2-1-i];
        first.push({ id: nowId(), round:1, A, B, score:null, done:false, winner:null });
      }
      first.forEach(m=>{
        if(m.A && !m.B){ m.done=true; m.winner=m.A; m.score={aSets:0,bSets:0,bye:true}; }
        else if(!m.A && m.B){ m.done=true; m.winner=m.B; m.score={aSets:0,bSets:0,bye:true}; }
      });

      const rounds = [first];
      let curCount = first.length;
      while(curCount > 1){
        curCount = Math.ceil(curCount/2);
        rounds.push(Array.from({length: curCount}, ()=>({
          id: nowId(), round: rounds.length+1, A:null, B:null, score:null, done:false, winner:null
        })));
      }
      return rounds;
    }

    function propagateBracket(rounds){
      for(let r=0;r<rounds.length-1;r++){
        const cur = rounds[r];
        const next = rounds[r+1];
        for(let i=0;i<next.length;i++){
          const m1 = cur[i*2];
          const m2 = cur[i*2+1];
          next[i].A = m1 ? (m1.winner||null) : null;
          next[i].B = m2 ? (m2.winner||null) : null;

          const m = next[i];
          if(m.A && !m.B){
            m.done=true; m.winner=m.A; m.score={aSets:0,bSets:0,bye:true};
          }else if(!m.A && m.B){
            m.done=true; m.winner=m.B; m.score={aSets:0,bSets:0,bye:true};
          }else{
            if(!m.done && (m.score?.bye)) m.score=null;
          }
        }
      }
    }

    function pickQualifiers(groupsObj, standingsByGroup, advancePerGroup){
      const adv = advancePerGroup|0;
      const meta = [];
      for(const [g, ids] of Object.entries(groupsObj||{})){
        const st = standingsByGroup[g] || [];
        const take = Math.min(adv, st.length);
        for(let i=0;i<take;i++) meta.push({ teamId: st[i].id, group:g, rank:i+1 });
      }
      meta.sort((a,b)=> (a.rank-b.rank) || String(a.group).localeCompare(String(b.group)));
      return { seeds: meta.map(x=>x.teamId), meta };
    }

    function buildSeedPositions(meta, randomByes=true){
      const n = meta.length;
      const pow2 = 1 << Math.ceil(Math.log2(Math.max(2, n)));
      const byes = pow2 - n;

      const seeded = Array(pow2).fill(null);
      let pairSlots = Array.from({length: pow2/2}, (_,i)=>i);

      let remain = [...meta].sort((a,b)=>{
        if(a.rank !== b.rank) return a.rank - b.rank;
        return String(a.group).localeCompare(String(b.group));
      });

      if(randomByes && byes > 0){
        const picked = shuffle(remain).slice(0, byes);
        const byeSet = new Set(picked.map(x=>x.teamId));
        remain = remain.filter(x=>!byeSet.has(x.teamId));

        pairSlots = shuffle(pairSlots);
        picked.forEach((p, k)=>{
          const ps = pairSlots[k];
          if(Math.random() < 0.5){
            seeded[ps] = p.teamId;
            seeded[pow2-1-ps] = null;
          }else{
            seeded[ps] = null;
            seeded[pow2-1-ps] = p.teamId;
          }
        });

        pairSlots = pairSlots.slice(byes);
      }

      while(remain.length){
        const best = remain.shift();
        let oppIndex = -1;
        for(let k=remain.length-1;k>=0;k--){
          if(remain[k].group !== best.group){ oppIndex = k; break; }
        }
        const opp = (oppIndex>=0) ? remain.splice(oppIndex,1)[0] : (remain.pop() || null);

        const ps = pairSlots.shift();
        if(ps === undefined) break;

        seeded[ps] = best.teamId;
        seeded[pow2-1-ps] = opp ? opp.teamId : null;
      }
      return seeded;
    }

    function arraysEqual(a,b){
      if(!a || !b) return false;
      if(a.length !== b.length) return false;
      for(let i=0;i<a.length;i++) if(a[i] !== b[i]) return false;
      return true;
    }

    // =========================
    // âœ… ë‹¨ì²´ì „(íŒ€ì „) ë³´ë“œ êµ¬ì„±
    // =========================
    function getTeamMatchRule(){
      const cfg = current?.config || {};
      const teamCfg = cfg.team || {};
      const singlesCount = Math.max(0, Math.floor(Number(teamCfg.singlesCount ?? 0)));
      const doublesCount = Math.max(0, Math.floor(Number(teamCfg.doublesCount ?? 0)));
      const label = teamCfg.label || `${singlesCount}ë‹¨ ${doublesCount}ë³µ`;
      return { singlesCount, doublesCount, label };
    }

    function makeDefaultBoards(){
      const { singlesCount, doublesCount } = getTeamMatchRule();
      const boards = [];
      for(let i=1;i<=singlesCount;i++){
        boards.push({
          id: nowId(),
          kind: "S",
          no: i,
          aPlayers: [], bPlayers: [],
          score: null,
          done: false
        });
      }
      for(let i=1;i<=doublesCount;i++){
        boards.push({
          id: nowId(),
          kind: "D",
          no: i,
          aPlayers: [], bPlayers: [],
          score: null,
          done: false
        });
      }
      return boards;
    }

    function boardTitle(b){
      return b.kind==="S" ? `ë‹¨ì‹ ${b.no}` : `ë³µì‹ ${b.no}`;
    }

    function calcTeamMatchScore(match){
      // boards ê¸°ì¤€ ìŠ¹ìˆ˜ ì§‘ê³„
      const boards = match?.boards || [];
      let aWin = 0, bWin = 0;
      for(const b of boards){
        if(!b?.done || !b?.score || b.score?.bye) continue;
        const w = winnerFromSets(b.score.aSets|0, b.score.bSets|0);
        if(w==="A") aWin++;
        else bWin++;
      }
      return { aWin, bWin };
    }

    // =========================
    // âœ… standings
    // ê°œì¸ì „/íŒ€ì „ ê³µìš©: ìŠ¹ â†’ ì„¸íŠ¸ë“ì‹¤ â†’ ì„¸íŠ¸ë“ (íŒ€ì „ì€ â€œë³´ë“œìŠ¹â€ì„ winìœ¼ë¡œ ë´„)
    // =========================
    function computeStandings(matchList, scopedIds, mode){
      const map = new Map();
      const ensure = (id)=>{
        if(!map.has(id)){
          map.set(id, { id, played:0, win:0, loss:0, sw:0, sl:0, sd:0 });
        }
        return map.get(id);
      };
      (scopedIds||[]).forEach(id=>ensure(id));

      for(const m of (matchList||[])){
        if(!m.done) continue;
        if(!m.A || !m.B) continue;

        const A = ensure(m.A);
        const B = ensure(m.B);

        if(mode==="team"){
          // íŒ€ì „: boardsë¡œ ìŠ¹íŒ¨/ë“ì‹¤ ì§‘ê³„ (sw/sl = ë³´ë“œ ë“/ì‹¤)
          const s = m.teamScore || calcTeamMatchScore(m);
          const a = s.aWin|0, b = s.bWin|0;

          A.played++; B.played++;
          A.sw += a; A.sl += b;
          B.sw += b; B.sl += a;

          if(a===b) continue; // ë™ì ì´ë©´ ìŠ¹/íŒ¨ ë¯¸ë°˜ì˜(ì›í•˜ì‹œë©´ ê²°ì •ì „ ê°•ì œ ê°€ëŠ¥)
          if(a>b){ A.win++; B.loss++; }
          else { B.win++; A.loss++; }

        }else{
          // ê°œì¸ì „(ê¸°ì¡´): set score
          if(!m.score || m.score.bye) continue;
          const a = m.score.aSets|0;
          const b = m.score.bSets|0;

          A.played++; B.played++;
          A.sw += a; A.sl += b;
          B.sw += b; B.sl += a;

          const w = winnerFromSets(a,b);
          if(w==="A"){ A.win++; B.loss++; }
          else { B.win++; A.loss++; }
        }
      }

      for(const v of map.values()) v.sd = v.sw - v.sl;

      const arr = [...map.values()];
      arr.sort((x,y)=>{
        if(y.win !== x.win) return y.win - x.win;
        if(y.sd !== x.sd) return y.sd - x.sd;
        if(y.sw !== x.sw) return y.sw - x.sw;
        return x.id.localeCompare(y.id);
      });
      return arr;
    }

    // =========================
    // render current (íŒ€/ê°œì¸ ìë™)
    // =========================
    function renderCurrent(){
      const teamsBox = $("teamsBox");
      const groupsBox = $("groupsBox");
      const groupsWrap = $("groupsWrap");

      if(!current){
        teamsBox.innerHTML = `<div class="mut">current ì—†ìŒ</div>`;
        groupsBox.innerHTML = `<div class="mut">-</div>`;
        return;
      }

      const mode = current?.config?.mode || "team";
      $("modePill").textContent = `ëª¨ë“œ: ${mode==="team" ? "ë‹¨ì²´ì „" : "ê°œì¸ì „"}`;

      if(mode==="team"){
        $("leftTitle").textContent = "í˜„ì¬ íŒ€ êµ¬ì„±";
        const tRule = getTeamMatchRule();
        $("teamRulePill").classList.remove("hidden");
        $("teamRulePill").textContent = `íŒ€ì „: ${tRule.label} (ë‹¨ì‹ ${tRule.singlesCount} / ë³µì‹ ${tRule.doublesCount})`;

        const totalBoards = tRule.singlesCount + tRule.doublesCount;
        if(totalBoards>0 && totalBoards%2===0){
          $("rulePill").textContent = `ì£¼ì˜: ì´ ë§¤ì¹˜ìˆ˜(${totalBoards})ê°€ ì§ìˆ˜ë¼ íŒ€ì „ ë™ì  ê°€ëŠ¥`;
        }else{
          $("rulePill").textContent = `íŒ€ì „ì€ ë³´ë“œ ìŠ¹ìˆ˜ë¡œ ìŠ¹íŒ¨ ê²°ì •`;
        }

        const teams = current.teams || [];
        teamsBox.innerHTML = teams.length
          ? teams.map(t=>`
            <div class="team">
              <div class="tline">
                <div class="name">${esc(teamLabel(t))}</div>
                <div class="meta">í•© ${esc(t.sum ?? "")}</div>
              </div>
            </div>
          `).join("")
          : `<div class="mut">íŒ€ ë°ì´í„° ì—†ìŒ</div>`;

      }else{
        $("leftTitle").textContent = "ì°¸ê°€ì";
        $("teamRulePill").classList.add("hidden");
        $("rulePill").textContent = `ê°œì¸ì „ì€ â€œì„¸íŠ¸ ìŠ¤ì½”ì–´â€ë¡œ ìˆœìœ„ ì‚°ì •`;

        const ps = current.participants || [];
        teamsBox.innerHTML = ps.length
          ? `<div style="text-align:center">${ps.map(p=>`<span class="chip">${esc(playerTag(p))}</span>`).join("")}</div>`
          : `<div class="mut">participants ì—†ìŒ (team-make ì €ì¥ í™•ì¸)</div>`;
      }

      const groups = current.groups || {};
      const keys = Object.keys(groups);
      if(!keys.length){
        groupsWrap.classList.remove("hidden");
        groupsBox.innerHTML = `<div class="mut">ì¡° ë°ì´í„° ì—†ìŒ</div>`;
      }else{
        groupsWrap.classList.remove("hidden");
        groupsBox.innerHTML = keys.sort().map(g=>{
          const ids = groups[g] || [];
          return `
            <div style="margin-bottom:10px">
              <div style="font-weight:1000;margin-bottom:6px">${esc(g)}ì¡°</div>
              <div>
                ${ids.map(id=>{
                  const t = teamById(id);
                  return `<span class="chip">${esc(t ? teamLabel(t) : id)}</span>`;
                }).join("")}
              </div>
            </div>
          `;
        }).join("");
      }
    }

    // =========================
    // standings + bracket render
    // =========================
    function standingsTable(title, st, mode){
      const isTeam = (mode==="team");
      return `
        <div class="box" style="box-shadow:none">
          <div style="font-weight:1000;margin-bottom:8px">${esc(title)} ìˆœìœ„</div>
          <div style="overflow:auto;border:1px solid var(--bd);border-radius:12px">
            <table>
              <thead>
                <tr>
                  <th>ìˆœìœ„</th><th>${isTeam ? "íŒ€" : "ì°¸ê°€ì"}</th><th>ê²½ê¸°</th><th>ìŠ¹</th><th>íŒ¨</th>
                  <th>${isTeam ? "ë³´ë“œë“" : "ì„¸íŠ¸ë“"}</th><th>${isTeam ? "ë³´ë“œì‹¤" : "ì„¸íŠ¸ì‹¤"}</th><th>${isTeam ? "ë³´ë“œë“ì‹¤" : "ì„¸íŠ¸ë“ì‹¤"}</th>
                </tr>
              </thead>
              <tbody>
                ${st.map((r,i)=>{
                  const t = teamById(r.id);
                  const label = t ? teamLabel(t) : r.id;
                  return `
                    <tr>
                      <td>${i+1}</td>
                      <td style="text-align:left;font-weight:900">${esc(label)}</td>
                      <td>${r.played}</td>
                      <td>${r.win}</td>
                      <td>${r.loss}</td>
                      <td>${r.sw}</td>
                      <td>${r.sl}</td>
                      <td>${r.sd}</td>
                    </tr>
                  `;
                }).join("") || `<tr><td colspan="8" class="mut">ë°ì´í„° ì—†ìŒ</td></tr>`}
              </tbody>
            </table>
          </div>
          <div class="small" style="margin-top:8px">
            ë™ë¥  ì •ë ¬: ìŠ¹ â†’ ë“ì‹¤ â†’ ë“
          </div>
        </div>
      `;
    }

    function renderStandings(){
      const box = $("standingsBox");
      if(!run || !current){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div>`;
        return;
      }

      const mode = current?.config?.mode || "team";
      const format = run.settings?.format || "league";
      const matches = run.matches || [];

      const ids = (mode==="team")
        ? (current.teams||[]).map(t=>t.id)
        : (current.participants||[]).map(p=>p.name); // ê°œì¸ì „ì€ id = name ë¡œ ì”€

      const groupsObj = current.groups || {};

      if(format==="league" || format==="tournament"){
        const st = computeStandings(matches, ids, mode);
        box.innerHTML = standingsTable("ì „ì²´", st, mode);
        return;
      }

      const out = [];
      const standingsByGroup = {};
      for(const [g, gIds] of Object.entries(groupsObj)){
        const gMatches = matches.filter(m=>m.group===g);
        const st = computeStandings(gMatches, gIds, mode);
        standingsByGroup[g] = st;
        out.push(`<div style="margin-bottom:10px">${standingsTable(`${g}ì¡°`, st, mode)}</div>`);
      }
      box.innerHTML = out.join("") || `<div class="mut">ì¡°ë³„ ìˆœìœ„ ì—†ìŒ</div>`;

      const adv = run.settings?.advancePerGroup|0;
      if(adv>0){
        const q = pickQualifiers(groupsObj, standingsByGroup, adv);
        const seedsArr = q.seeds || [];
        if(seedsArr.length){
          box.innerHTML += `
            <div class="card" style="margin-top:10px;box-shadow:none">
              <div style="font-weight:1000;text-align:center;margin-bottom:8px">í† ë„ˆ ì§„ì¶œ(ì‹œë“œ)</div>
              <div style="text-align:center">
                ${seedsArr.map(id=>{
                  const t = teamById(id);
                  return `<span class="chip">${esc(t ? teamLabel(t) : id)}</span>`;
                }).join("")}
              </div>
              <div class="mut">â€» ì¡°ë³„ ê²°ê³¼ì— ë”°ë¼ í† ë„ˆ ì‹œë“œëŠ” ìë™ ê°±ì‹ ë©ë‹ˆë‹¤.</div>
            </div>
          `;
        }
      }
    }

    // =========================
    // matches render
    // - ê°œì¸ì „: ê¸°ì¡´ ë°©ì‹(ì„¸íŠ¸ ì…ë ¥)
    // - ë‹¨ì²´ì „: íŒ€vsíŒ€ 1ê²½ê¸° ì•ˆì— ë‹¨/ë³µ ë³´ë“œ ì…ë ¥
    // =========================
    function renderMatches(){
      const box = $("matchesBox");
      if(!run || !current || !(run.matches||[]).length){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      const mode = current?.config?.mode || "team";
      const { bestOf, need, label } = bestOfInfo(parseInt($("bestOf").value, 10) || 5);

      const ms = run.matches || [];

      if(mode !== "team"){
        // ========= ê°œì¸ì „(ê¸°ì¡´ ì¹´ë“œ) =========
        box.innerHTML = ms.map((m, idx)=>{
          const aName = m.A || "A";
          const bName = m.B || "B";
          const sTxt = m.score && !m.score.bye ? `${m.score.aSets}:${m.score.bSets}` : (m.score?.bye ? "BYE" : "-");

          return `
            <div class="matchCard">
              <div class="matchTop">
                <div>#${idx+1} ${m.group ? `(${esc(m.group)}ì¡°)` : ""}</div>
                <div class="small">ê²°ê³¼: <b>${esc(sTxt)}</b> Â· ${esc(label)} ${m.done ? "âœ…" : ""}</div>
              </div>

              <div class="matchMid">
                <div class="side">${esc(aName)}</div>
                <div class="vs">VS</div>
                <div class="side">${esc(bName)}</div>
              </div>

              <div class="scoreRow">
                <input class="input scoreInput" type="number" min="0" step="1" id="a_${m.id}" value="${m.score && !m.score.bye ? m.score.aSets : ""}">
                <span class="colon">:</span>
                <input class="input scoreInput" type="number" min="0" step="1" id="b_${m.id}" value="${m.score && !m.score.bye ? m.score.bSets : ""}">
                <span class="small">ìµœëŒ€ ${bestOf}ì„¸íŠ¸ / ${need}ì„ ìŠ¹</span>
                <button class="btn ok" data-mid="${m.id}">ì €ì¥</button>
                <button class="btn secondary" data-clear="${m.id}">ì§€ìš°ê¸°</button>
              </div>

              <div class="mut" id="msg_${m.id}" style="margin-top:6px"></div>
            </div>
          `;
        }).join("");

        box.querySelectorAll("button[data-mid]").forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            await saveMatchScore(btn.getAttribute("data-mid"));
          });
        });
        box.querySelectorAll("button[data-clear]").forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            await clearMatchScore(btn.getAttribute("data-clear"));
          });
        });

        return;
      }

      // ========= ë‹¨ì²´ì „(íŒ€ì „) =========
      const tRule = getTeamMatchRule();

      box.innerHTML = ms.map((m, idx)=>{
        const A = teamById(m.A);
        const B = teamById(m.B);
        const aName = A ? teamLabel(A) : (m.A||"BYE");
        const bName = B ? teamLabel(B) : (m.B||"BYE");

        const boards = m.boards || [];
        const tScore = m.teamScore || calcTeamMatchScore(m);
        const tTxt = `${tScore.aWin}:${tScore.bWin}`;

        return `
          <div class="matchCard">
            <div class="matchTop">
              <div>#${idx+1} ${m.group ? `(${esc(m.group)}ì¡°)` : ""}</div>
              <div class="small">
                íŒ€ìŠ¤ì½”ì–´: <b>${esc(tTxt)}</b> Â· ${esc(tRule.label)} Â· ${esc(label)} ${m.done ? "âœ…" : ""}
              </div>
            </div>

            <div class="matchMid">
              <div class="side">${esc(aName)}</div>
              <div class="vs">VS</div>
              <div class="side">${esc(bName)}</div>
            </div>

            <div class="mut" style="margin-top:8px">
              ì•„ë˜ì—ì„œ <b>ë‹¨ì‹ ${tRule.singlesCount}ê°œ</b> / <b>ë³µì‹ ${tRule.doublesCount}ê°œ</b> ê²°ê³¼ë¥¼ ëª¨ë‘ ì…ë ¥í•©ë‹ˆë‹¤.
            </div>

            ${(boards||[]).map((b, bi)=>{
              const title = boardTitle(b);
              const sTxt = b.score ? `${b.score.aSets}:${b.score.bSets}` : "-";

              // ì„ ìˆ˜ ì„ íƒ ì˜µì…˜
              const aPlayers = (A?.players||[]).map(p=>p.name);
              const bPlayers = (B?.players||[]).map(p=>p.name);

              const multiA = (b.kind==="D");
              const multiB = (b.kind==="D");

              const aSel1 = b.aPlayers?.[0] || "";
              const aSel2 = b.aPlayers?.[1] || "";
              const bSel1 = b.bPlayers?.[0] || "";
              const bSel2 = b.bPlayers?.[1] || "";

              return `
                <div class="board">
                  <div class="boardTop">
                    <div class="boardTitle">${esc(title)}</div>
                    <div class="small">ê²°ê³¼: <b>${esc(sTxt)}</b> Â· ìµœëŒ€ ${bestOf}ì„¸íŠ¸ / ${need}ì„ ìŠ¹ ${b.done ? "âœ…" : ""}</div>
                  </div>

                  <div class="pickRow">
                    <span class="tag">A</span>
                    <select class="input" id="ap1_${b.id}">
                      <option value="">ì„ ìˆ˜ ì„ íƒ</option>
                      ${aPlayers.map(n=>`<option ${n===aSel1?"selected":""} value="${esc(n)}">${esc(n)}</option>`).join("")}
                    </select>
                    ${multiA ? `
                      <select class="input" id="ap2_${b.id}">
                        <option value="">(ë³µì‹2) ì„ íƒ</option>
                        ${aPlayers.map(n=>`<option ${n===aSel2?"selected":""} value="${esc(n)}">${esc(n)}</option>`).join("")}
                      </select>
                    ` : ``}

                    <span class="tag">B</span>
                    <select class="input" id="bp1_${b.id}">
                      <option value="">ì„ ìˆ˜ ì„ íƒ</option>
                      ${bPlayers.map(n=>`<option ${n===bSel1?"selected":""} value="${esc(n)}">${esc(n)}</option>`).join("")}
                    </select>
                    ${multiB ? `
                      <select class="input" id="bp2_${b.id}">
                        <option value="">(ë³µì‹2) ì„ íƒ</option>
                        ${bPlayers.map(n=>`<option ${n===bSel2?"selected":""} value="${esc(n)}">${esc(n)}</option>`).join("")}
                      </select>
                    ` : ``}
                  </div>

                  <div class="scoreRow">
                    <input class="input scoreInput" type="number" min="0" step="1" id="sa_${b.id}" value="${b.score ? b.score.aSets : ""}">
                    <span class="colon">:</span>
                    <input class="input scoreInput" type="number" min="0" step="1" id="sb_${b.id}" value="${b.score ? b.score.bSets : ""}">
                    <button class="btn ok" data-bsave="${m.id}|${b.id}">ë³´ë“œ ì €ì¥</button>
                    <button class="btn secondary" data-bclear="${m.id}|${b.id}">ë³´ë“œ ì§€ìš°ê¸°</button>
                  </div>

                  <div class="mut" id="bmsg_${b.id}" style="margin-top:6px"></div>
                </div>
              `;
            }).join("")}

            <div class="divider"></div>
            <div class="row">
              <button class="btn ok" data-finish="${m.id}">ì´ ê²½ê¸°(íŒ€ì „) ì™„ë£Œ ì²˜ë¦¬</button>
              <button class="btn secondary" data-unfinish="${m.id}">ì™„ë£Œ í•´ì œ</button>
            </div>

            <div class="mut" id="tmsg_${m.id}" style="margin-top:6px"></div>
          </div>
        `;
      }).join("");

      // ë³´ë“œ ì €ì¥/ì§€ìš°ê¸°
      box.querySelectorAll("button[data-bsave]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const [matchId, boardId] = btn.getAttribute("data-bsave").split("|");
          await saveTeamBoard(matchId, boardId);
        });
      });
      box.querySelectorAll("button[data-bclear]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const [matchId, boardId] = btn.getAttribute("data-bclear").split("|");
          await clearTeamBoard(matchId, boardId);
        });
      });

      // ê²½ê¸° ì™„ë£Œ/í•´ì œ
      box.querySelectorAll("button[data-finish]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          await finishTeamMatch(btn.getAttribute("data-finish"), true);
        });
      });
      box.querySelectorAll("button[data-unfinish]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          await finishTeamMatch(btn.getAttribute("data-unfinish"), false);
        });
      });
    }

    // =========================
    // bracket render (ê°œì¸ì „ë§Œ ì‚¬ìš© / íŒ€ì „ì€ ì¼ë‹¨ íŒ€ í† ë„ˆì— "íŒ€ ê²°ê³¼"ë§Œ ì“°ë„ë¡ ìœ ì§€ ê°€ëŠ¥)
    // => í˜„ì¬ëŠ” ê¸°ì¡´ ê·¸ëŒ€ë¡œ ë‘ë˜, íŒ€ì „ì—ì„œë„ í† ë„ˆë¥¼ ì“°ë©´ â€œíŒ€ ìŠ¤ì½”ì–´â€ë¡œ ìŠ¹ì ê²°ì •ì„ ì›í•˜ì‹¤ ê°€ëŠ¥ì„±ì´ í¼
    //    (ì›í•˜ì‹œë©´ ë‹¤ìŒ ë‹¨ê³„ì—ì„œ íŒ€ í† ë„ˆë¥¼ ë³´ë“œ ê¸°ë°˜ìœ¼ë¡œ í™•ì¥í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.)
    // =========================
    function renderBracket(){
      const box = $("bracketBox");
      if(!run || !current){
        box.innerHTML = `<div class="mut">-</div>`;
        return;
      }
      const mode = current?.config?.mode || "team";
      const format = run.settings?.format || "league";
      const rounds = run.bracketRounds || null;

      if(format!=="tournament" && format!=="groups_to"){
        box.innerHTML = `<div class="mut">í† ë„ˆë¨¼íŠ¸ ëª¨ë“œì—ì„œ í‘œì‹œë©ë‹ˆë‹¤.</div>`;
        return;
      }
      if(!rounds){
        box.innerHTML = `<div class="mut">í† ë„ˆ ëŒ€ì§„ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      // íŒ€ì „ í† ë„ˆëŠ” ì•„ì§ "ë‹¨ì¼ ì„¸íŠ¸ìŠ¤ì½”ì–´" ë°©ì‹ìœ¼ë¡œë§Œ ìœ ì§€(ìš”ì²­ ì‹œ ë³´ë“œ í™•ì¥)
      const { bestOf, need, label } = bestOfInfo(parseInt($("bestOf").value, 10) || 5);

      box.innerHTML = `
        <div class="bracket">
          ${rounds.map((round, rIdx)=>`
            <div class="box" style="box-shadow:none">
              <h3>ë¼ìš´ë“œ ${rIdx+1}</h3>
              ${round.map((m, i)=>{
                const A = m.A ? teamById(m.A) : null;
                const B = m.B ? teamById(m.B) : null;
                const aName = m.A ? (A ? teamLabel(A) : m.A) : "BYE/ëŒ€ê¸°";
                const bName = m.B ? (B ? teamLabel(B) : m.B) : "BYE/ëŒ€ê¸°";
                const sTxt = m.score && !m.score.bye ? `${m.score.aSets}:${m.score.bSets}` : (m.score?.bye ? "BYE" : "-");
                const winner = m.winner ? (teamById(m.winner) ? teamLabel(teamById(m.winner)) : m.winner) : "";

                return `
                  <div class="bmatch">
                    <div class="line">
                      <div style="font-weight:950">ë§¤ì¹˜ ${i+1}</div>
                      <div class="small">ê²°ê³¼: <b>${esc(sTxt)}</b> Â· ${esc(label)} ${m.done ? "âœ…" : ""}</div>
                    </div>

                    <div style="margin-top:8px;display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center">
                      <div class="side">${esc(aName)}</div>
                      <div class="vs">VS</div>
                      <div class="side">${esc(bName)}</div>
                    </div>

                    <div class="scoreRow">
                      <input class="input scoreInput" type="number" min="0" step="1" id="ba_${m.id}" value="${m.score && !m.score.bye ? m.score.aSets : ""}">
                      <span class="colon">:</span>
                      <input class="input scoreInput" type="number" min="0" step="1" id="bb_${m.id}" value="${m.score && !m.score.bye ? m.score.bSets : ""}">
                      <span class="small">ìµœëŒ€ ${bestOf}ì„¸íŠ¸ / ${need}ì„ ìŠ¹</span>
                      <button class="btn ok" data-bsave="${m.id}">ì €ì¥</button>
                      <button class="btn secondary" data-bclear="${m.id}">ì§€ìš°ê¸°</button>
                    </div>

                    <div class="mut" id="bmsg_${m.id}" style="margin-top:6px"></div>
                    ${winner ? `<div class="oktxt">ìŠ¹ì: ${esc(winner)}</div>` : ``}
                    ${mode==="team" ? `<div class="mut">â€» íŒ€ì „ í† ë„ˆë¥¼ â€˜ë‹¨/ë³µ ë³´ë“œ ì…ë ¥â€™ê¹Œì§€ í™•ì¥í•˜ë ¤ë©´ ë§ì”€í•´ì£¼ì„¸ìš”.</div>` : ``}
                  </div>
                `;
              }).join("")}
            </div>
          `).join("")}
        </div>
      `;

      box.querySelectorAll("button[data-bsave]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          await saveBracketScore(btn.getAttribute("data-bsave"));
        });
      });
      box.querySelectorAll("button[data-bclear]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          await clearBracketScore(btn.getAttribute("data-bclear"));
        });
      });
    }

    async function writeRun(nextRun){
      nextRun.updatedAt = Date.now();
      nextRun.serverUpdatedAt = serverTimestamp();
      await set(ref(db, PATH.run), nextRun);
    }

    function recalcDerived(nextRun){
      const format = nextRun.settings?.format || "league";
      if(format === "league") return nextRun;
      if(format === "tournament"){
        if(nextRun.bracketRounds) propagateBracket(nextRun.bracketRounds);
        return nextRun;
      }

      if(format === "groups_to"){
        const groupsObj = current?.groups || {};

        const standingsByGroup = {};
        for(const [g, ids] of Object.entries(groupsObj)){
          const gMatches = (nextRun.matches||[]).filter(m=>m.group===g);
          standingsByGroup[g] = computeStandings(gMatches, ids, current?.config?.mode || "team");
        }

        const adv = nextRun.settings?.advancePerGroup|0;
        const { seeds, meta } = pickQualifiers(groupsObj, standingsByGroup, adv);

        const qualifierIds = meta.map(x=>x.teamId).slice().sort();
        const prevQualifierIds = nextRun.bracketQualifierIds || null;

        const sameQualifiers =
          Array.isArray(prevQualifierIds) &&
          prevQualifierIds.length === qualifierIds.length &&
          prevQualifierIds.every((v,i)=>v === qualifierIds[i]);

        let seededPositions = nextRun.bracketSeededPositions || null;

        if(!sameQualifiers || !seededPositions){
          seededPositions = buildSeedPositions(meta, true);
          nextRun.bracketQualifierIds = qualifierIds;
          nextRun.bracketSeededPositions = seededPositions;
        }

        nextRun.bracketSeeds = seeds;

        const prevPositions = nextRun.bracketSeededPositionsPrev || null;
        const needRebuild =
          !nextRun.bracketRounds ||
          !prevPositions ||
          !arraysEqual(prevPositions, seededPositions);

        if(needRebuild){
          nextRun.bracketRounds = buildBracketFromPositions(seededPositions);
        }

        nextRun.bracketSeededPositionsPrev = seededPositions;

        propagateBracket(nextRun.bracketRounds);
        return nextRun;
      }

      return nextRun;
    }

    // =========================
    // âœ… ëŒ€ì§„ ìƒì„± (current.config ê¸°ë°˜ ìë™ ì„¸íŒ…)
    // =========================
    function applyConfigToUI(){
      if(!current?.config) return;

      const mode = current.config.mode || "team";
      const single = current.config.single || null;

      // ê°œì¸ì „ì´ë©´ formatì„ ìë™ìœ¼ë¡œ ë§ì¶¤
      if(mode==="single" && single?.format){
        if(single.format==="roundrobin"){
          $("format").value = "league";
          $("advWrap").classList.add("hidden");
          $("formatHint").textContent = "ê°œì¸ì „: í’€ë¦¬ê·¸(ìë™ ì„¤ì •)";
        }else if(single.format==="group_knockout"){
          $("format").value = "groups_to";
          $("advWrap").classList.remove("hidden");
          if(Number.isFinite(single.advancePerGroup)) $("advancePerGroup").value = String(single.advancePerGroup);
          $("formatHint").textContent = `ê°œì¸ì „: ì¡°ë³„ë¦¬ê·¸ + í† ë„ˆ(ìë™ ì„¤ì •)`;
        }else if(single.format==="knockout"){
          $("format").value = "tournament";
          $("advWrap").classList.add("hidden");
          $("formatHint").textContent = "ê°œì¸ì „: ë°”ë¡œ í† ë„ˆë¨¼íŠ¸(ìë™ ì„¤ì •)";
        }
      }else{
        $("formatHint").textContent = "ë‹¨ì²´ì „: ë¦¬ê·¸/í† ë„ˆ/ì¡°+í† ë„ˆ ì¤‘ ì„ íƒ ê°€ëŠ¥";
        $("advWrap").classList.remove("hidden");
      }
    }

    async function buildSchedule(){
      if(!current){
        alert("teamLive/current ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }

      const mode = current?.config?.mode || "team";
      const format = $("format").value;
      const advancePerGroup = parseInt($("advancePerGroup").value, 10);
      const bestOf = parseInt($("bestOf").value, 10) || 5;

      // ì°¸ê°€ ID ëª©ë¡
      const teamIds = (mode==="team")
        ? (current.teams||[]).map(t=>t.id)
        : (current.participants||[]).map(p=>p.name);

      if(teamIds.length < 2){
        alert(mode==="team" ? "íŒ€ì´ 2ê°œ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤." : "ì°¸ê°€ìê°€ 2ëª… ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤.");
        return;
      }

      const groupsObj = current.groups || {};
      const hasGroups = Object.keys(groupsObj).length > 0;

      if(format==="groups_to" && !hasGroups){
        alert("ì¡° ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (team-makeì—ì„œ ì¡° í¸ì„± í›„ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤)");
        return;
      }
      if(format==="groups_to"){
        const minSize = Math.min(...Object.values(groupsObj).map(v=>v.length));
        if(advancePerGroup > minSize){
          alert(`ì§„ì¶œ ì¸ì›(${advancePerGroup})ì´ ì¡° íŒ€ ìˆ˜(${minSize})ë³´ë‹¤ í½ë‹ˆë‹¤. ë‚®ì¶°ì£¼ì„¸ìš”.`);
          return;
        }
      }

      const nextRun = {
        settings: {
          mode,
          format,
          advancePerGroup: (format==="groups_to") ? (advancePerGroup|0) : 0,
          scoring: { kind: "tt_sets_only", bestOf }
        },
        matches: [],
        bracketRounds: null,
        bracketSeeds: [],
        bracketSeededPositions: null,
        bracketQualifierIds: null,
        bracketSeededPositionsPrev: null
      };

      if(format==="league"){
        nextRun.matches = roundRobin(teamIds);

      }else if(format==="tournament"){
        const meta = shuffle(teamIds).map(id => ({ teamId: id, group:"X", rank:1 }));
        const seededPositions = buildSeedPositions(meta, true);
        nextRun.bracketSeededPositions = seededPositions;
        nextRun.bracketSeededPositionsPrev = seededPositions;
        nextRun.bracketQualifierIds = meta.map(x=>x.teamId).slice().sort();
        nextRun.bracketRounds = buildBracketFromPositions(seededPositions);
        propagateBracket(nextRun.bracketRounds);

      }else if(format==="groups_to"){
        nextRun.matches = groupRoundRobin(groupsObj);
        recalcDerived(nextRun);
      }

      // âœ… ë‹¨ì²´ì „ì´ë©´ matchesì— boards ê¸°ë³¸ ìƒì„±
      if(mode==="team"){
        nextRun.matches = (nextRun.matches||[]).map(m=>({
          ...m,
          boards: makeDefaultBoards(),
          teamScore: { aWin:0, bWin:0 }
        }));
      }

      await writeRun(nextRun);
    }

    async function resetRun(){
      if(!confirm("ê²½ê¸° ì§„í–‰ ë°ì´í„°(teamLive/run)ë¥¼ ì´ˆê¸°í™”í• ê¹Œìš”?")) return;
      await set(ref(db, PATH.run), null);
    }

    // =========================
    // ê°œì¸ì „ ì ìˆ˜ ì €ì¥(ê¸°ì¡´)
    // =========================
    async function saveMatchScore(matchId){
      const idx = (run?.matches||[]).findIndex(m=>m.id===matchId);
      if(idx < 0) return;

      const bestOf = parseInt($("bestOf").value, 10) || 5;
      const aEl = document.getElementById(`a_${matchId}`);
      const bEl = document.getElementById(`b_${matchId}`);
      const msg = document.getElementById(`msg_${matchId}`);

      const aSets = parseInt(aEl.value,10);
      const bSets = parseInt(bEl.value,10);

      const v = validateMatchSets(aSets,bSets,bestOf);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.bestOf = bestOf;

      nextRun.matches[idx].score = { aSets, bSets };
      nextRun.matches[idx].done = true;

      msg.className = "oktxt";
      msg.textContent = "ì €ì¥ë¨";

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    async function clearMatchScore(matchId){
      const idx = (run?.matches||[]).findIndex(m=>m.id===matchId);
      if(idx < 0) return;

      const nextRun = structuredClone(run);
      nextRun.matches[idx].score = null;
      nextRun.matches[idx].done = false;

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    // =========================
    // âœ… ë‹¨ì²´ì „: ë³´ë“œ ì €ì¥/ì§€ìš°ê¸° + íŒ€ì „ ì™„ë£Œ ì²˜ë¦¬
    // =========================
    function findRunMatchById(nextRun, matchId){
      const idx = (nextRun?.matches||[]).findIndex(m=>m.id===matchId);
      if(idx<0) return null;
      return { idx, m: nextRun.matches[idx] };
    }
    function findBoard(match, boardId){
      const bi = (match?.boards||[]).findIndex(b=>b.id===boardId);
      if(bi<0) return null;
      return { bi, b: match.boards[bi] };
    }

    function validPlayersPick(kind, aPlayers, bPlayers){
      // ë‹¨ì‹: ê°ê° 1ëª… / ë³µì‹: ê°ê° 2ëª… (ì¤‘ë³µ ê¸ˆì§€ ê¶Œì¥)
      if(kind==="S"){
        if(!aPlayers?.[0] || !bPlayers?.[0]) return {ok:false, msg:"ë‹¨ì‹ ì„ ìˆ˜ ì„ íƒ í•„ìš”"};
        if(aPlayers[0]===bPlayers[0]) return {ok:true}; // ì„œë¡œ ë‹¤ë¥¸ íŒ€ì´ë¼ ì´ë¦„ì´ ê°™ì„ ìˆ˜ë„ ìˆì–´ì„œ í—ˆìš©
        return {ok:true};
      }else{
        if(!aPlayers?.[0] || !aPlayers?.[1] || !bPlayers?.[0] || !bPlayers?.[1]) return {ok:false, msg:"ë³µì‹ 2ëª…ì”© ì„ íƒ í•„ìš”"};
        if(aPlayers[0]===aPlayers[1]) return {ok:false, msg:"AíŒ€ ë³µì‹ ì¤‘ë³µ ì„ íƒ"};
        if(bPlayers[0]===bPlayers[1]) return {ok:false, msg:"BíŒ€ ë³µì‹ ì¤‘ë³µ ì„ íƒ"};
        return {ok:true};
      }
    }

    async function saveTeamBoard(matchId, boardId){
      const bestOf = parseInt($("bestOf").value, 10) || 5;

      const a1 = (document.getElementById(`ap1_${boardId}`)?.value || "").trim();
      const a2 = (document.getElementById(`ap2_${boardId}`)?.value || "").trim();
      const b1 = (document.getElementById(`bp1_${boardId}`)?.value || "").trim();
      const b2 = (document.getElementById(`bp2_${boardId}`)?.value || "").trim();

      const sa = parseInt(document.getElementById(`sa_${boardId}`)?.value,10);
      const sb = parseInt(document.getElementById(`sb_${boardId}`)?.value,10);

      const msg = document.getElementById(`bmsg_${boardId}`);

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.bestOf = bestOf;

      const found = findRunMatchById(nextRun, matchId);
      if(!found) return;

      const foundB = findBoard(found.m, boardId);
      if(!foundB) return;

      const kind = foundB.b.kind;
      const aPlayers = (kind==="S") ? [a1] : [a1, a2];
      const bPlayers = (kind==="S") ? [b1] : [b1, b2];

      const pv = validPlayersPick(kind, aPlayers, bPlayers);
      if(!pv.ok){
        msg.className = "err";
        msg.textContent = pv.msg;
        return;
      }

      const v = validateMatchSets(sa, sb, bestOf);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      // ì €ì¥
      found.m.boards[foundB.bi].aPlayers = aPlayers;
      found.m.boards[foundB.bi].bPlayers = bPlayers;
      found.m.boards[foundB.bi].score = { aSets: sa, bSets: sb };
      found.m.boards[foundB.bi].done = true;

      // íŒ€ ìŠ¤ì½”ì–´ ê°±ì‹ 
      const tScore = calcTeamMatchScore(found.m);
      found.m.teamScore = tScore;

      msg.className = "oktxt";
      msg.textContent = "ë³´ë“œ ì €ì¥ë¨";

      // íŒ€ì „ì€ â€œëª¨ë“  ë³´ë“œ ì…ë ¥ë˜ë©´ ìë™ ì™„ë£Œâ€ë¡œë„ ì²˜ë¦¬ ê°€ëŠ¥
      const allDone = (found.m.boards||[]).every(b=>b.done || b.score?.bye);
      if(allDone){
        found.m.done = true;
        const tmsg = document.getElementById(`tmsg_${matchId}`);
        if(tmsg){
          tmsg.className = "oktxt";
          tmsg.textContent = "ëª¨ë“  ë³´ë“œ ì…ë ¥ ì™„ë£Œ â†’ ê²½ê¸° ì™„ë£Œ ì²˜ë¦¬ë¨";
        }
      }

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    async function clearTeamBoard(matchId, boardId){
      const nextRun = structuredClone(run);
      const found = findRunMatchById(nextRun, matchId);
      if(!found) return;
      const foundB = findBoard(found.m, boardId);
      if(!foundB) return;

      found.m.boards[foundB.bi].score = null;
      found.m.boards[foundB.bi].done = false;

      // íŒ€ìŠ¤ì½”ì–´ ê°±ì‹ 
      found.m.teamScore = calcTeamMatchScore(found.m);

      // ê²½ê¸° ì™„ë£Œë„ í•´ì œ(ì¼ë‹¨ ë³´ë“œ ì§€ìš°ë©´ ì™„ë£Œ í•´ì œ)
      found.m.done = false;

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    async function finishTeamMatch(matchId, yes){
      const nextRun = structuredClone(run);
      const found = findRunMatchById(nextRun, matchId);
      if(!found) return;

      // ì™„ë£Œ ì²˜ë¦¬: ë³´ë“œê°€ í•˜ë‚˜ë„ ì…ë ¥ ì•ˆëëŠ”ë° ì™„ë£ŒëŠ” ë§‰ê¸°
      if(yes){
        const anyDone = (found.m.boards||[]).some(b=>b.done);
        if(!anyDone){
          const tmsg = document.getElementById(`tmsg_${matchId}`);
          if(tmsg){
            tmsg.className = "err";
            tmsg.textContent = "ìµœì†Œ 1ê°œ ë³´ë“œ ê²°ê³¼ë¥¼ ì…ë ¥í•œ í›„ ì™„ë£Œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
          }
          return;
        }
      }

      found.m.teamScore = calcTeamMatchScore(found.m);
      found.m.done = !!yes;

      const tmsg = document.getElementById(`tmsg_${matchId}`);
      if(tmsg){
        tmsg.className = yes ? "oktxt" : "mut";
        tmsg.textContent = yes ? "ê²½ê¸° ì™„ë£Œ ì²˜ë¦¬ë¨" : "ì™„ë£Œ í•´ì œë¨";
      }

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    // =========================
    // bracket ì €ì¥/ì§€ìš°ê¸° (ê¸°ì¡´)
    // =========================
    function findBracketMatch(rounds, matchId){
      for(let r=0;r<rounds.length;r++){
        for(let i=0;i<rounds[r].length;i++){
          if(rounds[r][i].id===matchId) return {r,i};
        }
      }
      return null;
    }

    async function saveBracketScore(matchId){
      if(!run?.bracketRounds) return;
      const pos = findBracketMatch(run.bracketRounds, matchId);
      if(!pos) return;

      const bestOf = parseInt($("bestOf").value, 10) || 5;

      const aEl = document.getElementById(`ba_${matchId}`);
      const bEl = document.getElementById(`bb_${matchId}`);
      const msg = document.getElementById(`bmsg_${matchId}`);

      const aSets = parseInt(aEl.value,10);
      const bSets = parseInt(bEl.value,10);

      const m = run.bracketRounds[pos.r][pos.i];
      if(!m.A || !m.B){
        msg.className = "err";
        msg.textContent = "BYE/ëŒ€ê¸° ìŠ¬ë¡¯ì€ ì ìˆ˜ ì…ë ¥ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.";
        return;
      }

      const v = validateMatchSets(aSets,bSets,bestOf);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.bestOf = bestOf;

      const bm = nextRun.bracketRounds[pos.r][pos.i];
      bm.score = { aSets, bSets };
      bm.done = true;
      bm.winner = (winnerFromSets(aSets,bSets)==="A") ? bm.A : bm.B;

      propagateBracket(nextRun.bracketRounds);

      msg.className = "oktxt";
      msg.textContent = "ì €ì¥ë¨";
      await writeRun(nextRun);
    }

    async function clearBracketScore(matchId){
      if(!run?.bracketRounds) return;
      const pos = findBracketMatch(run.bracketRounds, matchId);
      if(!pos) return;

      const nextRun = structuredClone(run);
      const bm = nextRun.bracketRounds[pos.r][pos.i];
      if(bm.score?.bye) return;

      bm.score = null;
      bm.done = false;
      bm.winner = null;

      propagateBracket(nextRun.bracketRounds);
      await writeRun(nextRun);
    }

    // =========================
    // render all
    // =========================
    function renderAll(){
      applyConfigToUI();

      // hint ë° UI ë³´ì •
      const mode = current?.config?.mode || "team";
      const { label } = bestOfInfo(parseInt($("bestOf").value, 10) || 5);
      $("rulePill").textContent = (mode==="team")
        ? $("rulePill").textContent // renderCurrentì—ì„œ ì´ë¯¸ ì„¸íŒ…
        : `ê°œì¸ì „: ${label}`;

      // ê°œì¸ì „ì—ì„œ ì¡°ê°€ ì—†ìœ¼ë©´ ì¡° ë°•ìŠ¤ ìˆ¨ê¸¸ì§€ ì—¬ë¶€(ì›í•˜ì‹œë©´ ìˆ¨ê¹€ ì²˜ë¦¬ ê°€ëŠ¥)
      renderCurrent();
      renderStandings();
      renderMatches();
      renderBracket();
    }

    // bind
    $("buildBtn").addEventListener("click", buildSchedule);
    $("resetRunBtn").addEventListener("click", resetRun);

    $("advancePerGroup").addEventListener("change", async ()=>{
      if(!run || run.settings?.format!=="groups_to") return;
      const nextRun = structuredClone(run);
      nextRun.settings.advancePerGroup = parseInt($("advancePerGroup").value,10) || 2;
      recalcDerived(nextRun);
      await writeRun(nextRun);
    });

    $("format").addEventListener("change", ()=> renderAll());

    $("bestOf").addEventListener("change", async ()=>{
      if(!run) { renderAll(); return; }
      const nextRun = structuredClone(run);
      nextRun.settings.scoring = nextRun.settings.scoring || {};
      nextRun.settings.scoring.bestOf = parseInt($("bestOf").value,10) || 5;
      await writeRun(nextRun);
    });

    // init
    (async function init(){
      try{
        setStatus("Firebase ì—°ê²° ì¤‘...");
        await signInAnonymously(auth);

        onValue(ref(db, PATH.current), (snap)=>{
          current = snap.exists() ? (snap.val() || null) : null;
          if(!current){
            setStatus("teamLive/current ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (team-makeì—ì„œ ì €ì¥ í›„ ì´ë™í•˜ì„¸ìš”)", "err");
          }else{
            setStatus("ë°ì´í„° ë¡œë“œ ì™„ë£Œ", "oktxt");
          }
          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("current ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

        onValue(ref(db, PATH.run), (snap)=>{
          run = snap.exists() ? (snap.val() || null) : null;

          if(run?.settings){
            $("format").value = run.settings.format || "league";
            $("advancePerGroup").value = String(run.settings.advancePerGroup || 2);

            const bo = run.settings.scoring?.bestOf;
            if(bo === 3 || bo === 5) $("bestOf").value = String(bo);
          }

          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("run ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

      }catch(e){
        console.error(e);
        setStatus("Firebase ì—°ê²° ì˜¤ë¥˜(ì½˜ì†” í™•ì¸)", "err");
      }
    })();
  </script>
</body>
</html>