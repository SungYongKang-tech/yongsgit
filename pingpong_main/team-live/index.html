<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸ“ ê²½ê¸° ì§„í–‰ (team-live)</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --bd:#e6e8ef;
      --txt:#0f172a; --mut:#64748b; --r:16px;
      --accent:#2563eb; --ok:#16a34a; --danger:#ef4444;
      --shadow:0 10px 28px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;background:var(--bg);color:var(--txt)}
    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    h2{margin:6px 0 12px;font-size:16px;font-weight:950;text-align:center}

    .card{background:var(--card);border:1px solid var(--bd);border-radius:var(--r);box-shadow:var(--shadow);padding:12px;margin-bottom:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}
    .input, select{
      padding:10px 12px;border:1px solid var(--bd);border-radius:12px;background:#fff;font-size:14px
    }
    .btn{
      padding:10px 14px;border:1px solid rgba(37,99,235,.25);
      background:linear-gradient(180deg,#2b74ff,#2563eb);
      color:#fff;border-radius:12px;cursor:pointer;font-weight:950;
    }
    .btn.secondary{background:#fff;color:#0f172a;border:1px solid var(--bd)}
    .btn.ok{background:linear-gradient(180deg,#22c55e,#16a34a);border:1px solid rgba(22,163,74,.25)}
    .btn.danger{background:linear-gradient(180deg,#ff5a5a,#ef4444);border:1px solid rgba(239,68,68,.25)}

    .mut{color:var(--mut);font-weight:750;font-size:12px;margin-top:8px;text-align:center}
    .err{color:#b91c1c;font-weight:950;text-align:center}
    .oktxt{color:#166534;font-weight:950;text-align:center}

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){ .grid2{grid-template-columns:1fr} }

    .box{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:12px}
    .box h3{margin:0 0 10px;font-size:14px;font-weight:1000}

    .chip{display:inline-flex;align-items:center;padding:6px 10px;border:1px solid var(--bd);
      border-radius:999px;background:#f8fafc;margin:4px 6px 0 0;font-weight:900}
    .teams{display:flex;flex-direction:column;gap:10px}
    .team{border:1px solid var(--bd);border-radius:14px;padding:10px;background:#f8fafc}
    .team .tline{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
    .team .name{font-weight:950}
    .team .meta{color:var(--mut);font-weight:800;font-size:12px}

    table{width:100%;border-collapse:separate;border-spacing:0}
    th,td{border-bottom:1px solid var(--bd);padding:10px 8px;text-align:center;font-size:13px}
    th{position:sticky;top:0;background:#f2f4f8;z-index:1;font-weight:950}
    tr:last-child td{border-bottom:none}

    .matchCard{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:10px;margin-bottom:10px}
    .matchTop{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;font-weight:950}
    .matchMid{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;margin-top:8px}
    .side{border:1px solid var(--bd);border-radius:12px;padding:10px;background:#f8fafc;font-weight:900;line-height:1.45}
    .vs{font-weight:1000;color:#ef4444;text-align:center}

    .scoreRow{
      display:flex;gap:8px;justify-content:center;align-items:center;margin-top:10px;flex-wrap:wrap;
    }
    .scoreInput{
      width:56px;padding:8px 6px;text-align:center;font-weight:900;font-size:13px;
    }
    .colon{font-weight:900;font-size:18px;margin:0 6px}
    .small{font-size:12px;color:var(--mut);font-weight:800}

    .pill{padding:6px 10px;border:1px solid var(--bd);border-radius:999px;background:#f8fafc;font-weight:900}
    .subttl{font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px}

    .hidden{display:none !important}

    .board{
      border:1px solid var(--bd);
      border-radius:12px;
      padding:10px;
      background:#fff;
      margin-top:10px;
    }
    .boardTop{
      display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;
      font-weight:950;
    }

    .bracket{display:flex;flex-direction:column;gap:10px}
    .bmatch{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:10px}
    .bmatch .line{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
  </style>
</head>

<body>
  <div class="wrap">
    <h2>ğŸ“ ê²½ê¸° ì§„í–‰ (team-live)</h2>

    <div class="card">
      <div class="row">
        <span class="pill" id="modePill">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>

        <label style="font-weight:950">
          ì„¸íŠ¸ ìŠ¹ë¶€
          <select id="bestOf" class="input">
            <option value="5" selected>5íŒ 3ì„ ìŠ¹</option>
            <option value="3">3íŒ 2ì„ ìŠ¹</option>
          </select>
        </label>
      </div>

      <!-- âœ… ë‹¨ì²´ì „ì¼ ë•Œë§Œ ë³´ì´ëŠ”: ë‹¨/ë³µ ì„¤ì • -->
      <div class="row hidden" id="teamRuleRow" style="margin-top:10px">
        <span class="pill">ë‹¨ì²´ì „: ëª‡ë‹¨/ëª‡ë³µ ì„¤ì •</span>

        <label style="font-weight:950">
          ë‹¨ì‹
          <input class="input" id="teamSingles" type="number" min="0" max="30" value="3" style="width:90px">
        </label>
        <label style="font-weight:950">
          ë³µì‹
          <input class="input" id="teamDoubles" type="number" min="0" max="30" value="2" style="width:90px">
        </label>

        <button class="btn ok" id="applyTeamRuleBtn">ì ìš©</button>
        <span class="small" id="teamRuleHint">ì˜ˆ) 3ë‹¨ 2ë³µ â†’ ì´ 5ë³´ë“œ(í™€ìˆ˜ ê¶Œì¥)</span>
      </div>

      <div class="mut" id="status">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
    </div>

    <div class="grid2">
      <div class="box">
        <h3 id="leftTitle">ì°¸ê°€/íŒ€ êµ¬ì„±</h3>
        <div class="teams" id="teamsBox"><div class="mut">ë°ì´í„° ì—†ìŒ</div></div>
      </div>
      <div class="box" id="rightBox">
        <h3>ì¡° êµ¬ì„±</h3>
        <div id="groupsBox"><div class="mut">ì¡° ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¦¬ê·¸/í† ë„ˆë¡œ ì§„í–‰í•˜ì‹œë©´ ë©ë‹ˆë‹¤.</div></div>
      </div>
    </div>

    <div class="card" id="buildCard">
      <div class="row">
        <label style="font-weight:950">
          ì§„í–‰ ë°©ì‹
          <select id="format" class="input">
            <option value="league">ë¦¬ê·¸ì „(ì „ì²´ í’€ë¦¬ê·¸)</option>
            <option value="tournament">í† ë„ˆë¨¼íŠ¸(ë‹¨íŒ)</option>
            <option value="groups_to">ì¡°ë³„ë¦¬ê·¸ + í† ë„ˆë¨¼íŠ¸</option>
          </select>
        </label>

        <label style="font-weight:950" id="advLabel">
          ì¡°ë³„ë¦¬ê·¸ â†’ í† ë„ˆ ì§„ì¶œ(ì¡°ë‹¹)
          <select id="advancePerGroup" class="input">
            <option value="1">1ìœ„ë§Œ</option>
            <option value="2" selected>1Â·2ìœ„</option>
            <option value="3">1Â·2Â·3ìœ„</option>
          </select>
        </label>

        <button class="btn ok" id="buildBtn">ëŒ€ì§„ ìƒì„±</button>
        <button class="btn secondary" id="resetRunBtn">ì§„í–‰ ë°ì´í„° ì´ˆê¸°í™”</button>
      </div>
      <div class="mut" id="buildHint">ì¡°ë³„+í† ë„ˆ ì„ íƒ ì‹œ â€œì§„ì¶œ ì¸ì›â€ì„ ë°”ê¾¸ë©´ í† ë„ˆ ëŒ€ì§„ì´ ìë™ ì¬ìƒì„±ë©ë‹ˆë‹¤.</div>
    </div>

    <div class="card">
      <div class="subttl">ìˆœìœ„í‘œ</div>
      <div id="standingsBox"><div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div></div>
    </div>

    <div class="card">
      <div class="subttl">ê²½ê¸° ì§„í–‰</div>
      <div id="matchesBox"><div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div></div>
    </div>

    <div class="card">
      <div class="subttl">í† ë„ˆë¨¼íŠ¸</div>
      <div id="bracketBox"><div class="mut">í† ë„ˆë¨¼íŠ¸ ì„ íƒ(ë˜ëŠ” ì¡°ë³„+í† ë„ˆ) ì‹œ í‘œì‹œë©ë‹ˆë‹¤.</div></div>
    </div>
  </div>

  <script type="module">
    import { db, auth } from "../firebase.js";
    import { ref, onValue, set, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
    import { signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

    const $ = (id)=>document.getElementById(id);

    const PATH = { current:"teamLive/current", run:"teamLive/run" };

    const esc = (s)=>String(s??"")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");

    const nowId = ()=> `M${Date.now()}_${Math.random().toString(16).slice(2,8)}`;

    let current = null;
    let run = null;

    // mode: "team" | "single"
    const getMode = ()=> current?.config?.mode || "team";

    function setStatus(msg, cls="mut"){
      const el = $("status");
      el.className = cls;
      el.textContent = msg;
    }

    // ---------- ê³µí†µ: ì„¸íŠ¸ ìŠ¤ì½”ì–´ ê²€ì¦ ----------
    function validateMatchSets(aSets, bSets, bestOf){
      if(!Number.isInteger(aSets) || !Number.isInteger(bSets)) return {ok:false, msg:"ì •ìˆ˜ë¡œ ì…ë ¥"};
      if(aSets<0 || bSets<0) return {ok:false, msg:"0 ì´ìƒ"};
      if(aSets===bSets) return {ok:false, msg:"ë™ì  ë¶ˆê°€"};
      if(aSets>bestOf || bSets>bestOf) return {ok:false, msg:`ìµœëŒ€ ${bestOf}ì„¸íŠ¸`};

      const need = Math.ceil(bestOf/2);
      const w = Math.max(aSets,bSets);
      const l = Math.min(aSets,bSets);

      if(w < need) return {ok:false, msg:`ìŠ¹ìëŠ” ìµœì†Œ ${need}ì„¸íŠ¸ í•„ìš”`};
      if(w + l > bestOf) return {ok:false, msg:`í•©ê³„ëŠ” ${bestOf} ì´í•˜ì—¬ì•¼ í•¨`};

      return {ok:true};
    }
    function winnerFromSets(aSets,bSets){ return (aSets>bSets) ? "A" : "B"; }

    // ---------- team/live ë°ì´í„° í•´ì„ ----------
    // ë‹¨ì²´ì „: current.teams ì‚¬ìš©
    // ê°œì¸ì „: current.participantsë¥¼ "ê°€ìƒì˜ íŒ€"ìœ¼ë¡œ ë³€í™˜
    function buildEntityList(){
      const mode = getMode();
      if(mode === "team"){
        const teams = current?.teams || [];
        return teams.map(t=>({
          id: t.id,
          label: teamLabel(t),
          raw: t
        }));
      }

      // ê°œì¸ì „
      const ps = current?.participants || [];
      return ps.map((p, idx)=>({
        id: `P${idx+1}`,
        label: `${p.name ?? ""}${p.grade ? `(${p.grade}ë¶€)` : ""}`,
        raw: p
      }));
    }

    function playerTag(p){
      const busu = p?.grade ?? p?.busu ?? p?.busuText ?? "";
      return `${p?.name ?? ""}${busu ? `(${busu})` : ""}`;
    }
    function teamLabel(team){
      const names = (team.players||[]).map(p=>playerTag(p)).join(" Â· ");
      return `${team.id}: ${names}`;
    }

    function entityById(id){
      const mode = getMode();
      if(mode === "team"){
        return (current?.teams||[]).find(t=>t.id===id) || null;
      }
      // ê°œì¸ì „
      const list = buildEntityList();
      return list.find(x=>x.id===id) || null;
    }

    function entityLabel(id){
      const mode = getMode();
      if(mode === "team"){
        const t = entityById(id);
        return t ? teamLabel(t) : (id || "");
      }
      const p = entityById(id);
      return p ? (p.label || id) : (id || "");
    }

    // ---------- ë‹¨ì²´ì „: teamRule (ëª‡ë‹¨/ëª‡ë³µ) ----------
    function getTeamRule(){
      // ì´ë²ˆ runì—ë§Œ ì €ì¥í•˜ëŠ” ë°©ì‹
      const d = run?.settings?.teamRule?.doublesCount;
      const s = run?.settings?.teamRule?.singlesCount;
      const has = Number.isFinite(s) && Number.isFinite(d);

      if(has) return {
        singlesCount: Math.max(0, s|0),
        doublesCount: Math.max(0, d|0),
        label: `${Math.max(0,s|0)}ë‹¨ ${Math.max(0,d|0)}ë³µ`
      };

      // ê¸°ë³¸ê°’(ì²˜ìŒ)
      return { singlesCount: 3, doublesCount: 2, label: "3ë‹¨ 2ë³µ" };
    }

    function makeBoardsForTeamMatch(){
      const rule = getTeamRule();
      const boards = [];
      for(let i=1;i<=rule.singlesCount;i++){
        boards.push({
          id: nowId(),
          kind: "S",
          no: i,
          score: null,
          done: false
        });
      }
      for(let i=1;i<=rule.doublesCount;i++){
        boards.push({
          id: nowId(),
          kind: "D",
          no: i,
          score: null,
          done: false
        });
      }
      return boards;
    }

    function computeTeamMatchResult(match){
  const boards = match?.boards || [];
  let aW = 0, bW = 0, doneBoards = 0;

  for(const b of boards){
    if(!b.done || !b.score) continue;
    doneBoards++;
    const w = winnerFromSets(b.score.aSets|0, b.score.bSets|0);
    if(w==="A") aW++; else bW++;
  }

  // âœ… ë¬´ìŠ¹ë¶€ í—ˆìš©: "ì „ì²´ ë³´ë“œê°€ ëë‚˜ë©´" íŒ€ë§¤ì¹˜ ì¢…ë£Œ
  const done = boards.length > 0 && doneBoards === boards.length;

  // âœ… winnerëŠ” ë™ë¥ ì´ë©´ null (ë¬´ìŠ¹ë¶€)
  let winner = null;
  if(done){
    if(aW > bW) winner = "A";
    else if(bW > aW) winner = "B";
    else winner = null; // draw
  }

  return { aW, bW, doneBoards, totalBoards: boards.length, done, winner };
}

    // ---------- schedule ----------
    function roundRobin(ids){
      const ms = [];
      for(let i=0;i<ids.length;i++){
        for(let j=i+1;j<ids.length;j++){
          ms.push({
            id: nowId(),
            type:"match",
            group:null,
            A: ids[i],
            B: ids[j],
            // ê°œì¸ì „: score ì‚¬ìš© / ë‹¨ì²´ì „: boards ì‚¬ìš©
            score: null,
            boards: null,
            done:false
          });
        }
      }
      return ms;
    }
    function groupRoundRobin(groupsObj){
      const ms = [];
      for(const [g, ids] of Object.entries(groupsObj||{})){
        const rr = roundRobin(ids);
        rr.forEach(m=>m.group=g);
        ms.push(...rr);
      }
      return ms;
    }
    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // ---------- bracket ----------
    function buildBracketFromPositions(seeded){
      const pow2 = seeded.length;

      const first = [];
      for(let i=0;i<pow2/2;i++){
        const A = seeded[i];
        const B = seeded[pow2-1-i];
        first.push({ id: nowId(), round:1, A, B, score:null, boards:null, done:false, winner:null });
      }

      // BYE ìë™ìŠ¹
      first.forEach(m=>{
        if(m.A && !m.B){ m.done=true; m.winner=m.A; m.score={aSets:0,bSets:0,bye:true}; }
        else if(!m.A && m.B){ m.done=true; m.winner=m.B; m.score={aSets:0,bSets:0,bye:true}; }
      });

      const rounds = [first];
      let curCount = first.length;
      while(curCount > 1){
        curCount = Math.ceil(curCount/2);
        rounds.push(Array.from({length: curCount}, ()=>({
          id: nowId(), round: rounds.length+1, A:null, B:null, score:null, boards:null, done:false, winner:null
        })));
      }
      return rounds;
    }

    function propagateBracket(rounds){
      for(let r=0;r<rounds.length-1;r++){
        const cur = rounds[r];
        const next = rounds[r+1];
        for(let i=0;i<next.length;i++){
          const m1 = cur[i*2];
          const m2 = cur[i*2+1];
          next[i].A = m1 ? (m1.winner||null) : null;
          next[i].B = m2 ? (m2.winner||null) : null;

          const m = next[i];
          if(m.A && !m.B){
            m.done=true; m.winner=m.A; m.score={aSets:0,bSets:0,bye:true};
          }else if(!m.A && m.B){
            m.done=true; m.winner=m.B; m.score={aSets:0,bSets:0,bye:true};
          }else{
            if(!m.done && (m.score?.bye)) m.score=null;
          }
        }
      }
    }

    function pickQualifiers(groupsObj, standingsByGroup, advancePerGroup){
      const adv = advancePerGroup|0;
      const meta = [];
      for(const [g, ids] of Object.entries(groupsObj||{})){
        const st = standingsByGroup[g] || [];
        const take = Math.min(adv, st.length);
        for(let i=0;i<take;i++) meta.push({ teamId: st[i].id, group:g, rank:i+1 });
      }
      meta.sort((a,b)=> (a.rank-b.rank) || String(a.group).localeCompare(String(b.group)));
      return { seeds: meta.map(x=>x.teamId), meta };
    }

    function buildSeedPositions(meta, randomByes=true){
      const n = meta.length;
      const pow2 = 1 << Math.ceil(Math.log2(Math.max(2, n)));
      const byes = pow2 - n;

      const seeded = Array(pow2).fill(null);
      let pairSlots = Array.from({length: pow2/2}, (_,i)=>i);

      let remain = [...meta].sort((a,b)=>{
        if(a.rank !== b.rank) return a.rank - b.rank;
        return String(a.group).localeCompare(String(b.group));
      });

      if(randomByes && byes > 0){
        const picked = shuffle(remain).slice(0, byes);
        const byeSet = new Set(picked.map(x=>x.teamId));
        remain = remain.filter(x=>!byeSet.has(x.teamId));

        pairSlots = shuffle(pairSlots);
        picked.forEach((p, k)=>{
          const ps = pairSlots[k];
          if(Math.random() < 0.5){
            seeded[ps] = p.teamId;
            seeded[pow2-1-ps] = null;
          }else{
            seeded[ps] = null;
            seeded[pow2-1-ps] = p.teamId;
          }
        });

        pairSlots = pairSlots.slice(byes);
      }

      while(remain.length){
        const best = remain.shift();
        let oppIndex = -1;
        for(let k=remain.length-1;k>=0;k--){
          if(remain[k].group !== best.group){ oppIndex = k; break; }
        }
        const opp = (oppIndex>=0) ? remain.splice(oppIndex,1)[0] : (remain.pop() || null);

        const ps = pairSlots.shift();
        if(ps === undefined) break;

        seeded[ps] = best.teamId;
        seeded[pow2-1-ps] = opp ? opp.teamId : null;
      }
      return seeded;
    }

    function arraysEqual(a,b){
      if(!a || !b) return false;
      if(a.length !== b.length) return false;
      for(let i=0;i<a.length;i++) if(a[i] !== b[i]) return false;
      return true;
    }

    // ---------- standings ----------
    // ê°œì¸ì „: ìŠ¹(ì„¸íŠ¸) -> ì„¸íŠ¸ë“ì‹¤ -> ì„¸íŠ¸ë“
    function computeStandingsSingle(matchList, scopedIds){
      const map = new Map();
      const ensure = (id)=>{
        if(!map.has(id)){
          map.set(id, { id, played:0, win:0, loss:0, sw:0, sl:0, sd:0 });
        }
        return map.get(id);
      };
      (scopedIds||[]).forEach(id=>ensure(id));

      for(const m of (matchList||[])){
        if(!m.done || !m.score || m.score.bye) continue;
        if(!m.A || !m.B) continue;

        const A = ensure(m.A);
        const B = ensure(m.B);

        const a = m.score.aSets|0;
        const b = m.score.bSets|0;

        A.played++; B.played++;
        A.sw += a; A.sl += b;
        B.sw += b; B.sl += a;

        const w = winnerFromSets(a,b);
        if(w==="A"){ A.win++; B.loss++; }
        else { B.win++; A.loss++; }
      }

      for(const v of map.values()) v.sd = v.sw - v.sl;

      const arr = [...map.values()];
      arr.sort((x,y)=>{
        if(y.win !== x.win) return y.win - x.win;
        if(y.sd !== x.sd) return y.sd - x.sd;
        if(y.sw !== x.sw) return y.sw - x.sw;
        return x.id.localeCompare(y.id);
      });
      return arr;
    }

    // ë‹¨ì²´ì „: íŒ€ë§¤ì¹˜ ìŠ¹ -> ë³´ë“œë“ì‹¤ -> ë³´ë“œë“
    function computeStandingsTeam(matchList, scopedIds){
  const map = new Map();
  const ensure = (id)=>{
    if(!map.has(id)){
      map.set(id, { id, played:0, win:0, draw:0, loss:0, pts:0, bw:0, bl:0, bd:0 });
    }
    return map.get(id);
  };
  (scopedIds||[]).forEach(id=>ensure(id));

  for(const m of (matchList||[])){
    if(!m.A || !m.B) continue;
    const A = ensure(m.A);
    const B = ensure(m.B);

    // ë³´ë“œ ìŠ¹/íŒ¨ëŠ” ì§„í–‰ ì¤‘ì—ë„ ëˆ„ì 
    const boards = m.boards || [];
    let aW=0, bW=0;
    for(const b of boards){
      if(!b.done || !b.score) continue;
      const w = winnerFromSets(b.score.aSets|0, b.score.bSets|0);
      if(w==="A") aW++; else bW++;
    }
    A.bw += aW; A.bl += bW;
    B.bw += bW; B.bl += aW;

    // âœ… íŒ€ë§¤ì¹˜ ìŠ¹/ë¬´/íŒ¨ëŠ” "íŒ€ë§¤ì¹˜ done"ì¼ ë•Œë§Œ ë°˜ì˜
    const res = computeTeamMatchResult(m);
    if(res.done){
      A.played++; B.played++;
      if(res.winner === "A"){ A.win++; B.loss++; }
      else if(res.winner === "B"){ B.win++; A.loss++; }
      else { A.draw++; B.draw++; } // ë¬´ìŠ¹ë¶€

      // âœ… ìŠ¹ì (ì›í•˜ì‹œë©´ ë°”ê¾¸ì…”ë„ ë©ë‹ˆë‹¤): ìŠ¹2, ë¬´1, íŒ¨0
      A.pts = A.win*2 + A.draw;
      B.pts = B.win*2 + B.draw;
    }
  }

  for(const v of map.values()) v.bd = v.bw - v.bl;

  const arr = [...map.values()];
  arr.sort((x,y)=>{
    // âœ… ì •ë ¬: ìŠ¹ì  â†’ ë³´ë“œë“ì‹¤ â†’ ë³´ë“œë“
    if((y.pts) !== (x.pts)) return (y.pts) - (x.pts);
    if(y.bd !== x.bd) return y.bd - x.bd;
    if(y.bw !== x.bw) return y.bw - x.bw;
    return x.id.localeCompare(y.id);
  });
  return arr;
}

    // ---------- rendering ----------
    function renderModePill(){
      const mode = getMode();
      $("modePill").textContent = (mode==="team") ? "ë‹¨ì²´ì „ ëª¨ë“œ" : "ê°œì¸ì „ ëª¨ë“œ";
      $("teamRuleRow").classList.toggle("hidden", mode!=="team");

      // ì˜¤ë¥¸ìª½(ì¡° êµ¬ì„±)ì€ ê°œì¸ì „ ì¤‘ì‹¬ì´ì§€ë§Œ ë‹¨ì²´ì „ì—ì„œë„ ì“°ê³  ì‹¶ìœ¼ë©´ ìœ ì§€
      // ì¼ë‹¨ ìœ ì§€í•˜ë˜, ë‹¨ì²´ì „ + ì¡° ì—†ìŒì´ë©´ ì•ˆë‚´ë§Œ í‘œì‹œ
      $("rightBox").classList.toggle("hidden", false);

      $("leftTitle").textContent = (mode==="team") ? "í˜„ì¬ íŒ€ êµ¬ì„±" : "ì°¸ê°€ì(ê°œì¸ì „)";
    }

    function renderCurrent(){
      const teamsBox = $("teamsBox");
      const groupsBox = $("groupsBox");

      if(!current){
        teamsBox.innerHTML = `<div class="mut">current ì—†ìŒ</div>`;
        groupsBox.innerHTML = `<div class="mut">-</div>`;
        return;
      }

      const mode = getMode();
      const entities = buildEntityList();

      // ì¢Œì¸¡: íŒ€/ì°¸ê°€ì í‘œì‹œ
      teamsBox.innerHTML = entities.length
        ? entities.map(e=>{
            if(mode==="team"){
              const t = e.raw;
              return `
                <div class="team">
                  <div class="tline">
                    <div class="name">${esc(teamLabel(t))}</div>
                    <div class="meta">í•© ${esc(t.sum ?? "")}</div>
                  </div>
                </div>
              `;
            }else{
              return `
                <div class="team">
                  <div class="tline">
                    <div class="name">${esc(e.label)}</div>
                    <div class="meta">ê°œì¸ì „ ì°¸ê°€</div>
                  </div>
                </div>
              `;
            }
          }).join("")
        : `<div class="mut">ë°ì´í„° ì—†ìŒ</div>`;

      // ìš°ì¸¡: ì¡°(ìˆëŠ” ê²½ìš°ë§Œ)
      const groups = current.groups || {};
      const keys = Object.keys(groups);
      if(!keys.length){
        groupsBox.innerHTML = `<div class="mut">ì¡° ë°ì´í„° ì—†ìŒ</div>`;
      }else{
        groupsBox.innerHTML = keys.sort().map(g=>{
          const ids = groups[g] || [];
          return `
            <div style="margin-bottom:10px">
              <div style="font-weight:1000;margin-bottom:6px">${esc(g)}ì¡°</div>
              <div>
                ${ids.map(id=> `<span class="chip">${esc(entityLabel(id))}</span>`).join("")}
              </div>
            </div>
          `;
        }).join("");
      }
    }

    function standingsTable(title, rows){
      const mode = getMode();
      const isTeam = (mode==="team");

      if(isTeam){
        return `
          <div class="box" style="box-shadow:none">
            <div style="font-weight:1000;margin-bottom:8px">${esc(title)} ìˆœìœ„</div>
            <div style="overflow:auto;border:1px solid var(--bd);border-radius:12px">
              <table>
                <thead>
                  <tr>
                    <th>ìˆœìœ„</th><th>íŒ€</th><th>íŒ€ë§¤ì¹˜</th><th>ìŠ¹</th><th>ë¬´</th><th>íŒ¨</th><th>ìŠ¹ì </th>
<th>ë³´ë“œë“</th><th>ë³´ë“œì‹¤</th><th>ë³´ë“œë“ì‹¤</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows.map((r,i)=>`
                    <tr>
                      <td>${i+1}</td>
<td style="text-align:left;font-weight:900">${esc(entityLabel(r.id))}</td>
<td>${r.played}</td>
<td>${r.win}</td>
<td>${r.draw}</td>
<td>${r.loss}</td>
<td>${r.pts ?? (r.win*2 + r.draw)}</td>
<td>${r.bw}</td>
<td>${r.bl}</td>
<td>${r.bd}</td>
                    </tr>
                  `).join("") || `<tr><td colspan="8" class="mut">ë°ì´í„° ì—†ìŒ</td></tr>`}
                </tbody>
              </table>
            </div>
            <div class="small" style="margin-top:8px">
              ë™ë¥  ì •ë ¬: íŒ€ë§¤ì¹˜ ìŠ¹ â†’ ë³´ë“œë“ì‹¤ â†’ ë³´ë“œë“
            </div>
          </div>
        `;
      }

      // ê°œì¸ì „
      return `
        <div class="box" style="box-shadow:none">
          <div style="font-weight:1000;margin-bottom:8px">${esc(title)} ìˆœìœ„</div>
          <div style="overflow:auto;border:1px solid var(--bd);border-radius:12px">
            <table>
              <thead>
                <tr>
                  <th>ìˆœìœ„</th><th>ì„ ìˆ˜</th><th>ê²½ê¸°</th><th>ìŠ¹</th><th>íŒ¨</th>
                  <th>ì„¸íŠ¸ë“</th><th>ì„¸íŠ¸ì‹¤</th><th>ì„¸íŠ¸ë“ì‹¤</th>
                </tr>
              </thead>
              <tbody>
                ${rows.map((r,i)=>`
                  <tr>
                    <td>${i+1}</td>
                    <td style="text-align:left;font-weight:900">${esc(entityLabel(r.id))}</td>
                    <td>${r.played}</td>
                    <td>${r.win}</td>
                    <td>${r.loss}</td>
                    <td>${r.sw}</td>
                    <td>${r.sl}</td>
                    <td>${r.sd}</td>
                  </tr>
                `).join("") || `<tr><td colspan="8" class="mut">ë°ì´í„° ì—†ìŒ</td></tr>`}
              </tbody>
            </table>
          </div>
          <div class="small" style="margin-top:8px">
            ë™ë¥  ì •ë ¬: ìŠ¹ â†’ ì„¸íŠ¸ë“ì‹¤ â†’ ì„¸íŠ¸ë“
          </div>
        </div>
      `;
    }

    function renderStandings(){
      const box = $("standingsBox");
      if(!run || !current){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div>`;
        return;
      }

      const mode = getMode();
      const format = run.settings?.format || "league";
      const matches = run.matches || [];
      const groupsObj = current.groups || {};
      const ids = buildEntityList().map(x=>x.id);

      const compute = (mode==="team") ? computeStandingsTeam : computeStandingsSingle;

      if(format==="league" || format==="tournament"){
        const st = compute(matches, ids);
        box.innerHTML = standingsTable("ì „ì²´", st);
        return;
      }

      const out = [];
      const standingsByGroup = {};
      for(const [g, gids] of Object.entries(groupsObj)){
        const gMatches = matches.filter(m=>m.group===g);
        const st = compute(gMatches, gids);
        standingsByGroup[g] = st;
        out.push(`<div style="margin-bottom:10px">${standingsTable(`${g}ì¡°`, st)}</div>`);
      }
      box.innerHTML = out.join("") || `<div class="mut">ì¡°ë³„ ìˆœìœ„ ì—†ìŒ</div>`;

      // ì¡°ë³„+í† ë„ˆì´ë©´ ì‹œë“œ í‘œì‹œ(ê°œì¸/ë‹¨ì²´ ê³µí†µ)
      const adv = run.settings?.advancePerGroup|0;
      if(adv>0){
        const q = pickQualifiers(groupsObj, standingsByGroup, adv);
        const seedsArr = q.seeds || [];
        if(seedsArr.length){
          box.innerHTML += `
            <div class="card" style="margin-top:10px;box-shadow:none">
              <div style="font-weight:1000;text-align:center;margin-bottom:8px">í† ë„ˆ ì§„ì¶œ(ì‹œë“œ)</div>
              <div style="text-align:center">
                ${seedsArr.map(id=>`<span class="chip">${esc(entityLabel(id))}</span>`).join("")}
              </div>
              <div class="mut">â€» ì¡°ë³„ ê²°ê³¼ì— ë”°ë¼ í† ë„ˆ ì‹œë“œëŠ” ìë™ ê°±ì‹ ë©ë‹ˆë‹¤.</div>
            </div>
          `;
        }
      }
    }

    // ---------- match rendering ----------
    function renderMatches(){
      const box = $("matchesBox");
      if(!run || !current || !(run.matches||[]).length){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      const mode = getMode();
      const bestOf = parseInt($("bestOf").value, 10) || 5;
      const ms = run.matches || [];

      // ë‹¨ì²´ì „: ë³´ë“œ ê¸°ë°˜ ì…ë ¥
      if(mode==="team"){
        const rule = getTeamRule();
        box.innerHTML = ms.map((m, idx)=>{
          const aName = entityLabel(m.A) || "A";
          const bName = entityLabel(m.B) || "B";
          const res = computeTeamMatchResult(m);

          const head = `${rule.label} Â· (ë‹¨ì‹${rule.singlesCount}/ë³µì‹${rule.doublesCount})`;
          const scoreTxt = `${res.aW}:${res.bW} / ${res.totalBoards}ë³´ë“œ`;
const resultTxt = res.done ? (res.winner==="A" ? "AìŠ¹" : res.winner==="B" ? "BìŠ¹" : "ë¬´ìŠ¹ë¶€") : "ì§„í–‰ì¤‘";

          return `
            <div class="matchCard">
              <div class="matchTop">
                <div>#${idx+1} ${m.group ? `(${esc(m.group)}ì¡°)` : ""}</div>
                <div class="small"><b>${esc(head)}</b> Â· ë³´ë“œ <b>${esc(scoreTxt)}</b> ${res.done ? "âœ…" : ""}</div>
              </div>

              <div class="matchMid">
                <div class="side">${esc(aName)}</div>
                <div class="vs">VS</div>
                <div class="side">${esc(bName)}</div>
              </div>

              ${(m.boards||[]).map((b, bi)=>{
                const kindTxt = (b.kind==="S") ? `ë‹¨ì‹ ${b.no}` : `ë³µì‹ ${b.no}`;
                const sTxt = (b.score && !b.score.bye) ? `${b.score.aSets}:${b.score.bSets}` : "-";
                return `
                  <div class="board">
                    <div class="boardTop">
                      <div>${esc(kindTxt)}</div>
                      <div class="small">ì„¸íŠ¸: <b>${esc(sTxt)}</b> ${b.done ? "âœ…" : ""} <span class="small">(BO${bestOf})</span></div>
                    </div>
                    <div class="scoreRow" style="justify-content:flex-start">
                      <input class="input scoreInput" type="number" min="0" step="1" id="ta_${m.id}_${b.id}" value="${b.score ? b.score.aSets : ""}">
                      <span class="colon">:</span>
                      <input class="input scoreInput" type="number" min="0" step="1" id="tb_${m.id}_${b.id}" value="${b.score ? b.score.bSets : ""}">
                      <button class="btn ok" data-tsave="${m.id}|${b.id}">ì €ì¥</button>
                      <button class="btn secondary" data-tclear="${m.id}|${b.id}">ì§€ìš°ê¸°</button>
                      <span class="mut" id="tmsg_${m.id}_${b.id}" style="margin:0 0 0 6px;text-align:left"></span>
                    </div>
                  </div>
                `;
              }).join("") || `<div class="mut">ë³´ë“œê°€ ì—†ìŠµë‹ˆë‹¤. (ìœ„ì—ì„œ ë‹¨/ë³µ ì„¤ì • ì ìš© í›„ â€œëŒ€ì§„ ìƒì„±â€í•˜ì„¸ìš”)</div>`}
            </div>
          `;
        }).join("");

        box.querySelectorAll("button[data-tsave]").forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            const [mid, bid] = btn.getAttribute("data-tsave").split("|");
            await saveTeamBoardScore(mid, bid);
          });
        });
        box.querySelectorAll("button[data-tclear]").forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            const [mid, bid] = btn.getAttribute("data-tclear").split("|");
            await clearTeamBoardScore(mid, bid);
          });
        });

        return;
      }

      // ê°œì¸ì „: ê¸°ì¡´ ì„¸íŠ¸ìŠ¤ì½”ì–´ ë°©ì‹
      box.innerHTML = ms.map((m, idx)=>{
        const aName = entityLabel(m.A) || (m.A||"BYE");
        const bName = entityLabel(m.B) || (m.B||"BYE");
        const sTxt = m.score && !m.score.bye ? `${m.score.aSets}:${m.score.bSets}` : (m.score?.bye ? "BYE" : "-");

        return `
          <div class="matchCard">
            <div class="matchTop">
              <div>#${idx+1} ${m.group ? `(${esc(m.group)}ì¡°)` : ""}</div>
              <div class="small">ì„¸íŠ¸: <b>${esc(sTxt)}</b> ${m.done ? "âœ…" : ""}</div>
            </div>

            <div class="matchMid">
              <div class="side">${esc(aName)}</div>
              <div class="vs">VS</div>
              <div class="side">${esc(bName)}</div>
            </div>

            <div class="scoreRow">
              <input class="input scoreInput" type="number" min="0" step="1" id="a_${m.id}" value="${m.score && !m.score.bye ? m.score.aSets : ""}">
              <span class="colon">:</span>
              <input class="input scoreInput" type="number" min="0" step="1" id="b_${m.id}" value="${m.score && !m.score.bye ? m.score.bSets : ""}">
              <span class="small">(BO${bestOf})</span>
              <button class="btn ok" data-mid="${m.id}">ì €ì¥</button>
              <button class="btn secondary" data-clear="${m.id}">ì§€ìš°ê¸°</button>
            </div>

            <div class="mut" id="msg_${m.id}" style="margin-top:6px"></div>
          </div>
        `;
      }).join("");

      box.querySelectorAll("button[data-mid]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-mid");
          await saveSingleMatchScore(mid);
        });
      });
      box.querySelectorAll("button[data-clear]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-clear");
          await clearSingleMatchScore(mid);
        });
      });
    }

    // ---------- bracket rendering (ê°œì¸ì „/ë‹¨ì²´ì „ ê³µí†µ í”„ë ˆì„) ----------
    function renderBracket(){
      const box = $("bracketBox");
      if(!run || !current){
        box.innerHTML = `<div class="mut">-</div>`;
        return;
      }
      const format = run.settings?.format || "league";
      const rounds = run.bracketRounds || null;

      if(format!=="tournament" && format!=="groups_to"){
        box.innerHTML = `<div class="mut">í† ë„ˆë¨¼íŠ¸ ëª¨ë“œì—ì„œ í‘œì‹œë©ë‹ˆë‹¤.</div>`;
        return;
      }
      if(!rounds){
        box.innerHTML = `<div class="mut">í† ë„ˆ ëŒ€ì§„ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      const mode = getMode();
      const bestOf = parseInt($("bestOf").value, 10) || 5;
      const rule = (mode==="team") ? getTeamRule() : null;

      box.innerHTML = `
        <div class="bracket">
          ${rounds.map((round, rIdx)=>`
            <div class="box" style="box-shadow:none">
              <h3>ë¼ìš´ë“œ ${rIdx+1}</h3>
              ${round.map((m, i)=>{
                const aName = m.A ? entityLabel(m.A) : "BYE/ëŒ€ê¸°";
                const bName = m.B ? entityLabel(m.B) : "BYE/ëŒ€ê¸°";
                const sTxt = m.score && !m.score.bye ? `${m.score.aSets}:${m.score.bSets}` : (m.score?.bye ? "BYE" : "-");
                const winner = m.winner ? entityLabel(m.winner) : "";

                const extra = (mode==="team" && rule)
                  ? `<div class="small" style="margin-top:6px"><b>${esc(rule.label)}</b> Â· ë³´ë“œ ì§„í–‰ì€ â€œë¦¬ê·¸ ê²½ê¸° ì§„í–‰â€ì—ì„œë§Œ ì…ë ¥(ì›í•˜ì‹œë©´ í† ë„ˆë„ ë³´ë“œ ì…ë ¥ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•©ë‹ˆë‹¤)</div>`
                  : ``;

                return `
                  <div class="bmatch">
                    <div class="line">
                      <div style="font-weight:950">ë§¤ì¹˜ ${i+1}</div>
                      <div class="small">ì„¸íŠ¸: <b>${esc(sTxt)}</b> ${m.done ? "âœ…" : ""} <span class="small">(BO${bestOf})</span></div>
                    </div>

                    <div style="margin-top:8px;display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center">
                      <div class="side">${esc(aName)}</div>
                      <div class="vs">VS</div>
                      <div class="side">${esc(bName)}</div>
                    </div>

                    <div class="scoreRow">
                      <input class="input scoreInput" type="number" min="0" step="1" id="ba_${m.id}" value="${m.score && !m.score.bye ? m.score.aSets : ""}">
                      <span class="colon">:</span>
                      <input class="input scoreInput" type="number" min="0" step="1" id="bb_${m.id}" value="${m.score && !m.score.bye ? m.score.bSets : ""}">
                      <button class="btn ok" data-bsave="${m.id}">ì €ì¥</button>
                      <button class="btn secondary" data-bclear="${m.id}">ì§€ìš°ê¸°</button>
                    </div>

                    <div class="mut" id="bmsg_${m.id}" style="margin-top:6px"></div>
                    ${winner ? `<div class="oktxt">ìŠ¹ì: ${esc(winner)}</div>` : ``}
                    ${extra}
                  </div>
                `;
              }).join("")}
            </div>
          `).join("")}
        </div>
      `;

      box.querySelectorAll("button[data-bsave]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-bsave");
          await saveBracketScore(mid);
        });
      });
      box.querySelectorAll("button[data-bclear]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-bclear");
          await clearBracketScore(mid);
        });
      });
    }

    // ---------- write / recalc ----------
    async function writeRun(nextRun){
      nextRun.updatedAt = Date.now();
      nextRun.serverUpdatedAt = serverTimestamp();
      await set(ref(db, PATH.run), nextRun);
    }

    function recalcDerived(nextRun){
      const format = nextRun.settings?.format || "league";
      if(format === "league") return nextRun;

      if(format === "tournament"){
        if(nextRun.bracketRounds) propagateBracket(nextRun.bracketRounds);
        return nextRun;
      }

      if(format === "groups_to"){
        const groupsObj = current?.groups || {};
        const mode = getMode();
        const compute = (mode==="team") ? computeStandingsTeam : computeStandingsSingle;

        const standingsByGroup = {};
        for(const [g, ids] of Object.entries(groupsObj)){
          const gMatches = (nextRun.matches||[]).filter(m=>m.group===g);
          standingsByGroup[g] = compute(gMatches, ids);
        }

        const adv = nextRun.settings?.advancePerGroup|0;
        const { seeds, meta } = pickQualifiers(groupsObj, standingsByGroup, adv);

        const qualifierIds = meta.map(x=>x.teamId).slice().sort();
        const prevQualifierIds = nextRun.bracketQualifierIds || null;

        const sameQualifiers =
          Array.isArray(prevQualifierIds) &&
          prevQualifierIds.length === qualifierIds.length &&
          prevQualifierIds.every((v,i)=>v === qualifierIds[i]);

        let seededPositions = nextRun.bracketSeededPositions || null;

        if(!sameQualifiers || !seededPositions){
          seededPositions = buildSeedPositions(meta, true);
          nextRun.bracketQualifierIds = qualifierIds;
          nextRun.bracketSeededPositions = seededPositions;
        }

        nextRun.bracketSeeds = seeds;

        const prevPositions = nextRun.bracketSeededPositionsPrev || null;
        const needRebuild =
          !nextRun.bracketRounds ||
          !prevPositions ||
          !arraysEqual(prevPositions, seededPositions);

        if(needRebuild){
          nextRun.bracketRounds = buildBracketFromPositions(seededPositions);
        }

        nextRun.bracketSeededPositionsPrev = seededPositions;

        propagateBracket(nextRun.bracketRounds);
        return nextRun;
      }

      return nextRun;
    }

    // ---------- build schedule ----------
    async function buildSchedule(){
      if(!current){
        alert("teamLive/current ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (team-makeì—ì„œ ì €ì¥ í›„ ì´ë™)");
        return;
      }

      const mode = getMode();
      const entities = buildEntityList();
      if(entities.length < 2){
        alert("ì°¸ê°€ìê°€ 2ëª… ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
        return;
      }

      const format = $("format").value;
      const advancePerGroup = parseInt($("advancePerGroup").value, 10);
      const bestOf = parseInt($("bestOf").value, 10) || 5;

      // ë‹¨ì²´ì „: ë‹¨/ë³µ ë£° ìœ íš¨ì„±(ì´ ë³´ë“œ í™€ìˆ˜ ê¶Œì¥)
      let teamRule = null;
      if(mode==="team"){
        teamRule = getTeamRule();
        const totalBoards = teamRule.singlesCount + teamRule.doublesCount;
        if(totalBoards <= 0){
          alert("ë‹¨ì²´ì „ì€ ë³´ë“œ ìˆ˜ê°€ 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤. (ë‹¨ì‹+ë³µì‹)");
          return;
        }
       
      }

      const ids = entities.map(x=>x.id);
      const groupsObj = current.groups || {};
      const hasGroups = Object.keys(groupsObj).length > 0;

      if(format==="groups_to" && !hasGroups){
        alert("ì¡° ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (íŒ€ êµ¬ì„± í˜ì´ì§€ì—ì„œ ì¡° í¸ì„± í›„ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤)");
        return;
      }

      if(format==="groups_to"){
        const minSize = Math.min(...Object.values(groupsObj).map(v=>v.length));
        if(advancePerGroup > minSize){
          alert(`ì§„ì¶œ ì¸ì›(${advancePerGroup})ì´ ì¡° íŒ€/ì¸ì› ìˆ˜(${minSize})ë³´ë‹¤ í½ë‹ˆë‹¤. ë‚®ì¶°ì£¼ì„¸ìš”.`);
          return;
        }
      }

      const nextRun = {
        settings: {
          format,
          advancePerGroup: (format==="groups_to") ? advancePerGroup : 0,
          scoring: { kind: "tt_sets_only", bestOf },
          // âœ… ë‹¨ì²´ì „ì´ë©´ ì—¬ê¸° ì €ì¥ (ì´ë²ˆ runì—ë§Œ ì ìš©)
          teamRule: (mode==="team") ? {
            singlesCount: teamRule.singlesCount,
            doublesCount: teamRule.doublesCount,
            label: teamRule.label
          } : null
        },
        matches: [],
        bracketRounds: null,
        bracketSeeds: [],
        bracketSeededPositions: null,
        bracketQualifierIds: null,
        bracketSeededPositionsPrev: null
      };

      if(format==="league"){
        nextRun.matches = roundRobin(ids);

      }else if(format==="tournament"){
        const meta = shuffle(ids).map(id => ({ teamId: id, group:"X", rank:1 }));
        const seededPositions = buildSeedPositions(meta, true);
        nextRun.bracketSeededPositions = seededPositions;
        nextRun.bracketSeededPositionsPrev = seededPositions;
        nextRun.bracketQualifierIds = meta.map(x=>x.teamId).slice().sort();

        nextRun.bracketRounds = buildBracketFromPositions(seededPositions);
        propagateBracket(nextRun.bracketRounds);

      }else if(format==="groups_to"){
        nextRun.matches = groupRoundRobin(groupsObj);
        recalcDerived(nextRun);
      }

      // âœ… ë‹¨ì²´ì „ì´ë©´: ê° ë§¤ì¹˜ì— boards ìƒì„±
      if(mode==="team"){
        nextRun.matches = (nextRun.matches||[]).map(m=>({
          ...m,
          boards: makeBoardsForTeamMatch(),
          score: null,
          done: false
        }));
      }

      await writeRun(nextRun);
    }

    async function resetRun(){
      if(!confirm("ê²½ê¸° ì§„í–‰ ë°ì´í„°(teamLive/run)ë¥¼ ì´ˆê¸°í™”í• ê¹Œìš”?")) return;
      await set(ref(db, PATH.run), null);
    }

    // ---------- ê°œì¸ì „ match save/clear ----------
    async function saveSingleMatchScore(matchId){
      const idx = (run?.matches||[]).findIndex(m=>m.id===matchId);
      if(idx < 0) return;

      const bestOf = parseInt($("bestOf").value, 10) || 5;
      const aEl = document.getElementById(`a_${matchId}`);
      const bEl = document.getElementById(`b_${matchId}`);
      const msg = document.getElementById(`msg_${matchId}`);

      const aSets = parseInt(aEl.value,10);
      const bSets = parseInt(bEl.value,10);

      const v = validateMatchSets(aSets,bSets,bestOf);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.bestOf = bestOf;

      nextRun.matches[idx].score = { aSets, bSets };
      nextRun.matches[idx].done = true;

      msg.className = "oktxt";
      msg.textContent = "ì €ì¥ë¨";

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    async function clearSingleMatchScore(matchId){
      const idx = (run?.matches||[]).findIndex(m=>m.id===matchId);
      if(idx < 0) return;

      const nextRun = structuredClone(run);
      nextRun.matches[idx].score = null;
      nextRun.matches[idx].done = false;

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    // ---------- ë‹¨ì²´ì „ board save/clear ----------
    function findMatchAndBoard(nextRun, matchId, boardId){
      const mi = (nextRun?.matches||[]).findIndex(m=>m.id===matchId);
      if(mi < 0) return null;
      const bi = (nextRun.matches[mi].boards||[]).findIndex(b=>b.id===boardId);
      if(bi < 0) return null;
      return { mi, bi };
    }

    async function saveTeamBoardScore(matchId, boardId){
      const bestOf = parseInt($("bestOf").value, 10) || 5;

      const aEl = document.getElementById(`ta_${matchId}_${boardId}`);
      const bEl = document.getElementById(`tb_${matchId}_${boardId}`);
      const msg = document.getElementById(`tmsg_${matchId}_${boardId}`);

      const aSets = parseInt(aEl.value,10);
      const bSets = parseInt(bEl.value,10);

      const v = validateMatchSets(aSets,bSets,bestOf);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.bestOf = bestOf;

      const pos = findMatchAndBoard(nextRun, matchId, boardId);
      if(!pos) return;

      const b = nextRun.matches[pos.mi].boards[pos.bi];
      b.score = { aSets, bSets };
      b.done = true;

      // íŒ€ë§¤ì¹˜ ì™„ë£Œ ì—¬ë¶€ ê°±ì‹ 
      const res = computeTeamMatchResult(nextRun.matches[pos.mi]);
      nextRun.matches[pos.mi].done = res.done;

      msg.className = "oktxt";
      msg.textContent = "ì €ì¥ë¨";

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    async function clearTeamBoardScore(matchId, boardId){
      const nextRun = structuredClone(run);
      const pos = findMatchAndBoard(nextRun, matchId, boardId);
      if(!pos) return;

      const b = nextRun.matches[pos.mi].boards[pos.bi];
      b.score = null;
      b.done = false;

      const res = computeTeamMatchResult(nextRun.matches[pos.mi]);
      nextRun.matches[pos.mi].done = res.done;

      recalcDerived(nextRun);
      await writeRun(nextRun);
    }

    // ---------- bracket score save/clear (ê°œì¸/ë‹¨ì²´ ê³µí†µ: ì§€ê¸ˆì€ ì„¸íŠ¸ìŠ¤ì½”ì–´ ê¸°ë°˜) ----------
    function findBracketMatch(rounds, matchId){
      for(let r=0;r<rounds.length;r++){
        for(let i=0;i<rounds[r].length;i++){
          if(rounds[r][i].id===matchId) return {r,i};
        }
      }
      return null;
    }

    async function saveBracketScore(matchId){
      if(!run?.bracketRounds) return;
      const pos = findBracketMatch(run.bracketRounds, matchId);
      if(!pos) return;

      const bestOf = parseInt($("bestOf").value, 10) || 5;
      const aEl = document.getElementById(`ba_${matchId}`);
      const bEl = document.getElementById(`bb_${matchId}`);
      const msg = document.getElementById(`bmsg_${matchId}`);

      const aSets = parseInt(aEl.value,10);
      const bSets = parseInt(bEl.value,10);

      const m = run.bracketRounds[pos.r][pos.i];
      if(!m.A || !m.B){
        msg.className = "err";
        msg.textContent = "BYE/ëŒ€ê¸° ìŠ¬ë¡¯ì€ ì ìˆ˜ ì…ë ¥ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.";
        return;
      }

      const v = validateMatchSets(aSets,bSets,bestOf);
      if(!v.ok){
        msg.className = "err";
        msg.textContent = v.msg || "ì ìˆ˜ ì˜¤ë¥˜";
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings.scoring.bestOf = bestOf;

      const bm = nextRun.bracketRounds[pos.r][pos.i];
      bm.score = { aSets, bSets };
      bm.done = true;
      bm.winner = (winnerFromSets(aSets,bSets)==="A") ? bm.A : bm.B;

      propagateBracket(nextRun.bracketRounds);

      msg.className = "oktxt";
      msg.textContent = "ì €ì¥ë¨";
      await writeRun(nextRun);
    }

    async function clearBracketScore(matchId){
      if(!run?.bracketRounds) return;
      const pos = findBracketMatch(run.bracketRounds, matchId);
      if(!pos) return;

      const nextRun = structuredClone(run);
      const bm = nextRun.bracketRounds[pos.r][pos.i];
      if(bm.score?.bye) return;

      bm.score = null;
      bm.done = false;
      bm.winner = null;

      propagateBracket(nextRun.bracketRounds);
      await writeRun(nextRun);
    }

    // ---------- teamRule apply ----------
    async function applyTeamRule(){
      if(!run){
        alert("ë¨¼ì € ëŒ€ì§„ ìƒì„± ì „/í›„ ìƒê´€ì—†ì´ ì ìš©í•˜ë ¤ë©´ runì´ í•„ìš”í•©ë‹ˆë‹¤.\nâ†’ ëŒ€ì§„ ìƒì„± ë²„íŠ¼ì„ í•œë²ˆ ëˆ„ë¥´ê±°ë‚˜, ì•„ë˜ì—ì„œ ìë™ìœ¼ë¡œ runì„ ë§Œë“¤ê² ìŠµë‹ˆë‹¤.");
      }

      const s = Math.max(0, Math.floor(Number($("teamSingles").value || 0)));
      const d = Math.max(0, Math.floor(Number($("teamDoubles").value || 0)));
      const total = s + d;

      if(total <= 0){
        alert("ë‹¨ì‹+ë³µì‹ í•©ê³„ëŠ” 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
        return;
      }

      // runì´ ì—†ìœ¼ë©´, ì„¤ì •ë§Œ ë‹´ì€ run ìƒì„±(ì•„ì§ matches ì—†ìŒ)
      let nextRun = run ? structuredClone(run) : {
        settings: { format: "league", advancePerGroup: 0, scoring:{ kind:"tt_sets_only", bestOf: parseInt($("bestOf").value,10)||5 } },
        matches: [],
        bracketRounds: null,
        bracketSeeds: [],
        bracketSeededPositions: null,
        bracketQualifierIds: null,
        bracketSeededPositionsPrev: null
      };

      nextRun.settings.teamRule = { singlesCount:s, doublesCount:d, label:`${s}ë‹¨ ${d}ë³µ` };
      await writeRun(nextRun);

      alert(`âœ… ì ìš© ì™„ë£Œ: ${s}ë‹¨ ${d}ë³µ\nì´ì œ â€œëŒ€ì§„ ìƒì„±â€ì„ ëˆ„ë¥´ë©´ ê° íŒ€ë§¤ì¹˜ì— ë³´ë“œê°€ ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤.`);
    }

    // ---------- UI events ----------
    $("buildBtn").addEventListener("click", buildSchedule);
    $("resetRunBtn").addEventListener("click", resetRun);

    $("advancePerGroup").addEventListener("change", async ()=>{
      if(!run || run.settings?.format!=="groups_to") return;
      const nextRun = structuredClone(run);
      nextRun.settings.advancePerGroup = parseInt($("advancePerGroup").value,10) || 2;
      recalcDerived(nextRun);
      await writeRun(nextRun);
    });

    $("format").addEventListener("change", ()=> renderAll());

    $("bestOf").addEventListener("change", async ()=>{
      if(!run) { renderAll(); return; }
      const nextRun = structuredClone(run);
      nextRun.settings.scoring = nextRun.settings.scoring || {};
      nextRun.settings.scoring.bestOf = parseInt($("bestOf").value,10) || 5;
      await writeRun(nextRun);
    });

    $("applyTeamRuleBtn").addEventListener("click", applyTeamRule);

    function renderAll(){
      renderModePill();
      renderCurrent();
      renderStandings();
      renderMatches();
      renderBracket();
    }

    // ---------- init ----------
    (async function init(){
      try{
        setStatus("Firebase ì—°ê²° ì¤‘...");
        await signInAnonymously(auth);

        onValue(ref(db, PATH.current), (snap)=>{
          current = snap.exists() ? (snap.val() || null) : null;
          if(!current){
            setStatus("teamLive/current ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (team-makeì—ì„œ ì €ì¥ í›„ ì´ë™í•˜ì„¸ìš”)", "err");
          }else{
            setStatus("ë°ì´í„° ë¡œë“œ ì™„ë£Œ", "oktxt");
          }
          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("current ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

        onValue(ref(db, PATH.run), (snap)=>{
          run = snap.exists() ? (snap.val() || null) : null;

          if(run?.settings){
            $("format").value = run.settings.format || "league";
            $("advancePerGroup").value = String(run.settings.advancePerGroup || 2);

            const bo = run.settings.scoring?.bestOf;
            if(bo === 3 || bo === 5) $("bestOf").value = String(bo);

            // ë‹¨ì²´ì „ ë£° ë°˜ì˜
            if(run.settings.teamRule){
              $("teamSingles").value = String(run.settings.teamRule.singlesCount ?? 3);
              $("teamDoubles").value = String(run.settings.teamRule.doublesCount ?? 2);
            }
          }

          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("run ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

      }catch(e){
        console.error(e);
        setStatus("Firebase ì—°ê²° ì˜¤ë¥˜(ì½˜ì†” í™•ì¸)", "err");
      }
    })();
  </script>
</body>
</html>