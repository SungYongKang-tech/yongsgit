<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸ“ ê²½ê¸° ì§„í–‰ (team-live)</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --bd:#e6e8ef;
      --txt:#0f172a; --mut:#64748b; --r:16px;
      --accent:#2563eb; --ok:#16a34a; --danger:#ef4444;
      --shadow:0 10px 28px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;background:var(--bg);color:var(--txt)}
    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    h2{margin:6px 0 12px;font-size:16px;font-weight:950;text-align:center}

    .card{background:var(--card);border:1px solid var(--bd);border-radius:var(--r);box-shadow:var(--shadow);padding:12px;margin-bottom:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}
    .input, select{
      padding:10px 12px;border:1px solid var(--bd);border-radius:12px;background:#fff;font-size:14px
    }
    .btn{
      padding:10px 14px;border:1px solid rgba(37,99,235,.25);
      background:linear-gradient(180deg,#2b74ff,#2563eb);
      color:#fff;border-radius:12px;cursor:pointer;font-weight:950;
    }
    .btn.secondary{background:#fff;color:#0f172a;border:1px solid var(--bd)}
    .btn.ok{background:linear-gradient(180deg,#22c55e,#16a34a);border:1px solid rgba(22,163,74,.25)}
    .btn.danger{background:linear-gradient(180deg,#ff5a5a,#ef4444);border:1px solid rgba(239,68,68,.25)}

    .mut{color:var(--mut);font-weight:750;font-size:12px;margin-top:8px;text-align:center}
    .err{color:#b91c1c;font-weight:950;text-align:center}
    .oktxt{color:#166534;font-weight:950;text-align:center}

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){ .grid2{grid-template-columns:1fr} }

    .box{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:12px}
    .box h3{margin:0 0 10px;font-size:14px;font-weight:1000}

    .chip{display:inline-flex;align-items:center;padding:6px 10px;border:1px solid var(--bd);
      border-radius:999px;background:#f8fafc;margin:4px 6px 0 0;font-weight:900}
    .teams{display:flex;flex-direction:column;gap:10px}
    .team{border:1px solid var(--bd);border-radius:14px;padding:10px;background:#f8fafc}
    .team .tline{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
    .team .name{font-weight:950}
    .team .meta{color:var(--mut);font-weight:800;font-size:12px}

    table{width:100%;border-collapse:separate;border-spacing:0}
    th,td{border-bottom:1px solid var(--bd);padding:10px 8px;text-align:center;font-size:13px}
    th{position:sticky;top:0;background:#f2f4f8;z-index:1;font-weight:950}
    tr:last-child td{border-bottom:none}

    .matchCard{border:1px solid var(--bd);border-radius:14px;background:#fff;padding:10px;margin-bottom:10px}
    .matchTop{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;font-weight:950}
    .matchMid{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;margin-top:8px}
    .side{border:1px solid var(--bd);border-radius:12px;padding:10px;background:#f8fafc;font-weight:900;line-height:1.45}
    .vs{font-weight:1000;color:#ef4444;text-align:center}

    .scoreInput{width:56px;padding:8px 6px;text-align:center;font-weight:900;font-size:13px}
    .colon{font-weight:900;font-size:18px;margin:0 6px}
    .small{font-size:12px;color:var(--mut);font-weight:800}

    .pill{padding:6px 10px;border:1px solid var(--bd);border-radius:999px;background:#f8fafc;font-weight:900}

    .brTableWrap{overflow:auto;border:1px solid var(--bd);border-radius:12px}
  </style>
</head>

<body>
  <div class="wrap">
    <h2>ğŸ“ ê²½ê¸° ì§„í–‰ (team-live)</h2>

    <div class="card">
      <div class="row">
        <span class="pill">íƒêµ¬: ì„¸íŠ¸ ìŠ¤ì½”ì–´ ì…ë ¥</span>

        <!-- âœ… ê°œì¸ì „ í† ë„ˆëŠ” BO3/BO5ë§Œ -->
        <label style="font-weight:950">
          BO(ê°œì¸ì „)
          <select id="bestOf" class="input">
            <option value="5" selected>5íŒ 3ì„ ìŠ¹ (BO5)</option>
            <option value="3">3íŒ 2ì„ ìŠ¹ (BO3)</option>
          </select>
        </label>
      </div>
      <div class="mut" id="status">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
    </div>

    <!-- ë‹¨ì²´ì „ì¼ ë•Œë§Œ ë³´ë“œ ì„¤ì • -->
    <div class="card" id="teamBoardCard" style="display:none">
      <div class="row">
        <span class="pill">ë‹¨ì²´ì „: ë³´ë“œ êµ¬ì„±</span>
        <label style="font-weight:950">ë‹¨ì‹
          <input id="teamSingles" class="input" type="number" min="0" max="20" value="3" style="width:90px">
        </label>
        <label style="font-weight:950">ë³µì‹
          <input id="teamDoubles" class="input" type="number" min="0" max="20" value="2" style="width:90px">
        </label>
        <span class="small" id="boardLabel">ì˜ˆ: 3ë‹¨ 2ë³µ (ì´ 5ë³´ë“œ)</span>
      </div>
      <div class="mut">ëŒ€ì§„ ìƒì„± ì‹œ, ê° íŒ€ë§¤ì¹˜ë§ˆë‹¤ ë³´ë“œí‘œ + ì„ ìˆ˜ ìë™ ë°°ì¹˜ê°€ ë©ë‹ˆë‹¤. (ìˆ˜ì • ê°€ëŠ¥)</div>
    </div>

    <div class="grid2">
      <div class="box">
        <h3 id="leftTitle">í˜„ì¬ íŒ€/ì°¸ê°€ì</h3>
        <div class="teams" id="teamsBox"><div class="mut">ë°ì´í„° ì—†ìŒ</div></div>
      </div>
      <div class="box">
        <h3>ì¡° êµ¬ì„±</h3>
        <div id="groupsBox"><div class="mut">ì¡° ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¦¬ê·¸/í† ë„ˆë¡œ ì§„í–‰í•˜ì‹œë©´ ë©ë‹ˆë‹¤.</div></div>
      </div>
    </div>

    <div class="card">
      <div class="row">
        <label style="font-weight:950">
          ì§„í–‰ ë°©ì‹
          <select id="format" class="input">
            <option value="league">ë¦¬ê·¸ì „(ì „ì²´ í’€ë¦¬ê·¸)</option>
            <option value="groups_to">ì¡°ë³„ë¦¬ê·¸ + í† ë„ˆë¨¼íŠ¸</option>
            <option value="tournament">í† ë„ˆë¨¼íŠ¸(ë‹¨íŒ)</option>
          </select>
        </label>

        <label style="font-weight:950" id="advLabel">
          ì¡°ë³„ë¦¬ê·¸ â†’ í† ë„ˆ ì§„ì¶œ(ì¡°ë‹¹)
          <select id="advancePerGroup" class="input">
            <option value="1">1ìœ„ë§Œ</option>
            <option value="2" selected>1Â·2ìœ„</option>
            <option value="3">1Â·2Â·3ìœ„</option>
          </select>
        </label>

        <button class="btn ok" id="buildBtn">ëŒ€ì§„ ìƒì„±</button>
        <button class="btn secondary" id="resetRunBtn">ì§„í–‰ ë°ì´í„° ì´ˆê¸°í™”</button>
      </div>
      <div class="mut" id="formatHint">ë°ì´í„°ì— ë§ì¶°(ë‹¨ì²´/ê°œì¸) ì„ íƒì§€ê°€ ìë™ ì ìš©ë©ë‹ˆë‹¤.</div>
    </div>

    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">ìˆœìœ„í‘œ</div>
      <div id="standingsBox"><div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div></div>
    </div>

    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">ê²½ê¸° ì§„í–‰</div>
      <div id="matchesBox"><div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div></div>
    </div>

    <div class="card">
      <div style="font-size:14px;font-weight:1000;text-align:center;margin-bottom:10px">í† ë„ˆë¨¼íŠ¸</div>
      <div id="bracketBox"><div class="mut">í† ë„ˆë¨¼íŠ¸ ì„ íƒ(ë˜ëŠ” ì¡°ë³„+í† ë„ˆ) ì‹œ í‘œì‹œë©ë‹ˆë‹¤.</div></div>
      <div class="mut">ê°œì¸ì „ í† ë„ˆëŠ” BO3/BO5 ì„¸íŠ¸ ìŠ¤ì½”ì–´ë¡œ ëê¹Œì§€ ì§„í–‰í•©ë‹ˆë‹¤.</div>
    </div>
  </div>

  <script type="module">
    import { db, auth } from "../firebase.js";
    import { ref, onValue, set, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";
    import { signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";

    const $ = (id)=>document.getElementById(id);
    const PATH = { current:"teamLive/current", run:"teamLive/run" };

    const esc = (s)=>String(s??"")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");

    const nowId = ()=> `M${Date.now()}_${Math.random().toString(16).slice(2,8)}`;

    let current = null;
    let run = null;

    function setStatus(msg, cls="mut"){
      const el = $("status");
      el.className = cls;
      el.textContent = msg;
    }

    function isTeamMode(){
      return current?.config?.mode === "team" && Array.isArray(current?.teams);
    }
    function isSingleMode(){
      return current?.config?.mode === "single" && Array.isArray(current?.participants);
    }

    // ====== helpers: team labels
    function playerTag(p){
  return `${p?.name ?? ""}`; // âœ… ë¶€ìˆ˜/ê´„í˜¸ ì œê±° (ê¸¸ì–´ì§€ëŠ” ì›ì¸ ì°¨ë‹¨)
}
    function teamLabel(team){
  return `${team.id}`; // âœ… ì™„ì „ ê¹”ë”
}
    function teamById(id){
      return (current?.teams||[]).find(t=>t.id===id) || null;
    }
    function teamPlayers(teamId){
      const t = teamById(teamId);
      return (t?.players || []).map(p=>({ name:p.name, grade:p.grade }));
    }

    // ====== ê°œì¸ì „: ì°¸ê°€ì
    function participantById(pid){
      return (current?.participants||[]).find(p=>p.id===pid) || null;
    }
    function pLabel(pid){
      const p = participantById(pid);
      if(!p) return pid || "";
      return `${p.name}(${p.grade}ë¶€)`;
    }
    function participantIds(){
      return (current?.participants||[]).map(p=>p.id);
    }

    // ====== UI sync by mode + saved config
    function syncModeUI(){
      const teamCard = $("teamBoardCard");
      const fmt = $("format");
      const hint = $("formatHint");
      const adv = $("advancePerGroup");
      const advLabel = $("advLabel");
      const leftTitle = $("leftTitle");

      if(isTeamMode()){
        leftTitle.textContent = "í˜„ì¬ íŒ€ êµ¬ì„±";
        teamCard.style.display = "";
        const s = Math.max(0, parseInt($("teamSingles").value,10) || 0);
        const d = Math.max(0, parseInt($("teamDoubles").value,10) || 0);
        $("boardLabel").textContent = `${s}ë‹¨ ${d}ë³µ (ì´ ${s+d}ë³´ë“œ)`;

        // ë‹¨ì²´ì „ì€ ë¦¬ê·¸ì „ë§Œ ê°•ì œ
        fmt.value = "league";
        fmt.querySelectorAll("option").forEach(op=> op.disabled = (op.value !== "league"));
        adv.disabled = true;
        advLabel.style.display = "none";
        hint.textContent = "ë‹¨ì²´ì „: ë³´ë“œí‘œ(ë‹¨ì‹/ë³µì‹) ì…ë ¥ ë°©ì‹ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤. (ë¦¬ê·¸ì „)";

        return;
      }

      // ê°œì¸ì „
      leftTitle.textContent = "í˜„ì¬ ì°¸ê°€ì";
      teamCard.style.display = "none";
      fmt.querySelectorAll("option").forEach(op=> op.disabled = false);
      adv.disabled = false;
      advLabel.style.display = "";
      hint.textContent = "ê°œì¸ì „: ë¦¬ê·¸ / ì¡°ë³„+í† ë„ˆ / í† ë„ˆ ì„ íƒ ê°€ëŠ¥ (ì¡°ëŠ” team-makeì—ì„œ í¸ì„±)";

      // âœ… team-makeì—ì„œ ì €ì¥ëœ ê°œì¸ì „ í˜•ì‹ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë°˜ì˜
      const sconf = current?.config?.single;
      if(sconf?.format){
        const map = { roundrobin:"league", group_knockout:"groups_to", knockout:"tournament" };
        const fv = map[sconf.format] || "league";
        fmt.value = fv;

        // ì¡°ë³„+í† ë„ˆë©´ ì¡°ë‹¹ ì§„ì¶œê°’ë„ ë°˜ì˜
        if(sconf.format==="group_knockout" && sconf.advancePerGroup){
          adv.value = String(sconf.advancePerGroup);
        }
      }
    }

    // ====== random helpers (seeded-ish)
    function hash32(str){
      let h = 2166136261;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h>>>0);
    }
    function mulberry32(seed){
      let a = seed >>> 0;
      return function(){
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    function shuffleWithSeed(arr, seedStr){
      const a = [...arr];
      const rand = mulberry32(hash32(seedStr));
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(rand()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // ====== scoring (ê°œì¸ì „: ë¬´ìŠ¹ë¶€ ë¶ˆê°€, BO3/BO5)
    function validateMatchSets(aSets, bSets, bestOf){
      if(!Number.isInteger(aSets) || !Number.isInteger(bSets)) return {ok:false, msg:"ì •ìˆ˜ë¡œ ì…ë ¥"};
      if(aSets<0 || bSets<0) return {ok:false, msg:"0 ì´ìƒ"};
      if(aSets===bSets) return {ok:false, msg:"ë™ì  ë¶ˆê°€"};
      if(aSets>bestOf || bSets>bestOf) return {ok:false, msg:`ìµœëŒ€ ${bestOf}ì„¸íŠ¸`};

      const need = Math.ceil(bestOf/2);
      const w = Math.max(aSets,bSets);
      const l = Math.min(aSets,bSets);

      if(w < need) return {ok:false, msg:`ìŠ¹ìëŠ” ìµœì†Œ ${need}ì„¸íŠ¸ í•„ìš”`};
      if(w + l > bestOf) return {ok:false, msg:`í•©ê³„ëŠ” ${bestOf} ì´í•˜ì—¬ì•¼ í•¨`};
      return {ok:true};
    }
    function winnerFromSets(aSets,bSets){ return (aSets>bSets) ? "A" : "B"; }

    // ====== round robin generator (ids are teamIds or participantIds)
    function roundRobin(ids, groupName=null){
      const ms = [];
      for(let i=0;i<ids.length;i++){
        for(let j=i+1;j<ids.length;j++){
          ms.push({ id: nowId(), type:"match", group:groupName, A:ids[i], B:ids[j], score:null, done:false, winner:null });
        }
      }
      return ms;
    }

    // ====== team boards
    function makeBoards(singlesCount, doublesCount){
      const boards = [];
      for(let i=1;i<=singlesCount;i++){
        boards.push({ id: nowId(), kind:"S", label:`ë‹¨ì‹ ${i}`, APlayer:"", BPlayer:"", score:null, done:false });
      }
      for(let i=1;i<=doublesCount;i++){
        boards.push({ id: nowId(), kind:"D", label:`ë³µì‹ ${i}`, APlayers:["",""], BPlayers:["",""], score:null, done:false });
      }
      return boards;
    }

    function autoFillBoardsForMatch(match, matchIndex, seedBase){
      const A = match.A, B = match.B;

      const aRaw = teamPlayers(A);
      const bRaw = teamPlayers(B);

      const aList = shuffleWithSeed(aRaw, `${seedBase}|${A}|${matchIndex}`);
      const bList = shuffleWithSeed(bRaw, `${seedBase}|${B}|${matchIndex}`);

      const aN = aList.length, bN = bList.length;

      const aStart = aN ? (matchIndex % aN) : 0;
      const bStart = bN ? (matchIndex % bN) : 0;

      const pickA = (k)=> aN ? aList[(aStart + k) % aN].name : "";
      const pickB = (k)=> bN ? bList[(bStart + k) % bN].name : "";

      let sIdx = 0;
      let dIdx = 0;

      for(const bd of (match.boards||[])){
        if(bd.kind==="S"){
          bd.APlayer = pickA(sIdx);
          bd.BPlayer = pickB(sIdx);
          sIdx++;
        }else{
          if(aN >= 2){
            const p1 = pickA(dIdx);
            const p2 = pickA(dIdx+1);
            bd.APlayers = [p1, (p2===p1 && aN>2) ? pickA(dIdx+2) : p2];
          }else{
            bd.APlayers = ["",""];
          }

          if(bN >= 2){
            const q1 = pickB(dIdx);
            const q2 = pickB(dIdx+1);
            bd.BPlayers = [q1, (q2===q1 && bN>2) ? pickB(dIdx+2) : q2];
          }else{
            bd.BPlayers = ["",""];
          }
          dIdx += 2;
        }
      }
    }

    // ====== team match aggregation (ë‹¨ì²´ì „ì€ ë¬´ìŠ¹ë¶€ í—ˆìš©)
    function computeTeamMatchResult(match){
      const boards = match?.boards || [];
      let aW=0, bW=0, doneBoards=0;

      for(const b of boards){
        if(!b.done || !b.score) continue;
        doneBoards++;
        const w = winnerFromSets(b.score.aSets|0, b.score.bSets|0);
        if(w==="A") aW++; else bW++;
      }

      const done = boards.length>0 && doneBoards === boards.length;

      let winner = null;
      if(done){
        if(aW>bW) winner="A";
        else if(bW>aW) winner="B";
        else winner=null; // ë¬´ìŠ¹ë¶€
      }
      return { aW, bW, doneBoards, totalBoards: boards.length, done, winner };
    }

    function computeStandingsTeam(matches, teamIds){
      const map = new Map();
      const ensure = (id)=>{
        if(!map.has(id)){
          map.set(id, { id, played:0, win:0, draw:0, loss:0, pts:0, bw:0, bl:0, bd:0 });
        }
        return map.get(id);
      };
      (teamIds||[]).forEach(id=>ensure(id));

      for(const m of (matches||[])){
        if(!m.A || !m.B) continue;
        if(!m.done) continue;

        const A = ensure(m.A);
        const B = ensure(m.B);

        const aW = m.result?.aW ?? 0;
        const bW = m.result?.bW ?? 0;

        A.played++; B.played++;
        A.bw += aW; A.bl += bW;
        B.bw += bW; B.bl += aW;

        if(m.winner==="A"){
          A.win++; B.loss++;
          A.pts += 2;
        }else if(m.winner==="B"){
          B.win++; A.loss++;
          B.pts += 2;
        }else{
          A.draw++; B.draw++;
          A.pts += 1;
          B.pts += 1;
        }
      }

      for(const v of map.values()) v.bd = v.bw - v.bl;

      const arr = [...map.values()];
      arr.sort((x,y)=>{
        if(y.pts !== x.pts) return y.pts - x.pts;
        if(y.bd !== x.bd) return y.bd - x.bd;
        if(y.bw !== x.bw) return y.bw - x.bw;
        return x.id.localeCompare(y.id);
      });
      return arr;
    }

    function standingsTableTeam(st){
      return `
        <div class="box" style="box-shadow:none">
          <div style="font-weight:1000;margin-bottom:8px">ë‹¨ì²´ì „ ìˆœìœ„</div>
          <div style="overflow:auto;border:1px solid var(--bd);border-radius:12px">
            <table>
              <thead>
                <tr>
                  <th>ìˆœìœ„</th><th>íŒ€</th><th>ê²½ê¸°</th><th>ìŠ¹</th><th>ë¬´</th><th>íŒ¨</th><th>ìŠ¹ì </th>
                  <th>ë³´ë“œìŠ¹</th><th>ë³´ë“œíŒ¨</th><th>ë³´ë“œë“ì‹¤</th>
                </tr>
              </thead>
              <tbody>
                ${st.map((r,i)=>{
                  const t = teamById(r.id);
                  return `
                    <tr>
                      <td>${i+1}</td>
                      <td style="text-align:left;font-weight:900">${esc(t ? teamLabel(t) : r.id)}</td>
                      <td>${r.played}</td>
                      <td>${r.win}</td>
                      <td>${r.draw}</td>
                      <td>${r.loss}</td>
                      <td><b>${r.pts}</b></td>
                      <td>${r.bw}</td>
                      <td>${r.bl}</td>
                      <td>${r.bd}</td>
                    </tr>
                  `;
                }).join("") || `<tr><td colspan="10" class="mut">ë°ì´í„° ì—†ìŒ</td></tr>`}
              </tbody>
            </table>
          </div>
          <div class="small" style="margin-top:8px">ì •ë ¬: ìŠ¹ì (ìŠ¹2/ë¬´1) â†’ ë³´ë“œë“ì‹¤ â†’ ë³´ë“œìŠ¹</div>
        </div>
      `;
    }

    // ====== ê°œì¸ì „ standings (ë¦¬ê·¸/ì¡°ë³„)
    function computeStandingsSingles(matches, ids){
      const map = new Map();
      const ensure = (id)=>{
        if(!map.has(id)){
          map.set(id, { id, played:0, win:0, loss:0, pts:0, sw:0, sl:0, sd:0 });
        }
        return map.get(id);
      };
      (ids||[]).forEach(id=>ensure(id));

      for(const m of (matches||[])){
        if(!m.done || !m.score) continue;
        if(!m.A || !m.B) continue;

        const A = ensure(m.A);
        const B = ensure(m.B);

        const aS = m.score.aSets|0;
        const bS = m.score.bSets|0;

        A.played++; B.played++;
        A.sw += aS; A.sl += bS;
        B.sw += bS; B.sl += aS;

        if(m.winner==="A"){
          A.win++; B.loss++;
          A.pts += 1;
        }else if(m.winner==="B"){
          B.win++; A.loss++;
          B.pts += 1;
        }
      }

      for(const v of map.values()) v.sd = v.sw - v.sl;

      const arr = [...map.values()];
      arr.sort((x,y)=>{
        if(y.pts !== x.pts) return y.pts - x.pts;
        if(y.sd !== x.sd) return y.sd - x.sd;
        if(y.sw !== x.sw) return y.sw - x.sw;
        return pLabel(x.id).localeCompare(pLabel(y.id), "ko");
      });
      return arr;
    }

    function standingsTableSingles(st, title="ê°œì¸ì „ ìˆœìœ„"){
      return `
        <div class="box" style="box-shadow:none">
          <div style="font-weight:1000;margin-bottom:8px">${esc(title)}</div>
          <div style="overflow:auto;border:1px solid var(--bd);border-radius:12px">
            <table>
              <thead>
                <tr>
                  <th>ìˆœìœ„</th><th>ì„ ìˆ˜</th><th>ê²½ê¸°</th><th>ìŠ¹</th><th>íŒ¨</th><th>ìŠ¹ì </th><th>ì„¸íŠ¸ë“ì‹¤</th><th>ì„¸íŠ¸ìŠ¹</th><th>ì„¸íŠ¸íŒ¨</th>
                </tr>
              </thead>
              <tbody>
                ${st.map((r,i)=>`
                  <tr>
                    <td>${i+1}</td>
                    <td style="text-align:left;font-weight:900">${esc(pLabel(r.id))}</td>
                    <td>${r.played}</td>
                    <td>${r.win}</td>
                    <td>${r.loss}</td>
                    <td><b>${r.pts}</b></td>
                    <td>${r.sd}</td>
                    <td>${r.sw}</td>
                    <td>${r.sl}</td>
                  </tr>
                `).join("") || `<tr><td colspan="9" class="mut">ë°ì´í„° ì—†ìŒ</td></tr>`}
              </tbody>
            </table>
          </div>
          <div class="small" style="margin-top:8px">ì •ë ¬: ìŠ¹ì  â†’ ì„¸íŠ¸ë“ì‹¤ â†’ ì„¸íŠ¸ìŠ¹</div>
        </div>
      `;
    }

    // ====== render current (team/participants)
    function renderCurrent(){
      const teamsBox = $("teamsBox");
      const groupsBox = $("groupsBox");

      if(!current){
        teamsBox.innerHTML = `<div class="mut">current ì—†ìŒ</div>`;
        groupsBox.innerHTML = `<div class="mut">-</div>`;
        return;
      }

      if(isTeamMode()){
        const teams = current.teams || [];
       teamsBox.innerHTML = teams.length
  ? teams.map(t=>{
      const roster = (t.players||[])
        .map(p=>{
          const busu = p.grade ?? p.busu ?? p.level ?? "";
          return busu
            ? `${esc(p.name)} (${esc(busu)}ë¶€)`
            : `${esc(p.name)}`;
        })
        .join(" Â· ");

      return `
        <div class="team">
          <div class="tline">
            <div class="name">${esc(teamLabel(t))}</div>
            <div class="meta">í•© ${esc(t.sum ?? "")}</div>
          </div>

          <div class="small"
               style="margin-top:8px;text-align:left;line-height:1.6">
            ${roster || "íŒ€ì› ì—†ìŒ"}
          </div>
        </div>
      `;
    }).join("")
  : `<div class="mut">íŒ€ ë°ì´í„° ì—†ìŒ</div>`;
      }else{
        const ps = current.participants || [];
        teamsBox.innerHTML = ps.length
          ? ps.map(p=>`
            <div class="team">
              <div class="tline">
                <div class="name">${esc(p.name)}(${esc(p.grade)}ë¶€)</div>
                <div class="meta">${esc(p.id||"")}</div>
              </div>
            </div>
          `).join("")
          : `<div class="mut">ì°¸ê°€ì ë°ì´í„° ì—†ìŒ</div>`;
      }

      const groups = current.groups || {};
      const keys = Object.keys(groups);
      if(!keys.length){
        groupsBox.innerHTML = `<div class="mut">ì¡° ë°ì´í„° ì—†ìŒ</div>`;
      }else{
        groupsBox.innerHTML = keys.sort().map(g=>{
          const ids = groups[g] || [];
          return `
            <div style="margin-bottom:10px">
              <div style="font-weight:1000;margin-bottom:6px">${esc(g)}ì¡°</div>
              <div>
                ${ids.map(id=>{
                  return `<span class="chip">${esc(isTeamMode() ? (teamLabel(teamById(id)||{id,players:[]}) ) : pLabel(id))}</span>`;
                }).join("")}
              </div>
            </div>
          `;
        }).join("");
      }
    }

    // ====== standings render
    function renderStandings(){
      const box = $("standingsBox");
      if(!run || !current){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ ìƒì„± í›„ ì ìˆ˜ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ë°˜ì˜ë©ë‹ˆë‹¤.</div>`;
        return;
      }

      if(isTeamMode()){
        const teamIds = (current.teams||[]).map(t=>t.id);
        const st = computeStandingsTeam(run.matches||[], teamIds);
        box.innerHTML = standingsTableTeam(st);
        return;
      }

      // ê°œì¸ì „
      const fmt = run?.settings?.format || $("format").value;

      if(fmt==="league"){
        const ids = participantIds();
        const st = computeStandingsSingles(run.matches||[], ids);
        box.innerHTML = standingsTableSingles(st, "ê°œì¸ì „ ë¦¬ê·¸ ìˆœìœ„");
        return;
      }

      if(fmt==="groups_to"){
        const groups = current.groups || {};
        const keys = Object.keys(groups);
        if(!keys.length){
          box.innerHTML = `<div class="err">ì¡°ë³„+í† ë„ˆì¸ë° current.groupsê°€ ì—†ìŠµë‹ˆë‹¤. (ì¡°ëŠ” team-makeì—ì„œ í¸ì„± í›„ ì €ì¥í•˜ì„¸ìš”)</div>`;
          return;
        }

        const parts = keys.sort().map(g=>{
          const ids = groups[g] || [];
          const ms = (run.matches||[]).filter(m=>m.group===g);
          const st = computeStandingsSingles(ms, ids);
          return standingsTableSingles(st, `${g}ì¡° ìˆœìœ„`);
        }).join("");

        box.innerHTML = parts || `<div class="mut">ì¡° ìˆœìœ„ í‘œì‹œ ë¶ˆê°€</div>`;
        return;
      }

      box.innerHTML = `<div class="mut">í† ë„ˆë¨¼íŠ¸ëŠ” ìˆœìœ„í‘œ ëŒ€ì‹  ë¸Œë¼ì¼“ì„ í™•ì¸í•˜ì„¸ìš”.</div>`;
    }

    // ====== matches render: team UI (boards) + singles UI
    function optionList(players, selectedName){
      const opts = [`<option value="">ì„ íƒ</option>`];
      for(const p of players){
        const v = p.name;
        opts.push(`<option value="${esc(v)}" ${v===selectedName ? "selected":""}>${esc(p.name)} (${esc(p.grade)}ë¶€)</option>`);
      }
      return opts.join("");
    }

    function teamMatchStateText(m){
      if(!m.done) return "ì§„í–‰ì¤‘";
      if(m.winner==="A") return "AìŠ¹";
      if(m.winner==="B") return "BìŠ¹";
      return "ë¬´ìŠ¹ë¶€";
    }

    function renderTeamMatchUI(m, idx){
      const A = teamById(m.A), B = teamById(m.B);
      const aName = A ? teamLabel(A) : (m.A||"");
      const bName = B ? teamLabel(B) : (m.B||"");

      const aPlayers = teamPlayers(m.A);
      const bPlayers = teamPlayers(m.B);

      const bestOf = parseInt($("bestOf").value, 10) || 5;
      const res = m.result || computeTeamMatchResult(m);

      const rows = (m.boards||[]).map(b=>{
        const scoreTxt = b.score ? `${b.score.aSets}:${b.score.bSets}` : "-";

        if(b.kind==="S"){
          return `
            <tr>
              <td>${esc(b.label)}</td>
              <td>
                <select class="input" data-pick="S,A,${m.id},${b.id}">${optionList(aPlayers, b.APlayer||"")}</select>
              </td>
              <td>
                <select class="input" data-pick="S,B,${m.id},${b.id}">${optionList(bPlayers, b.BPlayer||"")}</select>
              </td>
              <td>
                <input class="input scoreInput" type="number" min="0" step="1" style="width:60px" id="sa_${b.id}" value="${b.score? b.score.aSets:""}">
                <span class="colon">:</span>
                <input class="input scoreInput" type="number" min="0" step="1" style="width:60px" id="sb_${b.id}" value="${b.score? b.score.bSets:""}">
                <span class="small">(BO${bestOf})</span>
                <button class="btn ok" data-bsave="${m.id},${b.id}">ì €ì¥</button>
                <button class="btn secondary" data-bclear="${m.id},${b.id}">ì§€ìš°ê¸°</button>
              </td>
              <td class="small">${b.done ? "âœ…" : ""} ${esc(scoreTxt)}</td>
            </tr>
          `;
        }else{
          const ap1 = b.APlayers?.[0] || "", ap2 = b.APlayers?.[1] || "";
          const bp1 = b.BPlayers?.[0] || "", bp2 = b.BPlayers?.[1] || "";
          return `
            <tr>
              <td>${esc(b.label)}</td>
              <td>
                <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">
                  <select class="input" data-pick="D,A,0,${m.id},${b.id}">${optionList(aPlayers, ap1)}</select>
                  <select class="input" data-pick="D,A,1,${m.id},${b.id}">${optionList(aPlayers, ap2)}</select>
                </div>
              </td>
              <td>
                <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">
                  <select class="input" data-pick="D,B,0,${m.id},${b.id}">${optionList(bPlayers, bp1)}</select>
                  <select class="input" data-pick="D,B,1,${m.id},${b.id}">${optionList(bPlayers, bp2)}</select>
                </div>
              </td>
              <td>
                <input class="input scoreInput" type="number" min="0" step="1" style="width:60px" id="sa_${b.id}" value="${b.score? b.score.aSets:""}">
                <span class="colon">:</span>
                <input class="input scoreInput" type="number" min="0" step="1" style="width:60px" id="sb_${b.id}" value="${b.score? b.score.bSets:""}">
                <span class="small">(BO${bestOf})</span>
                <button class="btn ok" data-bsave="${m.id},${b.id}">ì €ì¥</button>
                <button class="btn secondary" data-bclear="${m.id},${b.id}">ì§€ìš°ê¸°</button>
              </td>
              <td class="small">${b.done ? "âœ…" : ""} ${esc(scoreTxt)}</td>
            </tr>
          `;
        }
      }).join("");

      return `
        <div class="matchCard">
          <div class="matchTop">
            <div>
              #${idx+1} Â· ë³´ë“œ ${res.aW}:${res.bW} / ${res.totalBoards} Â· <b>${esc(teamMatchStateText(m))}</b>
            </div>
            <div class="small">${m.group ? `(${esc(m.group)}ì¡°)` : ""}</div>
          </div>

          <div class="matchMid">
            <div class="side">${esc(aName)}</div>
            <div class="vs">VS</div>
            <div class="side">${esc(bName)}</div>
          </div>

          <div style="overflow:auto;margin-top:10px;border:1px solid var(--bd);border-radius:12px">
            <table>
              <thead>
                <tr>
                  <th>ë³´ë“œ</th>
                  <th>AíŒ€ ì„ ìˆ˜</th>
                  <th>BíŒ€ ì„ ìˆ˜</th>
                  <th>ì„¸íŠ¸ ìŠ¤ì½”ì–´</th>
                  <th>ìƒíƒœ</th>
                </tr>
              </thead>
              <tbody>${rows || `<tr><td colspan="5" class="mut">ë³´ë“œê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>`}</tbody>
            </table>
          </div>
        </div>
      `;
    }

    function renderSinglesMatchUI(m, idx){
      const bestOf = parseInt($("bestOf").value,10) || 5;
      const aName = pLabel(m.A);
      const bName = pLabel(m.B);
      const scoreTxt = m.score ? `${m.score.aSets}:${m.score.bSets}` : "-";
      const state = m.done ? (m.winner==="A" ? "AìŠ¹" : "BìŠ¹") : "ì§„í–‰ì¤‘";

      return `
        <div class="matchCard">
          <div class="matchTop">
            <div>#${idx+1} Â· <b>${esc(state)}</b> ${m.group ? `Â· (${esc(m.group)}ì¡°)` : ""}</div>
            <div class="small">${m.type==="ko" ? `í† ë„ˆ R${m.round}` : `ë¦¬ê·¸`}</div>
          </div>

          <div class="matchMid">
            <div class="side">${esc(aName)}</div>
            <div class="vs">VS</div>
            <div class="side">${esc(bName)}</div>
          </div>

          <div class="row" style="margin-top:10px">
            <input class="input scoreInput" type="number" min="0" step="1" style="width:70px" id="sa_${m.id}" value="${m.score? m.score.aSets:""}">
            <span class="colon">:</span>
            <input class="input scoreInput" type="number" min="0" step="1" style="width:70px" id="sb_${m.id}" value="${m.score? m.score.bSets:""}">
            <span class="small">(BO${bestOf})</span>
            <button class="btn ok" data-ssave="${m.id}">ì €ì¥</button>
            <button class="btn secondary" data-sclear="${m.id}">ì§€ìš°ê¸°</button>
            <span class="small">í˜„ì¬ ${esc(scoreTxt)}</span>
          </div>
        </div>
      `;
    }

    function renderMatches(){
      const box = $("matchesBox");
      if(!run || !current || !(run.matches||[]).length){
        box.innerHTML = `<div class="mut">ëŒ€ì§„ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      const ms = run.matches || [];

      if(isTeamMode()){
        box.innerHTML = ms.map((m, idx)=> renderTeamMatchUI(m, idx)).join("");

        // bind: ì„ ìˆ˜ ì„ íƒ
        box.querySelectorAll("select[data-pick]").forEach(sel=>{
          sel.addEventListener("change", async ()=>{
            const raw = sel.getAttribute("data-pick");
            const parts = raw.split(",");
            const value = sel.value;

            if(parts[0]==="S"){
              const [, side, mid, bid] = parts;
              await saveBoardPick("S", side, 0, mid, bid, value);
            }else{
              const [, side, slot, mid, bid] = parts;
              await saveBoardPick("D", side, parseInt(slot,10), mid, bid, value);
            }
          });
        });

        // bind: ë³´ë“œ ìŠ¤ì½”ì–´ ì €ì¥/ì‚­ì œ
        box.querySelectorAll("button[data-bsave]").forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            const [mid, bid] = btn.getAttribute("data-bsave").split(",");
            await saveBoardScore(mid, bid);
          });
        });
        box.querySelectorAll("button[data-bclear]").forEach(btn=>{
          btn.addEventListener("click", async ()=>{
            const [mid, bid] = btn.getAttribute("data-bclear").split(",");
            await clearBoardScore(mid, bid);
          });
        });

        return;
      }

      // ê°œì¸ì „: ë¦¬ê·¸/ì¡°ë³„ ë¦¬ê·¸/í† ë„ˆ(ko) ëª¨ë‘ matchesì— ì„ì¼ ìˆ˜ ìˆìœ¼ë‹ˆ ë‹¤ ë³´ì—¬ì¤Œ
      const list = ms.filter(m=>m.type!=="ko"); // ë¦¬ê·¸ íŒŒíŠ¸
      const kos  = ms.filter(m=>m.type==="ko"); // í† ë„ˆ íŒŒíŠ¸

      const merged = [...list, ...kos];
      box.innerHTML = merged.map((m, idx)=> renderSinglesMatchUI(m, idx)).join("");

      box.querySelectorAll("button[data-ssave]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-ssave");
          await saveSinglesScore(mid);
        });
      });
      box.querySelectorAll("button[data-sclear]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const mid = btn.getAttribute("data-sclear");
          await clearSinglesScore(mid);
        });
      });
    }

    // ====== bracket rendering (ê°œì¸ì „)
    function renderBracket(){
      const box = $("bracketBox");

      if(!run || !current){
        box.innerHTML = `<div class="mut">í† ë„ˆë¨¼íŠ¸ ì„ íƒ(ë˜ëŠ” ì¡°ë³„+í† ë„ˆ) ì‹œ í‘œì‹œë©ë‹ˆë‹¤.</div>`;
        return;
      }
      if(isTeamMode()){
        box.innerHTML = `<div class="mut">ë‹¨ì²´ì „ì€ ë³´ë“œí‘œ ì…ë ¥ ì¤‘ì‹¬ì…ë‹ˆë‹¤.</div>`;
        return;
      }

      const kos = (run.matches||[]).filter(m=>m.type==="ko");
      if(!kos.length){
        box.innerHTML = `<div class="mut">í† ë„ˆ ëŒ€ì§„ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      // roundë³„ë¡œ ë¬¶ì–´ì„œ í‘œë¡œ ì¶œë ¥
      const byRound = new Map();
      for(const m of kos){
        const r = m.round || 1;
        if(!byRound.has(r)) byRound.set(r, []);
        byRound.get(r).push(m);
      }
      const rounds = [...byRound.keys()].sort((a,b)=>a-b);

      const tables = rounds.map(r=>{
        const ms = byRound.get(r) || [];
        ms.sort((a,b)=> (a.ord||0)-(b.ord||0));
        return `
          <div style="margin-bottom:12px">
            <div style="font-weight:1000;margin-bottom:6px">í† ë„ˆë¨¼íŠ¸ R${r}</div>
            <div class="brTableWrap">
              <table>
                <thead>
                  <tr><th>#</th><th>A</th><th>ìŠ¤ì½”ì–´</th><th>B</th><th>ìƒíƒœ</th></tr>
                </thead>
                <tbody>
                  ${ms.map((m,i)=>{
                    const s = m.score ? `${m.score.aSets}:${m.score.bSets}` : "-";
                    const st = m.done ? (m.winner==="A" ? "AìŠ¹" : "BìŠ¹") : "ì§„í–‰ì¤‘";
                    return `
                      <tr>
                        <td>${i+1}</td>
                        <td style="text-align:left;font-weight:900">${esc(pLabel(m.A||""))}</td>
                        <td><b>${esc(s)}</b></td>
                        <td style="text-align:left;font-weight:900">${esc(pLabel(m.B||""))}</td>
                        <td>${esc(st)}</td>
                      </tr>
                    `;
                  }).join("")}
                </tbody>
              </table>
            </div>
          </div>
        `;
      }).join("");

      box.innerHTML = tables;
    }

    // ====== write run
    async function writeRun(nextRun){
      nextRun.updatedAt = Date.now();
      nextRun.serverUpdatedAt = serverTimestamp();
      await set(ref(db, PATH.run), nextRun);
    }

    // ====== team board save logic
    function findMatchIndexById(mid){
      return (run?.matches||[]).findIndex(m=>m.id===mid);
    }
    function findBoardIndex(m, bid){
      return (m?.boards||[]).findIndex(b=>b.id===bid);
    }

    async function saveBoardPick(kind, side, slotIdx, mid, bid, value){
      const mi = findMatchIndexById(mid);
      if(mi<0) return;

      const nextRun = structuredClone(run);
      const m = nextRun.matches[mi];
      const bi = findBoardIndex(m, bid);
      if(bi<0) return;

      const b = m.boards[bi];
      if(kind==="S"){
        if(side==="A") b.APlayer = value;
        else b.BPlayer = value;
      }else{
        if(side==="A"){
          b.APlayers = b.APlayers || ["",""];
          b.APlayers[slotIdx] = value;
        }else{
          b.BPlayers = b.BPlayers || ["",""];
          b.BPlayers[slotIdx] = value;
        }
      }

      await writeRun(nextRun);
    }

    async function saveBoardScore(mid, bid){
      const mi = findMatchIndexById(mid);
      if(mi<0) return;

      const bestOf = parseInt($("bestOf").value,10) || 5;

      const aEl = document.getElementById(`sa_${bid}`);
      const bEl = document.getElementById(`sb_${bid}`);
      const aSets = parseInt(aEl.value,10);
      const bSets = parseInt(bEl.value,10);

      const v = validateMatchSets(aSets,bSets,bestOf);
      if(!v.ok){
        alert(v.msg || "ì ìˆ˜ ì˜¤ë¥˜");
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings = nextRun.settings || {};
      nextRun.settings.scoring = nextRun.settings.scoring || {};
      nextRun.settings.scoring.bestOf = bestOf;

      const m = nextRun.matches[mi];
      const bi = findBoardIndex(m, bid);
      if(bi<0) return;

      const b = m.boards[bi];

      if(b.kind==="S"){
        if(!b.APlayer || !b.BPlayer){
          alert("ë‹¨ì‹ ë³´ë“œëŠ” ì–‘ìª½ ì„ ìˆ˜ ì´ë¦„ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.");
          return;
        }
      }else{
        const okA = b.APlayers?.[0] && b.APlayers?.[1];
        const okB = b.BPlayers?.[0] && b.BPlayers?.[1];
        if(!okA || !okB){
          alert("ë³µì‹ ë³´ë“œëŠ” ì–‘ìª½ 2ëª…ì”© ëª¨ë‘ ì„ íƒí•˜ì„¸ìš”.");
          return;
        }
        if(b.APlayers[0]===b.APlayers[1] || b.BPlayers[0]===b.BPlayers[1]){
          alert("ë³µì‹ì€ ê°™ì€ íŒ€ì—ì„œ ì„œë¡œ ë‹¤ë¥¸ 2ëª…ì„ ì„ íƒí•˜ì„¸ìš”.");
          return;
        }
      }

      b.score = { aSets, bSets };
      b.done = true;

      const res = computeTeamMatchResult(m);
      m.result = { aW:res.aW, bW:res.bW, totalBoards:res.totalBoards };
      m.done = res.done;
      m.winner = res.winner;

      await writeRun(nextRun);
    }

    async function clearBoardScore(mid, bid){
      const mi = findMatchIndexById(mid);
      if(mi<0) return;

      const nextRun = structuredClone(run);
      const m = nextRun.matches[mi];
      const bi = findBoardIndex(m, bid);
      if(bi<0) return;

      const b = m.boards[bi];
      b.score = null;
      b.done = false;

      const res = computeTeamMatchResult(m);
      m.result = { aW:res.aW, bW:res.bW, totalBoards:res.totalBoards };
      m.done = res.done;
      m.winner = res.winner;

      await writeRun(nextRun);
    }

    // ====== ê°œì¸ì „ ì ìˆ˜ ì €ì¥
    function recomputeSinglesMeta(m, bestOf){
      if(!m.score) { m.done=false; m.winner=null; return; }
      const aS = m.score.aSets|0;
      const bS = m.score.bSets|0;
      const v = validateMatchSets(aS,bS,bestOf);
      if(!v.ok) { m.done=false; m.winner=null; return; }
      m.done = true;
      m.winner = winnerFromSets(aS,bS);
    }

    async function saveSinglesScore(mid){
      const mi = findMatchIndexById(mid);
      if(mi<0) return;

      const bestOf = parseInt($("bestOf").value,10) || 5;

      const aEl = document.getElementById(`sa_${mid}`);
      const bEl = document.getElementById(`sb_${mid}`);
      const aSets = parseInt(aEl.value,10);
      const bSets = parseInt(bEl.value,10);

      const v = validateMatchSets(aSets,bSets,bestOf);
      if(!v.ok){
        alert(v.msg || "ì ìˆ˜ ì˜¤ë¥˜");
        return;
      }

      const nextRun = structuredClone(run);
      nextRun.settings = nextRun.settings || {};
      nextRun.settings.scoring = nextRun.settings.scoring || {};
      nextRun.settings.scoring.bestOf = bestOf;

      const m = nextRun.matches[mi];
      m.score = { aSets, bSets };
      recomputeSinglesMeta(m, bestOf);

      // âœ… ì¡°ë³„+í† ë„ˆë©´, ì¡° ìˆœìœ„ ë³€í™”ì— ë”°ë¼ í† ë„ˆ ì°¸ê°€ì ìë™ ê°±ì‹ 
      if(nextRun.settings.format==="groups_to"){
        fillBracketFromGroupStandings(nextRun);
      }else if(nextRun.settings.format==="tournament"){
        advanceBracketWinners(nextRun);
      }else{
        // leagueëŠ” ì•„ë¬´ê²ƒë„ ì•ˆí•¨
      }

      await writeRun(nextRun);
    }

    async function clearSinglesScore(mid){
      const mi = findMatchIndexById(mid);
      if(mi<0) return;

      const nextRun = structuredClone(run);
      const m = nextRun.matches[mi];
      m.score = null;
      m.done = false;
      m.winner = null;

      if(nextRun.settings.format==="groups_to"){
        fillBracketFromGroupStandings(nextRun);
      }else if(nextRun.settings.format==="tournament"){
        advanceBracketWinners(nextRun);
      }

      await writeRun(nextRun);
    }

    // ====== bracket building/advancing (ê°œì¸ì „)
    function nextPowerOfTwo(n){
      let p = 1;
      while(p < n) p <<= 1;
      return p;
    }

    function buildKO(seeds){
  const N = seeds.length;
  const P = nextPowerOfTwo(N);
  const byes = P - N;

  const firstRound = [];
  const list = [...seeds];

  // nullì„ ë„£ë˜, "ì´ nullì€ 1R BYE ë•Œë¬¸"ì´ë¼ëŠ” í‘œì‹œë¥¼ ë‚¨ê¸°ì
  for(let i=0;i<byes;i++) list.push(null);

  for(let i=0;i<P/2;i++){
    const A = list[i];
    const B = list[P-1-i];

    const isBye = (A && !B) || (!A && B); // âœ… 1ë¼ìš´ë“œì—ë§Œ ì¡´ì¬í•˜ëŠ” BYE ì—¬ë¶€

    firstRound.push({
      id: nowId(),
      type: "ko",
      round: 1,
      ord: i+1,
      A, B,
      isBye,              // âœ… ì¶”ê°€
      score: null,
      done: false,
      winner: null
    });
  }

  // ë‹¤ìŒ ë¼ìš´ë“œë“¤ì€ ì°¸ê°€ìê°€ TBD(null)ì¸ ìƒíƒœ = BYEê°€ ì•„ë‹˜!
  let rounds = [firstRound];
  let r = 2;
  let matchesInRound = firstRound.length / 2;

  while(matchesInRound >= 1){
    const arr = [];
    for(let i=0;i<matchesInRound;i++){
      arr.push({
        id: nowId(),
        type:"ko",
        round:r,
        ord:i+1,
        A:null,
        B:null,
        isBye:false,       // âœ… ì¶”ê°€ (ê¸°ë³¸ false)
        score:null,
        done:false,
        winner:null
      });
    }
    rounds.push(arr);
    r++;
    matchesInRound = matchesInRound/2;
  }

  return rounds.flat();
}

    function advanceBracketWinners(nextRun){
  const kos = (nextRun.matches||[]).filter(m=>m.type==="ko");
  if(!kos.length) return;

  const ordered = kos.slice().sort((a,b)=>{
    if((a.round||0)!==(b.round||0)) return (a.round||0)-(b.round||0);
    return (a.ord||0)-(b.ord||0);
  });

  // group by round
  const byR = new Map();
  for(const m of ordered){
    const r = m.round || 1;
    if(!byR.has(r)) byR.set(r, []);
    byR.get(r).push(m);
  }
  const rounds = [...byR.keys()].sort((a,b)=>a-b);

  const bestOf = nextRun.settings?.scoring?.bestOf || 5;
  const need = Math.ceil(bestOf/2);

  // âœ… í•µì‹¬ 1) BYE ìë™ìŠ¹/ì ìˆ˜ ìë™ì…ë ¥ì€ "1ë¼ìš´ë“œ + isBye=true"ì¸ ê²½ìš°ë§Œ!
  const r1 = byR.get(1) || [];
  for(const m of r1){
    if(m.isBye){
      if(m.A && !m.B){
        m.done = true; m.winner="A";
        // ì ìˆ˜ ìë™ ì…ë ¥ì€ ì›í•˜ë©´ ìœ ì§€, ì‹«ìœ¼ë©´ ì•„ë˜ ì¤„ ì œê±° ê°€ëŠ¥
        if(!m.score) m.score = { aSets: need, bSets: 0 };
      }else if(!m.A && m.B){
        m.done = true; m.winner="B";
        if(!m.score) m.score = { aSets: 0, bSets: need };
      }
    }
  }

  // âœ… í•µì‹¬ 2) ìŠ¹ì ì „íŒŒ + ì°¸ê°€ì ë°”ë€Œë©´ ë‹¤ìŒ ë¼ìš´ë“œ ì ìˆ˜/ìŠ¹íŒ¨ ë¬´ì¡°ê±´ ì´ˆê¸°í™”
  for(let r=1; r<rounds.length; r++){
    const prev = byR.get(r) || [];
    const next = byR.get(r+1) || [];
    if(!next.length) continue;

    for(let i=0;i<next.length;i++){
      const m1 = prev[i*2];
      const m2 = prev[i*2+1];
      const n = next[i];

      const w1 = m1?.done ? (m1.winner==="A" ? m1.A : m1.B) : null;
      const w2 = m2?.done ? (m2.winner==="A" ? m2.A : m2.B) : null;

      const oldA = n.A;
      const oldB = n.B;

      n.A = w1;
      n.B = w2;

      // âœ… TBD(null)ì¸ ìƒíƒœëŠ” "ì•„ì§ ê²½ê¸° ì•ˆ ì •í•´ì§"ì´ì§€ BYEê°€ ì•„ë‹˜
      n.isBye = false;

      // âœ… ì°¸ê°€ì ë³€ê²½(ë˜ëŠ” TBD ìƒíƒœë¡œ ë³€ê²½)ë˜ë©´ ì ìˆ˜/ìŠ¹íŒ¨ ë¦¬ì…‹
      const changed = (oldA !== n.A) || (oldB !== n.B);
      const hasTBD = (!n.A || !n.B);

      if(changed || hasTBD){
        n.score = null;
        n.done = false;
        n.winner = null;
      }
    }
  }
}

    function getGroupStandings(nextRun, groupKey){
      const ids = (current.groups?.[groupKey]||[]).filter(Boolean);
      const ms = (nextRun.matches||[]).filter(m=>m.group===groupKey && m.type==="match");
      return computeStandingsSingles(ms, ids);
    }

    function fillBracketFromGroupStandings(nextRun){
      const groups = current.groups || {};
      const keys = Object.keys(groups).sort();
      if(!keys.length) return;

      const k = parseInt($("advancePerGroup").value,10) || 2;

      // collect qualifiers: for each group take top k
      const qualifiers = [];
      for(const g of keys){
        const st = getGroupStandings(nextRun, g);
        st.slice(0, k).forEach((r, idx)=>{
          qualifiers.push({ group:g, rank:idx+1, pid:r.id });
        });
      }

      // seed order: rank1 ë¨¼ì €, ê·¸ë‹¤ìŒ rank2... ê·¸ë£¹ì€ ì„ì–´ì„œ
      const seedBase = String(nextRun.updatedAt || Date.now());
      const out = [];
      for(let rank=1; rank<=k; rank++){
        const chunk = qualifiers.filter(q=>q.rank===rank).map(q=>q.pid);
        const mixed = shuffleWithSeed(chunk, `seed|${seedBase}|rank${rank}`);
        out.push(...mixed);
      }

      // build KO if not exist OR size changed
      let kos = (nextRun.matches||[]).filter(m=>m.type==="ko");
      if(!kos.length){
        const ko = buildKO(out);
        nextRun.matches = [...(nextRun.matches||[]), ...ko];
        kos = ko;
      }else{
        // first roundë§Œ seedë¡œ ì¬ë°°ì¹˜í•˜ê³ , ì´í›„ ë¼ìš´ë“œëŠ” ì´ˆê¸°í™”
        const ordered = kos.slice().sort((a,b)=>{
          if((a.round||0)!==(b.round||0)) return (a.round||0)-(b.round||0);
          return (a.ord||0)-(b.ord||0);
        });
        const r1 = ordered.filter(m=>m.round===1);

        // seeds -> byes ì²˜ë¦¬ í¬í•¨í•˜ì—¬ r1ì— ë„£ê¸°
        const N = out.length;
        const P = nextPowerOfTwo(N);
        const byes = P - N;
        const list = [...out];
        for(let i=0;i<byes;i++) list.push(null);

        for(let i=0;i<r1.length;i++){
          const A = list[i];
          const B = list[P-1-i];
          r1[i].A = A;
          r1[i].B = B;
          r1[i].score = null; r1[i].done=false; r1[i].winner=null;
        }

        // reset rounds >=2
        ordered.filter(m=>m.round>1).forEach(m=>{
          m.A=null; m.B=null; m.score=null; m.done=false; m.winner=null;
        });
      }

      // now propagate auto-byes and winners chain
      advanceBracketWinners(nextRun);
    }

    // ====== build schedule (team or singles)
    async function buildSchedule(){
      if(!current){
        alert("teamLive/current ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }

      const nextRun = {
        settings: {
          format: $("format").value,
          scoring: {
            kind: isTeamMode() ? "tt_team_boards" : "tt_sets_only",
            bestOf: parseInt($("bestOf").value,10) || 5
          }
        },
        matches: []
      };

      if(isTeamMode()){
        const teamIds = current.teams.map(t=>t.id);

        const s = Math.max(0, parseInt($("teamSingles").value,10) || 0);
        const d = Math.max(0, parseInt($("teamDoubles").value,10) || 0);
        if(s + d < 1){
          alert("ë‹¨ì‹+ë³µì‹ í•©ê³„ê°€ 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
          return;
        }

        const base = roundRobin(teamIds);

        const seedBase = String(Date.now());

        base.forEach((m, idx)=>{
          m.kind = "team_match";
          m.boards = makeBoards(s, d);

          autoFillBoardsForMatch(m, idx, seedBase);

          m.result = { aW:0, bW:0, totalBoards:(s+d) };
          m.winner = null;
          m.done = false;
          delete m.score;
        });

        nextRun.settings.format = "league";
        nextRun.matches = base;

        await writeRun(nextRun);
        return;
      }

      // ====== ê°œì¸ì „
      const ids = participantIds();
      if(ids.length < 2){
        alert("ê°œì¸ì „ ì°¸ê°€ìê°€ 2ëª… ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
        return;
      }

      const fmt = $("format").value;

      if(fmt==="league"){
        nextRun.matches = roundRobin(ids);
        await writeRun(nextRun);
        return;
      }

      if(fmt==="tournament"){
        // í† ë„ˆë¨¼íŠ¸: ì°¸ê°€ì ì „ì²´ë¡œ KO ìƒì„±
        const seedBase = String(Date.now());
        const seeds = shuffleWithSeed(ids, `tournament|${seedBase}`);
        const ko = buildKO(seeds);
        nextRun.matches = ko;
        advanceBracketWinners(nextRun);
        await writeRun(nextRun);
        return;
      }

      if(fmt==="groups_to"){
        // ì¡°ë³„+í† ë„ˆ: ì¡°ëŠ” team-makeì—ì„œ í¸ì„±ë˜ì–´ current.groupsì— ìˆì–´ì•¼ í•¨
        const groups = current.groups || {};
        const keys = Object.keys(groups).sort();
        if(!keys.length){
          alert("ì¡°ë³„+í† ë„ˆì¸ë° ì¡° ë°ì´í„°(current.groups)ê°€ ì—†ìŠµë‹ˆë‹¤. team-makeì—ì„œ ì¡°ë¥¼ í¸ì„± í›„ ì €ì¥í•˜ì„¸ìš”.");
          return;
        }

        // ì¡°ë³„ ë¦¬ê·¸ ë§¤ì¹˜ ìƒì„±
        const all = [];
        keys.forEach(g=>{
          const gIds = (groups[g]||[]).filter(Boolean);
          if(gIds.length >= 2){
            all.push(...roundRobin(gIds, g));
          }
        });

        nextRun.matches = all;

        // í† ë„ˆëŠ” â€˜ì§€ê¸ˆ ì‹œì  ìˆœìœ„â€™ë¡œ ìë™ ìƒì„± + ê³„ì† ê°±ì‹ 
        // (ì²˜ìŒì—” ì ìˆ˜ ì—†ìœ¼ë‹ˆ seedê°€ ë‹¤ 0ì ì´ì§€ë§Œ, ì…ë ¥í•˜ë©´ ìë™ ê°±ì‹ ë¨)
        fillBracketFromGroupStandings(nextRun);

        await writeRun(nextRun);
        return;
      }

      alert("ì•Œ ìˆ˜ ì—†ëŠ” ì§„í–‰ ë°©ì‹ì…ë‹ˆë‹¤.");
    }

    async function resetRun(){
      if(!confirm("ê²½ê¸° ì§„í–‰ ë°ì´í„°(teamLive/run)ë¥¼ ì´ˆê¸°í™”í• ê¹Œìš”?")) return;
      await set(ref(db, PATH.run), null);
    }

    // ====== bind
    $("buildBtn").addEventListener("click", buildSchedule);
    $("resetRunBtn").addEventListener("click", resetRun);

    $("bestOf").addEventListener("change", async ()=>{
      if(!run) return;
      const nextRun = structuredClone(run);
      nextRun.settings = nextRun.settings || {};
      nextRun.settings.scoring = nextRun.settings.scoring || {};
      nextRun.settings.scoring.bestOf = parseInt($("bestOf").value,10) || 5;
      await writeRun(nextRun);
    });

    $("teamSingles").addEventListener("change", syncModeUI);
    $("teamDoubles").addEventListener("change", syncModeUI);

    $("format").addEventListener("change", ()=>{
      // ê°œì¸ì „ì—ì„œëŠ” ì„ íƒ ê°€ëŠ¥. (ë‹¨, ì €ì¥ëœ configê°€ ìˆë”ë¼ë„ ì‚¬ìš©ìê°€ ë°”ê¾¸ë©´ ê·¸ê±¸ë¡œ ìƒì„±)
      renderStandings();
      renderBracket();
    });

    $("advancePerGroup").addEventListener("change", ()=>{
      // ì¡°ë³„+í† ë„ˆ ì§„í–‰ ì¤‘ì´ë©´ ë¸Œë¼ì¼“ ê°±ì‹ 
      if(run && run.settings?.format==="groups_to"){
        const nextRun = structuredClone(run);
        fillBracketFromGroupStandings(nextRun);
        writeRun(nextRun);
      }
    });

    function renderAll(){
      syncModeUI();
      renderCurrent();
      renderStandings();
      renderMatches();
      renderBracket();
    }

    // ====== init
    (async function init(){
      try{
        setStatus("Firebase ì—°ê²° ì¤‘...");
        await signInAnonymously(auth);

        onValue(ref(db, PATH.current), (snap)=>{
          current = snap.exists() ? (snap.val() || null) : null;
          if(!current){
            setStatus("teamLive/current ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (team-makeì—ì„œ ì €ì¥ í›„ ì´ë™í•˜ì„¸ìš”)", "err");
          }else{
            setStatus("ë°ì´í„° ë¡œë“œ ì™„ë£Œ", "oktxt");
          }
          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("current ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

        onValue(ref(db, PATH.run), (snap)=>{
          run = snap.exists() ? (snap.val() || null) : null;
          renderAll();
        }, (err)=>{
          console.error(err);
          setStatus("run ì½ê¸° ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)", "err");
        });

      }catch(e){
        console.error(e);
        setStatus("Firebase ì—°ê²° ì˜¤ë¥˜(ì½˜ì†” í™•ì¸)", "err");
      }
    })();
  </script>
</body>
</html>