<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Wall-baduk ê²Œì„</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
    :root { --bar-h: 60px; --p: 42px; --t: 15px; }
    body { font-family: sans-serif; background:#f5f5f5; text-align:center; margin:0; min-height:100vh;
      display:grid; grid-template-rows:auto auto auto auto auto; }
    h1 { margin: 8px 0 4px; }

    /* ë¡œë¹„ */
    #setup { margin:10px 0 4px; }
    #setup .row { display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; }
    #roomInput { width:min(260px, 70vw); padding:10px 12px; border:1px solid #bbb; border-radius:8px; font-size:16px; }
    #setup button { padding:12px 14px; border-radius:10px; border:1px solid #999; background:#fff; cursor:pointer; }
    #roomLine { font-size:13px; color:#555; margin:6px 0 6px; }

    /* ìƒë‹¨ íŒ¨ë„ */
    #panel { margin:4px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    #panel button { padding:10px 14px; border:1px solid #999; border-radius:10px; background:#fff; cursor:pointer; }

    #turnLine { margin:2px 0; font-size:16px; display:flex; gap:8px; justify-content:center; align-items:center; }
    #turnColor { font-weight:700; }
    #timer { font-variant-numeric: tabular-nums; padding:2px 6px; border:1px solid #ddd; border-radius:8px; background:#fff;
      min-width: 54px; display:inline-block; }
    #scores { margin:0 0 4px; font-size:14px; }

    /* ì˜¤ë””ì˜¤ ì»¨íŠ¸ë¡¤ */
    .audio-wrap { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; }
    #volSlider { width: 160px; }
    #volVal { min-width:36px; display:inline-block; text-align:right; }

    /* ë³´ë“œ */
    #wrap { display:flex; justify-content:center; align-items:flex-start; padding:0 10px 6px; overflow:auto; }
    #board { display:grid; background:#fff; border:2px solid #333; user-select:none; touch-action:manipulation; }
    .cell { box-sizing:border-box; border:1px solid #000; display:flex; align-items:center; justify-content:center; }

    .point { width:var(--p); height:var(--p); background:#fff; position:relative; cursor:pointer; transition:background .1s; }
    .piece { width:80%; height:80%; border-radius:50%; pointer-events:none; }
    .h-wall { width:var(--p); height:var(--t); background:#fff; cursor:pointer; }
    .v-wall { width:var(--t); height:var(--p); background:#fff; cursor:pointer; }
    .blank  { width:var(--t); height:var(--t); background:#15326b; }

    .movable { background:#d0d0d0 !important; }
    .final-p1-region { background:#ffd6e7 !important; }
    .final-p2-region { background:#d6ecff !important; }

    #bottomBar { position:sticky; bottom:0; left:0; right:0; background:#ffffffcc; backdrop-filter:blur(6px);
      border-top:1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center; padding:6px 12px; }
    #skipWallBtn { width:min(340px,92vw); height:40px; border-radius:12px; font-weight:700; background:#ffd6e7; border:1px solid #e7a3bd; }
    button:disabled { opacity:.5; cursor:not-allowed; }

    /* ë„ì›€ë§ ëª¨ë‹¬ */
    #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:10000; padding:16px; }
    #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
    #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
    #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
    #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
    #helpBody ul ul { margin-left:6px; padding-left:10px; }
    #helpBody li { margin:4px 0; }
    #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
    .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }

    @media (max-width:420px){ #volSlider { width:120px; } }
  </style>
</head>
<body>
<h1>Wall-baduk (ë²½ë°”ë‘‘)</h1>
<div id="gameRoomTitle" style="font-size:18px;font-weight:bold;margin-bottom:6px;display:none;"></div>

<div id="panel" style="display:none">
  <button id="resetBtn">ìƒˆë¡œ ì‹œì‘</button>
  <button id="helpBtn" onclick="openHelp()">ë„ì›€ë§</button>
  <button id="endBtn">ê²Œì„ ì¢…ë£Œ</button>
</div>

<div id="turnLine" style="display:none">í˜„ì¬ í„´: <span id="turnColor"></span> <span id="timer"></span></div>
<div id="scores" style="display:none">P1(ë¹¨ê°•): <span id="s1">0</span> / P2(íŒŒë‘): <span id="s2">0</span></div>

<div id="wrap"><div id="board"></div></div>
<div id="bottomBar" style="display:none"><button id="skipWallBtn" disabled>ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜</button></div>

<div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div id="helpCard">
    <div id="helpHeader"><span id="helpTitle">ê²Œì„ ì„¤ëª…</span></div>
    <div id="helpBody">
      <!-- ê¸°ì¡´ ê²Œì„ ì„¤ëª… ë¦¬ìŠ¤íŠ¸ -->
    </div>
    <div id="helpFooter"><button class="helpBtn" id="helpCloseBtn">ì‹œì‘í•˜ê¸°</button></div>
  </div>
</div>

<script type="module">


/* DOM ì—˜ë¦¬ë¨¼íŠ¸ ì°¸ì¡° */
const boardEl   = document.getElementById('board');
const skipWallBtn = document.getElementById('skipWallBtn');
const turnEl    = document.getElementById('turnColor');
const s1El      = document.getElementById('s1');
const s2El      = document.getElementById('s2');
const resetBtn = document.getElementById('resetBtn');
const endBtn   = document.getElementById('endBtn');
// ===== ì˜¤ë””ì˜¤ ê°ì²´ =====
const audioMal  = new Audio('mal.mp3');
const audioWall = new Audio('wall.mp3');
const audioWin  = new Audio('win.mp3');

/* ìƒˆë¡œ ì‹œì‘ / ì¢…ë£Œ ë²„íŠ¼ ë™ì‘ */
resetBtn?.addEventListener('click', () => {
  local.selected = null;
  local.prevWallCount = null;
  local.state = initialState();
  renderFromState();
});

endBtn?.addEventListener('click', () => {
  if (!confirm('í˜„ì¬ ìƒí™©ìœ¼ë¡œ ê²Œì„ì„ ì¢…ë£Œí• ê¹Œìš”?')) return;

  // ì ìˆ˜ ê³„ì‚°(ë‹¨ë… ì†Œìœ  ì˜ì—­ë§Œ í•©ì‚°)
  const { regions } = computeRegionsLocal();
  const sc = [0, 0];
  for (const reg of regions) {
    if (reg.players.size === 1) {
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];

  // ì¢…ë£Œ ì²˜ë¦¬: ì˜ì—­ ì¹ í•˜ê³  ê²°ê³¼ ì•Œë¦¼
  local.state.phase = 'ended';
  fillFinalRegionsLocal();
  showWinnerWithPaintLocal();
});
function randomChoice(arr){
  return (arr && arr.length) ? arr[Math.floor(Math.random()*arr.length)] : null;
}

/* ê²Œì„ ìƒìˆ˜/ìƒíƒœ */
const BOARD_POINTS = 7;
const GRID = BOARD_POINTS * 2 - 1;      // 7ì  â†’ 13ê·¸ë¦¬ë“œ
const COLORS = ['#e74c3c', '#3498db'];  // P1 ë¹¨ê°• / P2 íŒŒë‘
let grid = [];                           // ë³´ë“œ ì…€ 2ì°¨ì› ë°°ì—´

/* ë³´ì¡° í•¨ìˆ˜ */
function pt(p){ return (p-1)*2; }
const asArray = x => Array.isArray(x) ? x : (x && typeof x==='object') ? Object.values(x) : [];
function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
function isPoint(r,c){ return (r%2===0) && (c%2===0); }
function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }

/* ì´ˆê¸° ìƒíƒœ */
function initialState(){
  return {
    phase:'place-extra',
    current:0,
    extraOrder:[0,1,1,0],
    extraIdx:0,
    pieces:{ 
      '0':[ {r:pt(2),c:pt(2)}, {r:pt(6),c:pt(6)} ],
      '1':[ {r:pt(6),c:pt(2)}, {r:pt(2),c:pt(6)} ]
    },
    walls:[],
    lastMoved:null
  };
}

/* ìƒíƒœ ì •ê·œí™” */
function normalizeState(s){
  if(!s) return s;
  s.walls = asArray(s.walls);
  if(!s.pieces) s.pieces={'0':[],'1':[]};
  s.pieces['0']=asArray(s.pieces['0']);
  s.pieces['1']=asArray(s.pieces['1']);
  s.extraOrder=asArray(s.extraOrder||[0,1,1,0]);
  if (s.lastMoved && (typeof s.lastMoved.r!=='number' || typeof s.lastMoved.c!=='number')) s.lastMoved=null;
  return s;
}

/* ë²½(ë¯¸ë°°ì¹˜) í†µê³¼ ê°€ëŠ¥í•œ ì´ì›ƒ ì  ì°¾ê¸° */
function neighborsReachable(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;                 // ì  ì‚¬ì´ê°€ ì•„ë‹ˆë¼ë©´ ì´ë™ ë¶ˆê°€
    if(wall.classList.contains('placed')) continue;  // ì´ë¯¸ ë²½ì´ ìˆìœ¼ë©´ í†µê³¼ ë¶ˆê°€
    if(grid[nr][nc].querySelector('.piece')) continue; // ë„ì°©ì ì— ë§ ìˆìœ¼ë©´ ë¶ˆê°€
    out.push({nr,nc});
  }
  return out;
}

/* ë²½ ê¸°ì¤€ ì—°ê²° ì´ì›ƒ(ì˜ì—­ ê³„ì‚°ìš©) */
function neighborsByWall(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;
    if(wall.classList.contains('placed')) continue; // ë²½ì´ ìˆìœ¼ë©´ ë§‰í˜
    out.push({nr,nc});
  }
  return out;
}

/* ì„ íƒ ë§ì—ì„œ 2ìŠ¤í… ì´ë‚´ ì´ë™ ê°€ëŠ¥ ì  í‘œì‹œ */
function showMovableFrom(sr,sc){
  clearMovable();
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true; let cnt=0;
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
      grid[r][c].classList.add('movable'); cnt++;
    }
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return cnt;
}

/* ë³´ë“œ ë¦¬ì‚¬ì´ì¦ˆ(ê°„ë‹¨ ë²„ì „) â€” ì—†ìœ¼ë©´ ì—ëŸ¬ ë‚˜ë¯€ë¡œ ì •ì˜ */
function resizeBoard(){
  boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
  boardEl.style.gridTemplateRows    = `repeat(${GRID}, auto)`;
}


/** ë§ì´ ë†“ì¼ ìˆ˜ ìˆëŠ” ëª¨ë“  ë¹ˆ ì (ë°°ì¹˜ ë‹¨ê³„ìš©) */
function allEmptyPoints(s){
  const occ = new Set();
  for (const pid of ['0','1']){
    for (const p of s.pieces[pid]) occ.add(`${p.r},${p.c}`);
  }
  const out=[];
  for (let r=0; r<GRID; r+=2){
    for (let c=0; c<GRID; c+=2){
      if (!occ.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}

/** (ë²½ì„ ê³ ë ¤í•´) sr,scì—ì„œ ë§¨í•´íŠ¼ 2ìŠ¤í… ì´ë‚´ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ëª©ì ì§€ ëª©ë¡ */
function listMovable(s, sr, sc){
  // ê·¸ë¦¬ë“œ/ë²½/ì ìœ  ìƒíƒœëŠ” DOMì„ ê·¸ëŒ€ë¡œ ì‚¬ìš© (grid, neighborsReachable)
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true;
  const dest=[];
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
      dest.push({r,c});
    }
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}

/** íŠ¹ì • ì  ì£¼ë³€(ìƒí•˜ì¢Œìš°)ì˜ ë¹ˆ ë²½ ì¹¸ ë°˜í™˜ (íƒ€ì„ì•„ì›ƒ/AI ë²½ ì„¤ì¹˜ìš©) */
function adjacentEmptyWallsOfPoint(s, pr, pc){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const cand = [{r:pr-1,c:pc},{r:pr+1,c:pc},{r:pr,c:pc-1},{r:pr,c:pc+1}];
  return cand.filter(({r,c})=>{
    const inBoard = r>=0 && r<GRID && c>=0 && c<GRID;
    const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
    const free = !occupied.has(`${r},${c}`);
    return inBoard && isWallPos && free;
  });
}

/** ë³´ë“œì˜ ëª¨ë“  ë¹ˆ ë²½ ì¹¸ ëª©ë¡ (íƒ€ì„ì•„ì›ƒ/AI ë²½ ì„¤ì¹˜ìš©) */
function listEmptyWallsFromState(s){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const out=[];
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
      if(!isWallPos) continue;
      if(!occupied.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}


/* ================= URL ëª¨ë“œ ================= */
const params = new URLSearchParams(location.search);
const mode = params.get('mode') || 'solo';
const level = params.get('level') || 'easy';
const roomName = params.get('room') || '';

let local = { roomId:null, role:0, state:null, selected:null, prevWallCount:null, isSolo:false, aiLevel:level };

if (mode === 'solo') {
  local.isSolo = true;
  enterSoloGame();
} else {
  initFirebase();
  if (mode === 'create') createRoom(roomName);
  if (mode === 'join') joinRoom(roomName);
}

/* ================= Firebase ì˜¨ë¼ì¸ í•¨ìˆ˜ ================= */
function initFirebase(){
  // Firebase ì´ˆê¸°í™” & ìµëª… ë¡œê·¸ì¸ (ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ)
}
function createRoom(name){
  // ë°© ìƒì„± (ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ)
}
function joinRoom(name){
  // ë°© ì°¸ì—¬ (ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ)
}

/* ================= ì‹±ê¸€ëª¨ë“œ ì‹œì‘ ================= */
function enterSoloGame(){
  document.getElementById('panel').style.display='flex';
  document.getElementById('turnLine').style.display='block';
  document.getElementById('scores').style.display='block';
  document.getElementById('bottomBar').style.display='flex';
  makeBoard();
  resizeBoard();
  local.state = initialState();
  renderFromState();
}

/* ================= commitState ================= */
async function commitState(){
  if(local.isSolo){
    renderFromState();
    const s = normalizeState(local.state);
    if (s && s.current===1 && (s.phase==='move' || s.phase==='wall' || s.phase==='place-extra')) {
      setTimeout(aiTurn, 500);
    }
    return;
  }
  // ì˜¨ë¼ì¸ ëª¨ë“œ â†’ Firebase set()
}

/* ================= AI ë¡œì§ ================= */
function aiTurn(){
  const s = normalizeState(local.state);
  if (!s || s.current !== 1) return;

  if (s.phase === 'place-extra') aiPlaceExtra(s);
  else if (s.phase === 'move') aiMove(s);
  else if (s.phase === 'wall') aiPlaceWall(s);

  renderFromState();
  if (s.phase !== 'ended') commitState();
}
function aiPlaceExtra(s){
  const points = allEmptyPoints(s);
  const pick = randomChoice(points);
  s.pieces['1'].push({r:pick.r,c:pick.c});
  s.extraIdx++;
  if(s.extraIdx >= s.extraOrder.length) s.phase='move';
  else s.current = s.extraOrder[s.extraIdx];
}
/* ===== ê°•í™”ëœ íœ´ë¦¬ìŠ¤í‹± í—¬í¼ ===== */

// (r,c)ê°€ ì†í•œ êµ¬ì—­ì— ì¡´ì¬í•˜ëŠ” í”Œë ˆì´ì–´ ì§‘í•©
function playersInRegion(r, c){
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const q = [{ r, c }];
  visited[r][c] = true;
  const present = new Set();
  while(q.length){
    const cur = q.shift();
    const piece = grid[cur.r][cur.c].querySelector('.piece');
    if (piece) present.add(+piece.dataset.player);
    for (const { nr, nc } of neighborsByWall(cur.r, cur.c)){
      if (!visited[nr][nc]){ visited[nr][nc] = true; q.push({ r:nr, c:nc }); }
    }
  }
  return present; // ì˜ˆ: Set {0}, Set {1}, Set {0,1}
}

// ëª©ì ì§€ ê¸°ì¤€ ì´ë™ ììœ ë„(ë‚´ê°€ ê·¸ ì¹¸ì— ìˆì„ ë•Œ 2ìŠ¤í… ì´ë‚´ ëª©ì ì§€ ìˆ˜)
function mobilityAt(r, c){
  // í˜„ì¬ ë²½ ìƒíƒœë¥¼ ê·¸ëŒ€ë¡œ ì“°ê³ , ë§ ì ìœ ë§Œ ì²´í¬
  let cnt = 0;
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r, c, d:0}]; v[r][c]=true;
  while(q.length){
    const cur=q.shift();
    if(cur.d>0 && cur.d<=2 && isPoint(cur.r,cur.c) && !grid[cur.r][cur.c].querySelector('.piece')) cnt++;
    if(cur.d===2) continue;
    for(const {nr,nc} of neighborsReachable(cur.r,cur.c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:cur.d+1}); }
    }
  }
  return cnt;
}

// ë²½ ì¢Œí‘œ(wr,wc)ê°€ ê°€ë¥´ëŠ” ë‘ ì ì„ êµ¬í•¨ (ì—†ìœ¼ë©´ null)
function wallEndpoints(wr, wc){
  if (wr%2===1 && wc%2===0) return [{r:wr-1,c:wc},{r:wr+1,c:wc}]; // ê°€ë¡œë²½: ìœ„ì -ì•„ë˜ì 
  if (wr%2===0 && wc%2===1) return [{r:wr,c:wc-1},{r:wr,c:wc+1}]; // ì„¸ë¡œë²½: ì™¼ì -ì˜¤ë¥¸ì 
  return null;
}

// í›„ë³´ ë²½ì´ ìƒëŒ€ ê¸°ë™ë ¥ì— ì£¼ëŠ” ì°¨ë‹¨ ì ìˆ˜(ê·¼ì ‘ ìƒëŒ€ ë§ ìˆ˜ + ì¸ì ‘ ì  ì´ë™ë¡œ ì°¨ë‹¨ ìˆ˜)
function blockScoreForWall(wr, wc, opponent=0){
  const ends = wallEndpoints(wr, wc);
  if (!ends) return 0;

  // 1) ë²½ ì–‘ë ì£¼ë³€ 2-ë§¨í•´íŠ¼ ì•ˆì˜ ìƒëŒ€ ë§ ìˆ˜
  let nearOpp = 0;
  for (const pidEl of document.querySelectorAll('.piece')){
    const pid = +pidEl.dataset.player;
    if (pid!==opponent) continue;
    const cell = pidEl.parentElement;
    const rc = cellToRC(cell);
    if (!rc) continue;
    const d = Math.abs(rc.r-ends[0].r)+Math.abs(rc.c-ends[0].c);
    const e = Math.abs(rc.r-ends[1].r)+Math.abs(rc.c-ends[1].c);
    if (Math.min(d,e) <= 2) nearOpp++;
  }

  // 2) í˜„ì¬ ê°œë°©ëœ í†µë¡œì¸ì§€(=ì§€ê¸ˆì€ í†µê³¼ ê°€ëŠ¥, ë²½ì„ ë‘ë©´ ë§‰í˜) ê°€ì‚°
  let openPass = 0;
  const [A,B] = ends;
  // neighborsReachableì€ ì â†’ì´ì›ƒì ì´ "ì—´ë ¤ìˆê³  ë„ì°©ì  ë¹„ì–´ì•¼" trueì´ë¯€ë¡œ,
  // í†µë¡œê°€ ì—´ë ¤ìˆê³  ë„ì°©ì´ ë¹ˆ ì ì´ë¼ë©´ ì‹¤ì œë¡œ ì´ë™ í›„ë³´ì— ë‚˜íƒ€ë‚¨
  const neighA = neighborsReachable(A.r, A.c).some(v => v.nr===B.r && v.nc===B.c);
  const neighB = neighborsReachable(B.r, B.c).some(v => v.nr===A.r && v.nc===A.c);
  if (neighA || neighB) openPass = 1;

  // ê°€ì¤‘ í•©: ìƒëŒ€ ê·¼ì ‘ë„ *2 + ê°œë°© í†µë¡œ ì°¨ë‹¨ *3
  return nearOpp*2 + openPass*3;
}

// DOM ì…€ â†’ ë³´ë“œ ì¢Œí‘œ (r,c)
function cellToRC(cell){
  if (!cell) return null;
  // grid[r][c]ë¥¼ ë§Œë“¤ì–´ë‘˜ ë•Œ ì°¸ì¡°ë¥¼ ì €ì¥í–ˆìœ¼ë¯€ë¡œ, ë¹ ë¥´ê²Œ ì—­íƒìƒ‰:
  for (let r=0;r<GRID;r++){
    for (let c=0;c<GRID;c++){
      if (grid[r][c]===cell) return {r,c};
    }
  }
  return null;
}

/* ===================== [ë“œë¡­ì¸ AI êµì²´] 1-ìˆ˜ ì‹œë®¬ë ˆì´ì…˜ ===================== */

/* --- ê°€ì¤‘ì¹˜ (ë‚œì´ë„ì— ë”°ë¼ ìë™ ìŠ¤ì¼€ì¼) --- */
const W_TERR_EZ   = 1.0, W_TRAP_EZ = 0.8, W_MOB_EZ = 0.6, W_CLASH_EZ = 0.6;
const W_TERR_MD   = 1.4, W_TRAP_MD = 1.2, W_MOB_MD = 0.9, W_CLASH_MD = 0.8;
const W_TERR_HARD = 1.8, W_TRAP_HARD = 1.8, W_MOB_HARD = 1.2, W_CLASH_HARD = 1.0;

function weightsByLevel(level){
  if(level==='hard')   return {WT:W_TERR_HARD, WP:W_TRAP_HARD, WM:W_MOB_HARD, WC:W_CLASH_HARD};
  if(level==='medium') return {WT:W_TERR_MD,   WP:W_TRAP_MD,   WM:W_MOB_MD,   WC:W_CLASH_MD};
  return {WT:W_TERR_EZ, WP:W_TRAP_EZ, WM:W_MOB_EZ, WC:W_CLASH_EZ};
}

/* --- ìƒíƒœ ì „ìš© ìœ í‹¸ (DOM ì˜ì¡´ ì—†ìŒ) --- */
function keyRC(r,c){ return `${r},${c}`; }
function wallKey(wr,wc){ return `w:${wr},${wc}`; }

function pointsNeighborsByWalls(wallsSet, r, c){
  const out=[];
  const dirs = [[-2,0],[2,0],[0,-2],[0,2]];
  for(const [dr,dc] of dirs){
    const nr=r+dr, nc=c+dc;
    if(nr<0||nr>=GRID||nc<0||nc>=GRID||nr%2||nc%2) continue;
    const wr=r+dr/2, wc=c+dc/2;
    if(wallsSet.has(wallKey(wr,wc))) continue; // ë²½ì´ë©´ ë§‰í˜
    out.push([nr,nc]);
  }
  return out;
}

function listMovableState(wallsSet, occSet, sr, sc){
  const v = new Set([keyRC(sr,sc)]);
  const q = [{r:sr,c:sc,d:0}];
  const dest=[];
  while(q.length){
    const {r,c,d} = q.shift();
    if(d>0 && d<=2 && !occSet.has(keyRC(r,c))) dest.push({r,c});
    if(d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,r,c)){
      const k = keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}

function mobilityAtState(wallsSet, occSet, r, c){
  const v = new Set([keyRC(r,c)]);
  const q = [{r,c,d:0}];
  let cnt=0;
  while(q.length){
    const cur = q.shift();
    if(cur.d>0 && cur.d<=2 && !occSet.has(keyRC(cur.r,cur.c))) cnt++;
    if(cur.d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cur.r,cur.c)){
      const k=keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:cur.d+1}); }
    }
  }
  return cnt;
}

function regionsFromState(wallsSet, p0Set, p1Set){
  const visited = new Set();
  const regs=[];
  for(let r=0;r<GRID;r+=2){
    for(let c=0;c<GRID;c+=2){
      const start = keyRC(r,c);
      if(visited.has(start)) continue;
      const q=[[r,c]];
      visited.add(start);
      const points=[];
      let has0=false, has1=false;
      while(q.length){
        const [cr,cc]=q.shift();
        points.push([cr,cc]);
        const k=keyRC(cr,cc);
        if(p0Set.has(k)) has0=true;
        if(p1Set.has(k)) has1=true;
        for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cr,cc)){
          const nk=keyRC(nr,nc);
          if(!visited.has(nk)){ visited.add(nk); q.push([nr,nc]); }
        }
      }
      regs.push({points, has0, has1});
    }
  }
  return regs;
}

function territoryDiffAfter(wallsSet, p0Set, p1Set){
  const regs = regionsFromState(wallsSet,p0Set,p1Set);
  let me=0, opp=0;
  for(const reg of regs){
    if(reg.has0 && !reg.has1) opp+=reg.points.length;
    else if(reg.has1 && !reg.has0) me+=reg.points.length;
  }
  return me - opp; // ë‚´ ìˆœì˜ì—­
}

/* --- 1-ìˆ˜(ì´ë™+ë²½) ì‹œë®¬ë ˆì´ì…˜ í‰ê°€ --- */
function evaluateMovePlusBestWall(s, pieceFrom, moveTo, level){
  const {WT,WP,WM,WC} = weightsByLevel(level);

  // ì„¸íŠ¸ êµ¬ì„±
  const wallsSet = new Set(s.walls.map(w=>wallKey(w.r,w.c)));
  const p0Set = new Set(s.pieces['0'].map(p=>keyRC(p.r,p.c)));
  const p1 = s.pieces['1'].map(p=>({r:p.r,c:p.c}));
  // ë‚´ ë§ ì´ë™ ê°€ìƒ ë°˜ì˜
  const idx = p1.findIndex(pp => pp.r===pieceFrom.r && pp.c===pieceFrom.c);
  p1[idx] = {r:moveTo.r, c:moveTo.c};
  const p1Set = new Set(p1.map(p=>keyRC(p.r,p.c)));

  // ê¸°ë™ë ¥(ì´ë™ í›„ ê¸°ì¤€)
  const occForMob = new Set([...p0Set, ...p1Set]);
  const myMob = mobilityAtState(wallsSet, occForMob, moveTo.r, moveTo.c);

  // ìƒëŒ€ ê¸°ë™ë ¥ ì´í•© (ì¡ëŠ”/ê°€ë‘ëŠ” ê°€ì¹˜ ë°˜ì˜)
  let oppMobBefore=0, oppMobAfter=0;
  for(const k of p0Set){
    const [r,c] = k.split(',').map(Number);
    oppMobBefore += mobilityAtState(wallsSet, occForMob, r, c);
  }

  // ë²½ í›„ë³´: ì´ë™ì§€ ì£¼ë³€ ìš°ì„ , ì—†ìœ¼ë©´ ì „ì²´ ë¹ˆ ë²½
  let candWalls = [];
  for(const [wr,wc] of [[moveTo.r-1,moveTo.c],[moveTo.r+1,moveTo.c],[moveTo.r,moveTo.c-1],[moveTo.r,moveTo.c+1]]){
    const isWallPos = wr>=0&&wr<GRID&&wc>=0&&wc<GRID && ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
    if(isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr,c:wc});
  }
  if(candWalls.length===0){
    for(let wr=0;wr<GRID;wr++){
      for(let wc=0;wc<GRID;wc++){
        const isWallPos = ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
        if(isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr,c:wc});
      }
    }
  }

  // ê° ë²½ì„ ê°€ì •í•´ ìµœê³  ì ìˆ˜ ì„ íƒ
  let bestScore=-Infinity, bestWall=null;
  for(const w of candWalls){
    const ws = new Set(wallsSet); ws.add(wallKey(w.r,w.c));

    // ì˜ì—­ ì°¨(ë‚´-ìƒëŒ€)
    const terrDiff = territoryDiffAfter(ws, p0Set, p1Set);

    // ìƒëŒ€ ê¸°ë™ë ¥(ë²½ ë°˜ì˜ í›„)
    oppMobAfter = 0;
    for(const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      oppMobAfter += mobilityAtState(ws, occForMob, r, c);
    }
    const trapGain = Math.max(0, oppMobBefore - oppMobAfter); // ì¤„ì—ˆì„ìˆ˜ë¡ ì¢‹ìŒ

    // ì¶©ëŒ ìœ„í—˜(ìƒëŒ€ì™€ ë„ˆë¬´ ë¶™ì–´ìˆìœ¼ë©´ í˜ë„í‹°)
    let minOpp=Infinity;
    for(const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      const d = Math.abs(r - moveTo.r) + Math.abs(c - moveTo.c);
      if(d<minOpp) minOpp=d;
    }
    const clashPenalty = Math.max(0, 3 - (isFinite(minOpp)?minOpp:99)); // 1~2ì¹¸ì´ë©´ 1~2 í˜ë„í‹°

    const score = WT*terrDiff + WP*trapGain + WM*myMob - WC*clashPenalty;
    if(score>bestScore){ bestScore=score; bestWall=w; }
  }

  return {score: bestScore, bestWall};
}

/* --- AI ë©”ì¸: ì´ë™+ë²½ ë™ì‹œ ê²°ì • --- */
function aiMove(s){
  const myPieces = s.pieces['1'];
  let best=null, bestScore=-Infinity, bestWall=null;

  // í˜„ì¬ ì ìœ  ì„¸íŠ¸(ì‹œë®¬ ëª©ì )
  for(const p of myPieces){
    const moves = listMovable(s, p.r, p.c); // â† DOM ê¸°ë°˜ì´ì§€ë§Œ "í˜„ì¬" ìƒíƒœ ì¡°íšŒëŠ” OK
    for(const m of moves){
      const {score, bestWall:wallChoice} = evaluateMovePlusBestWall(s, p, m, local.aiLevel);
      if(score>bestScore){ bestScore=score; best={from:p, to:m}; bestWall=wallChoice; }
    }
  }

  if(best){
    // ì‹¤ì œ ë°˜ì˜
    const arr = s.pieces['1'];
    const idx = arr.findIndex(pp=>pp.r===best.from.r && pp.c===best.from.c);
    arr[idx] = {r:best.to.r, c:best.to.c};
    s.phase = 'wall';
    s.lastMoved = {r:best.to.r, c:best.to.c};
     audioMal.play();

    // ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ë²½ì„ ë°”ë¡œ ë‘˜ ìˆ˜ ìˆë„ë¡ ì €ì¥
    s._aiPlannedWall = bestWall; // ì„ì‹œ ì†ì„±
  }
}

function aiPlaceWall(s){
  let pick = s._aiPlannedWall || null;
  if(!pick){
    // í˜¹ì‹œ ì´ë™ ë‹¨ê³„ì—ì„œ ëª» ì •í–ˆìœ¼ë©´(ì´ë™ ë¶ˆê°€ ë“±) ê¸°ë³¸ í›„ë³´ë¡œ ë³´ì •
    let candidates = [];
    if (s.lastMoved) candidates = adjacentEmptyWallsOfPoint(s, s.lastMoved.r, s.lastMoved.c);
    if (candidates.length === 0) candidates = listEmptyWallsFromState(s);
    pick = candidates && candidates.length ? candidates[0] : null;
  }
  if(pick) s.walls.push({ r:pick.r, c:pick.c, owner:1 });
  audioWall.play();

  delete s._aiPlannedWall;
  s.current = 0; s.phase = 'move'; s.lastMoved = null;
}

/* --- ë” ì´ìƒ ì“°ì§€ ì•ŠìŒ: evalMoveScore (ë‚¨ê²¨ë‘ë©´ í˜¸ì¶œë˜ì§€ ì•Šë„ë¡ ì£¼ì„ì²˜ë¦¬) --- */
// function evalMoveScore(...) { ... }





function distToOpponent(pos) {
  const oppPieces = local.state.pieces['0']; // AIëŠ” 1ë²ˆ í”Œë ˆì´ì–´ë¡œ ê°€ì •
  let minDist = Infinity;
  for (const p of oppPieces) {
    const d = Math.abs(p.r - pos.r) + Math.abs(p.c - pos.c);
    if (d < minDist) minDist = d;
  }
  return minDist;
}

function distToCenter(pos) {
  const center = { r: Math.floor(GRID/2), c: Math.floor(GRID/2) };
  return Math.abs(center.r - pos.r) + Math.abs(center.c - pos.c);
}

function freedomScore(pos) {
  return neighborsReachable(pos.r, pos.c).length;
}
function makeBoard() {
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
  boardEl.style.gridTemplateRows = `repeat(${GRID}, auto)`;
  grid = Array.from({ length: GRID }, () => Array(GRID).fill(null));

  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');

      if (r % 2 === 0 && c % 2 === 0) {
        cell.classList.add('point');
        cell.addEventListener('click', () => onPointClick(r, c));
      } else if (r % 2 === 1 && c % 2 === 0) {
        cell.classList.add('h-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else if (r % 2 === 0 && c % 2 === 1) {
        cell.classList.add('v-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else {
        cell.classList.add('blank');
      }

      boardEl.appendChild(cell);
      grid[r][c] = cell;
    }
  }
  resizeBoard();
}
function renderFromState() {
  const s = normalizeState(local.state);
  if (!s) return;

  const phaseLabel = s.phase === 'place-extra' ? ' â€” ë§ ë°°ì¹˜'
                    : s.phase === 'move' ? ' â€” ë§ ì´ë™'
                    : s.phase === 'wall' ? ' â€” ë²½ ì„¤ì¹˜'
                    : s.phase === 'ended' ? ' â€” ì¢…ë£Œ' : '';
  turnEl.textContent = ((s.current === 0) ? 'P1(ë¹¨ê°•)' : 'P2(íŒŒë‘)') + ' ì°¨ë¡€' + phaseLabel;
  turnEl.style.color = COLORS[s.current];

  skipWallBtn.disabled = !(s.phase === 'move' && s.current === local.role);

  document.querySelectorAll('.piece').forEach(el => el.remove());
  for (const pid of [0, 1]) {
    for (const p of s.pieces[String(pid)]) {
      const cell = grid[p.r]?.[p.c];
      if (!cell) continue;
      const dot = document.createElement('div');
      dot.classList.add('piece');
      dot.style.background = COLORS[pid];
      dot.dataset.player = String(pid);
      cell.appendChild(dot);
    }
  }

  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = grid[r][c];
      if (!cell) continue;
      if (cell.classList.contains('h-wall') || cell.classList.contains('v-wall')) {
        cell.classList.remove('placed');
        cell.style.background = '#fff';
      }
    }
  }
  for (const w of s.walls) {
    const cell = grid[w.r]?.[w.c];
    if (cell) {
      cell.classList.add('placed');
      cell.style.background = COLORS[w.owner];
    }
  }

  updateScoresLocal();
}
function onPointClick(r, c) {
  const s = normalizeState(local.state);
  if (!s) return;

  if (s.phase === 'place-extra') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    if (cell.querySelector('.piece')) return;
    s.pieces[String(s.current)].push({ r, c });
    audioMal.play();   // ğŸ”Š ë§ ë†“ê¸° ì†Œë¦¬
    s.extraIdx++;
    if (s.extraIdx >= s.extraOrder.length) {
      s.phase = 'move';
    } else {
      s.current = s.extraOrder[s.extraIdx];
    }
    commitState();
    return;
  }

  if (s.phase === 'move') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    const piece = cell.querySelector('.piece');

    if (local.selected && local.selected.r === r && local.selected.c === c) {
      local.selected = null;
      clearMovable();
      return;
    }

    if (!local.selected && piece && +piece.dataset.player === local.role) {
      local.selected = { r, c };
      const cnt = showMovableFrom(r, c);
      if (cnt === 0) {
        local.selected = null;
        clearMovable();
      }
      return;
    }

    if (local.selected && cell.classList.contains('movable')) {
      const arr = s.pieces[String(local.role)];
      const idx = arr.findIndex(p => p.r === local.selected.r && p.c === local.selected.c);
      if (idx >= 0) {
        arr[idx] = { r, c };
        audioMal.play();   // ğŸ”Š ë§ ì´ë™ ì†Œë¦¬
        s.phase = 'wall';
        s.lastMoved = { r, c };
        clearMovable();
        local.selected = null;
        commitState();
      }
    }
  }
}

function onWallClick(r, c) {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'wall' || s.current !== local.role) return;
  const cell = grid[r][c];
  const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
  if (!isWall || cell.classList.contains('placed')) return;

  s.walls.push({ r, c, owner: local.role });
  audioWall.play();  // ğŸ”Š ë²½ ì„¤ì¹˜ ì†Œë¦¬
  s.current = 1 - s.current;
  s.phase = 'move';
  s.lastMoved = null;
  clearMovable();
  commitState();
}

skipWallBtn.addEventListener('click', () => {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'move' || s.current !== local.role) return;
  clearMovable();
  local.selected = null;
  s.phase = 'wall';
  s.lastMoved = null;
  commitState();
});
function computeRegionsLocal() {
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const regions = [];
  let hasMixed = false;

  for (let r = 0; r < GRID; r += 2) {
    for (let c = 0; c < GRID; c += 2) {
      if (visited[r][c]) continue;
      const q = [{ r, c }];
      visited[r][c] = true;
      const pts = [];
      const present = new Set();
      while (q.length) {
        const cur = q.shift();
        pts.push(cur);
        const piece = grid[cur.r][cur.c].querySelector('.piece');
        if (piece) present.add(+piece.dataset.player);
        for (const { nr, nc } of neighborsByWall(cur.r, cur.c)) {
          if (!visited[nr][nc]) {
            visited[nr][nc] = true;
            q.push({ r: nr, c: nc });
          }
        }
      }
      if (present.size >= 2) hasMixed = true;
      regions.push({ points: pts, players: present });
    }
  }
  return { regions, hasMixed };
}

function updateScoresLocal(){
  const ended = checkGameEndAndScoreLocal();
  if (ended && local.state?.phase !== 'ended'){
    local.state.phase = 'ended';
    showWinnerWithPaintLocal();
  }
}

function showWinnerWithPaintLocal(){
  audioWin.play(); // ğŸ”Š ê²½ê¸° ì¢…ë£Œ ì†Œë¦¬
  fillFinalRegionsLocal(); // ìµœì¢… ì˜ì—­ ì¹ í•˜ê¸°
  const p1 = +s1El.textContent, p2 = +s2El.textContent;
  alert(
    `ê²Œì„ ì¢…ë£Œ!\nP1(ë¹¨ê°•): ${p1} / P2(íŒŒë‘): ${p2}\n` +
    (p1>p2 ? 'ìŠ¹ì: P1(ë¹¨ê°•)' : p2>p1 ? 'ìŠ¹ì: P2(íŒŒë‘)' : 'ë¬´ìŠ¹ë¶€')
  );
}

/* ë³´ë“œ ì—°ê²°ì„ ê¸°ì¤€ìœ¼ë¡œ ì˜ì—­ì„ ê³„ì‚°í•´ ì ìˆ˜ë¥¼ ì‚°ì¶œí•˜ê³ ,
   ë‘ í”Œë ˆì´ì–´ ë§ì´ í•¨ê»˜ ìˆëŠ” ì˜ì—­ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì¢…ë£Œ */
function checkGameEndAndScoreLocal(){
  const { regions, hasMixed } = computeRegionsLocal();
  const sc = [0, 0];

  for (const reg of regions){
    if (reg.players.size === 1){
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;     // í•´ë‹¹ ì˜ì—­ì˜ ëª¨ë“  ì ì„ ì†Œìœ ì ì ìˆ˜ë¡œ
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];

  // í˜¼í•© ì˜ì—­ì´ ì—†ìœ¼ë©´ ëª¨ë“  ì˜ì—­ì˜ ì†Œìœ ìê°€ ê²°ì •ëœ ìƒíƒœ â†’ ì¢…ë£Œ
  return !hasMixed;
}

/* ìµœì¢… ì˜ì—­ì— ìƒ‰ì„ ì¹ í•´ ê°€ì‹œí™” */
function fillFinalRegionsLocal(){
  const { regions } = computeRegionsLocal();
  for (const reg of regions){
    if (reg.players.size !== 1) continue;
    const owner = [...reg.players][0];
    for (const { r, c } of reg.points){
      grid[r][c].classList.remove('movable');
      if (owner === 0) grid[r][c].classList.add('final-p1-region');
      else grid[r][c].classList.add('final-p2-region');
    }
  }
}




/* ===== ë„ì›€ë§ ì˜¤ë²„ë ˆì´ í•¸ë“¤ëŸ¬ ===== */
function openHelp(){ 
  const ov = document.getElementById('helpOverlay');
  if (ov) ov.style.display = 'flex';
}
function closeHelp(){ 
  const ov = document.getElementById('helpOverlay');
  if (ov) ov.style.display = 'none';
}
/* ì „ì—­ì—ì„œ í˜¸ì¶œë  ìˆ˜ ìˆê²Œ ë…¸ì¶œ */
window.openHelp = openHelp;
window.closeHelp = closeHelp;

/* ë‹«ê¸° ë²„íŠ¼/ì˜¤ë²„ë ˆì´ í´ë¦­ìœ¼ë¡œ ë‹«ê¸° */
const helpCloseBtn = document.getElementById('helpCloseBtn');
if (helpCloseBtn) helpCloseBtn.addEventListener('click', closeHelp);
const helpOverlay = document.getElementById('helpOverlay');
if (helpOverlay) {
  helpOverlay.addEventListener('click', (e)=>{
    if (e.target === helpOverlay) closeHelp();
  });
}




/* ======== ë‚˜ë¨¸ì§€ í•¨ìˆ˜ë“¤ ======== 
- distToOpponent, distToCenter, freedomScore
- makeBoard, resizeBoard, renderFromState
- onPointClick, onWallClick, skipWallBtn ì´ë²¤íŠ¸
- ì ìˆ˜ ê³„ì‚°, ìŠ¹ë¦¬ íŒì •
ëª¨ë‘ ê¸°ì¡´ index.html ì½”ë“œì—ì„œ ê·¸ëŒ€ë¡œ ë¶™ì—¬ì£¼ì„¸ìš”
*/
</script>
</body>
</html>
