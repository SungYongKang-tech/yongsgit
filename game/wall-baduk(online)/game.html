<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Wall-baduk 게임</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
    :root { --bar-h: 60px; --p: 42px; --t: 15px; }
    body { font-family: sans-serif; background:#f5f5f5; text-align:center; margin:0; min-height:100vh;
      display:grid; grid-template-rows:auto auto auto auto auto; }
    h1 { margin: 8px 0 4px; }

    /* 로비 */
    #setup { margin:10px 0 4px; }
    #setup .row { display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; }
    #roomInput { width:min(260px, 70vw); padding:10px 12px; border:1px solid #bbb; border-radius:8px; font-size:16px; }
    #setup button { padding:12px 14px; border-radius:10px; border:1px solid #999; background:#fff; cursor:pointer; }
    #roomLine { font-size:13px; color:#555; margin:6px 0 6px; }

    /* 상단 패널 */
    #panel { margin:4px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    #panel button { padding:10px 14px; border:1px solid #999; border-radius:10px; background:#fff; cursor:pointer; }

    #turnLine { margin:2px 0; font-size:16px; display:flex; gap:8px; justify-content:center; align-items:center; }
    #turnColor { font-weight:700; }
    #timer { font-variant-numeric: tabular-nums; padding:2px 6px; border:1px solid #ddd; border-radius:8px; background:#fff;
      min-width: 54px; display:inline-block; }
    #scores { margin:0 0 4px; font-size:14px; }

    /* 오디오 컨트롤 */
    .audio-wrap { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; }
    #volSlider { width: 160px; }
    #volVal { min-width:36px; display:inline-block; text-align:right; }

    /* 보드 */
    #wrap { display:flex; justify-content:center; align-items:flex-start; padding:0 10px 6px; overflow:auto; }
    #board { display:grid; background:#fff; border:2px solid #333; user-select:none; touch-action:manipulation; }
    .cell { box-sizing:border-box; border:1px solid #000; display:flex; align-items:center; justify-content:center; }

    .point { width:var(--p); height:var(--p); background:#fff; position:relative; cursor:pointer; transition:background .1s; }
    .piece { width:80%; height:80%; border-radius:50%; pointer-events:none; }
    .h-wall { width:var(--p); height:var(--t); background:#fff; cursor:pointer; }
    .v-wall { width:var(--t); height:var(--p); background:#fff; cursor:pointer; }
    .blank  { width:var(--t); height:var(--t); background:#15326b; }

    .movable { background:#d0d0d0 !important; }
    .final-p1-region { background:#ffd6e7 !important; }
    .final-p2-region { background:#d6ecff !important; }

    #bottomBar { position:sticky; bottom:0; left:0; right:0; background:#ffffffcc; backdrop-filter:blur(6px);
      border-top:1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center; padding:6px 12px; }
    #skipWallBtn { width:min(340px,92vw); height:40px; border-radius:12px; font-weight:700; background:#ffd6e7; border:1px solid #e7a3bd; }
    button:disabled { opacity:.5; cursor:not-allowed; }

    /* 도움말 모달 */
    #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:10000; padding:16px; }
    #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
    #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
    #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
    #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
    #helpBody ul ul { margin-left:6px; padding-left:10px; }
    #helpBody li { margin:4px 0; }
    #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
    .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }

    @media (max-width:420px){ #volSlider { width:120px; } }
  </style>
</head>
<body>
<h1>Wall-baduk (벽바둑)</h1>
<div id="gameRoomTitle" style="font-size:18px;font-weight:bold;margin-bottom:6px;display:none;"></div>

<div id="panel" style="display:none">
  <button id="resetBtn">새로 시작</button>
  <button id="helpBtn" onclick="openHelp()">도움말</button>
  <button id="endBtn">게임 종료</button>
</div>

<div id="turnLine" style="display:none">현재 턴: <span id="turnColor"></span> <span id="timer"></span></div>
<div id="scores" style="display:none">P1(빨강): <span id="s1">0</span> / P2(파랑): <span id="s2">0</span></div>

<div id="wrap"><div id="board"></div></div>
<div id="bottomBar" style="display:none"><button id="skipWallBtn" disabled>이동 없이 벽 설치</button></div>

<div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div id="helpCard">
    <div id="helpHeader"><span id="helpTitle">게임 설명</span></div>
    <div id="helpBody">
      <!-- 기존 게임 설명 리스트 -->
    </div>
    <div id="helpFooter"><button class="helpBtn" id="helpCloseBtn">시작하기</button></div>
  </div>
</div>

<script type="module">


/* DOM 엘리먼트 참조 */
const boardEl   = document.getElementById('board');
const skipWallBtn = document.getElementById('skipWallBtn');
const turnEl    = document.getElementById('turnColor');
const s1El      = document.getElementById('s1');
const s2El      = document.getElementById('s2');
const resetBtn = document.getElementById('resetBtn');
const endBtn   = document.getElementById('endBtn');
// ===== 오디오 객체 =====
const audioMal  = new Audio('mal.mp3');
const audioWall = new Audio('wall.mp3');
const audioWin  = new Audio('win.mp3');

/* 새로 시작 / 종료 버튼 동작 */
resetBtn?.addEventListener('click', () => {
  local.selected = null;
  local.prevWallCount = null;
  local.state = initialState();
  renderFromState();
});

endBtn?.addEventListener('click', () => {
  if (!confirm('현재 상황으로 게임을 종료할까요?')) return;

  // 점수 계산(단독 소유 영역만 합산)
  const { regions } = computeRegionsLocal();
  const sc = [0, 0];
  for (const reg of regions) {
    if (reg.players.size === 1) {
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];

  // 종료 처리: 영역 칠하고 결과 알림
  local.state.phase = 'ended';
  fillFinalRegionsLocal();
  showWinnerWithPaintLocal();
});
function randomChoice(arr){
  return (arr && arr.length) ? arr[Math.floor(Math.random()*arr.length)] : null;
}

/* 게임 상수/상태 */
const BOARD_POINTS = 7;
const GRID = BOARD_POINTS * 2 - 1;      // 7점 → 13그리드
const COLORS = ['#e74c3c', '#3498db'];  // P1 빨강 / P2 파랑
let grid = [];                           // 보드 셀 2차원 배열

/* 보조 함수 */
function pt(p){ return (p-1)*2; }
const asArray = x => Array.isArray(x) ? x : (x && typeof x==='object') ? Object.values(x) : [];
function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
function isPoint(r,c){ return (r%2===0) && (c%2===0); }
function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }

/* 초기 상태 */
function initialState(){
  return {
    phase:'place-extra',
    current:0,
    extraOrder:[0,1,1,0],
    extraIdx:0,
    pieces:{ 
      '0':[ {r:pt(2),c:pt(2)}, {r:pt(6),c:pt(6)} ],
      '1':[ {r:pt(6),c:pt(2)}, {r:pt(2),c:pt(6)} ]
    },
    walls:[],
    lastMoved:null
  };
}

/* 상태 정규화 */
function normalizeState(s){
  if(!s) return s;
  s.walls = asArray(s.walls);
  if(!s.pieces) s.pieces={'0':[],'1':[]};
  s.pieces['0']=asArray(s.pieces['0']);
  s.pieces['1']=asArray(s.pieces['1']);
  s.extraOrder=asArray(s.extraOrder||[0,1,1,0]);
  if (s.lastMoved && (typeof s.lastMoved.r!=='number' || typeof s.lastMoved.c!=='number')) s.lastMoved=null;
  return s;
}

/* 벽(미배치) 통과 가능한 이웃 점 찾기 */
function neighborsReachable(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;                 // 점 사이가 아니라면 이동 불가
    if(wall.classList.contains('placed')) continue;  // 이미 벽이 있으면 통과 불가
    if(grid[nr][nc].querySelector('.piece')) continue; // 도착점에 말 있으면 불가
    out.push({nr,nc});
  }
  return out;
}

/* 벽 기준 연결 이웃(영역 계산용) */
function neighborsByWall(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;
    if(wall.classList.contains('placed')) continue; // 벽이 있으면 막힘
    out.push({nr,nc});
  }
  return out;
}

/* 선택 말에서 2스텝 이내 이동 가능 점 표시 */
function showMovableFrom(sr,sc){
  clearMovable();
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true; let cnt=0;
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
      grid[r][c].classList.add('movable'); cnt++;
    }
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return cnt;
}

/* 보드 리사이즈(간단 버전) — 없으면 에러 나므로 정의 */
function resizeBoard(){
  boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
  boardEl.style.gridTemplateRows    = `repeat(${GRID}, auto)`;
}


/** 말이 놓일 수 있는 모든 빈 점(배치 단계용) */
function allEmptyPoints(s){
  const occ = new Set();
  for (const pid of ['0','1']){
    for (const p of s.pieces[pid]) occ.add(`${p.r},${p.c}`);
  }
  const out=[];
  for (let r=0; r<GRID; r+=2){
    for (let c=0; c<GRID; c+=2){
      if (!occ.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}

/** (벽을 고려해) sr,sc에서 맨해튼 2스텝 이내로 갈 수 있는 목적지 목록 */
function listMovable(s, sr, sc){
  // 그리드/벽/점유 상태는 DOM을 그대로 사용 (grid, neighborsReachable)
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true;
  const dest=[];
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
      dest.push({r,c});
    }
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}

/** 특정 점 주변(상하좌우)의 빈 벽 칸 반환 (타임아웃/AI 벽 설치용) */
function adjacentEmptyWallsOfPoint(s, pr, pc){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const cand = [{r:pr-1,c:pc},{r:pr+1,c:pc},{r:pr,c:pc-1},{r:pr,c:pc+1}];
  return cand.filter(({r,c})=>{
    const inBoard = r>=0 && r<GRID && c>=0 && c<GRID;
    const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
    const free = !occupied.has(`${r},${c}`);
    return inBoard && isWallPos && free;
  });
}

/** 보드의 모든 빈 벽 칸 목록 (타임아웃/AI 벽 설치용) */
function listEmptyWallsFromState(s){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const out=[];
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
      if(!isWallPos) continue;
      if(!occupied.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}


/* ================= URL 모드 ================= */
const params = new URLSearchParams(location.search);
const mode = params.get('mode') || 'solo';
const level = params.get('level') || 'easy';
const roomName = params.get('room') || '';

let local = { roomId:null, role:0, state:null, selected:null, prevWallCount:null, isSolo:false, aiLevel:level };

if (mode === 'solo') {
  local.isSolo = true;
  enterSoloGame();
} else {
  initFirebase();
  if (mode === 'create') createRoom(roomName);
  if (mode === 'join') joinRoom(roomName);
}

/* ================= Firebase 온라인 함수 ================= */
function initFirebase(){
  // Firebase 초기화 & 익명 로그인 (기존 코드 그대로)
}
function createRoom(name){
  // 방 생성 (기존 코드 그대로)
}
function joinRoom(name){
  // 방 참여 (기존 코드 그대로)
}

/* ================= 싱글모드 시작 ================= */
function enterSoloGame(){
  document.getElementById('panel').style.display='flex';
  document.getElementById('turnLine').style.display='block';
  document.getElementById('scores').style.display='block';
  document.getElementById('bottomBar').style.display='flex';
  makeBoard();
  resizeBoard();
  local.state = initialState();
  renderFromState();
}

/* ================= commitState ================= */
async function commitState(){
  if(local.isSolo){
    renderFromState();
    const s = normalizeState(local.state);
    if (s && s.current===1 && (s.phase==='move' || s.phase==='wall' || s.phase==='place-extra')) {
      setTimeout(aiTurn, 500);
    }
    return;
  }
  // 온라인 모드 → Firebase set()
}

/* ================= AI 로직 ================= */
function aiTurn(){
  const s = normalizeState(local.state);
  if (!s || s.current !== 1) return;

  if (s.phase === 'place-extra') aiPlaceExtra(s);
  else if (s.phase === 'move') aiMove(s);
  else if (s.phase === 'wall') aiPlaceWall(s);

  renderFromState();
  if (s.phase !== 'ended') commitState();
}
function aiPlaceExtra(s){
  const points = allEmptyPoints(s);
  const pick = randomChoice(points);
  s.pieces['1'].push({r:pick.r,c:pick.c});
  s.extraIdx++;
  if(s.extraIdx >= s.extraOrder.length) s.phase='move';
  else s.current = s.extraOrder[s.extraIdx];
}
/* ===== 강화된 휴리스틱 헬퍼 ===== */

// (r,c)가 속한 구역에 존재하는 플레이어 집합
function playersInRegion(r, c){
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const q = [{ r, c }];
  visited[r][c] = true;
  const present = new Set();
  while(q.length){
    const cur = q.shift();
    const piece = grid[cur.r][cur.c].querySelector('.piece');
    if (piece) present.add(+piece.dataset.player);
    for (const { nr, nc } of neighborsByWall(cur.r, cur.c)){
      if (!visited[nr][nc]){ visited[nr][nc] = true; q.push({ r:nr, c:nc }); }
    }
  }
  return present; // 예: Set {0}, Set {1}, Set {0,1}
}

// 목적지 기준 이동 자유도(내가 그 칸에 있을 때 2스텝 이내 목적지 수)
function mobilityAt(r, c){
  // 현재 벽 상태를 그대로 쓰고, 말 점유만 체크
  let cnt = 0;
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r, c, d:0}]; v[r][c]=true;
  while(q.length){
    const cur=q.shift();
    if(cur.d>0 && cur.d<=2 && isPoint(cur.r,cur.c) && !grid[cur.r][cur.c].querySelector('.piece')) cnt++;
    if(cur.d===2) continue;
    for(const {nr,nc} of neighborsReachable(cur.r,cur.c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:cur.d+1}); }
    }
  }
  return cnt;
}

// 벽 좌표(wr,wc)가 가르는 두 점을 구함 (없으면 null)
function wallEndpoints(wr, wc){
  if (wr%2===1 && wc%2===0) return [{r:wr-1,c:wc},{r:wr+1,c:wc}]; // 가로벽: 위점-아래점
  if (wr%2===0 && wc%2===1) return [{r:wr,c:wc-1},{r:wr,c:wc+1}]; // 세로벽: 왼점-오른점
  return null;
}

// 후보 벽이 상대 기동력에 주는 차단 점수(근접 상대 말 수 + 인접 점 이동로 차단 수)
function blockScoreForWall(wr, wc, opponent=0){
  const ends = wallEndpoints(wr, wc);
  if (!ends) return 0;

  // 1) 벽 양끝 주변 2-맨해튼 안의 상대 말 수
  let nearOpp = 0;
  for (const pidEl of document.querySelectorAll('.piece')){
    const pid = +pidEl.dataset.player;
    if (pid!==opponent) continue;
    const cell = pidEl.parentElement;
    const rc = cellToRC(cell);
    if (!rc) continue;
    const d = Math.abs(rc.r-ends[0].r)+Math.abs(rc.c-ends[0].c);
    const e = Math.abs(rc.r-ends[1].r)+Math.abs(rc.c-ends[1].c);
    if (Math.min(d,e) <= 2) nearOpp++;
  }

  // 2) 현재 개방된 통로인지(=지금은 통과 가능, 벽을 두면 막힘) 가산
  let openPass = 0;
  const [A,B] = ends;
  // neighborsReachable은 점→이웃점이 "열려있고 도착점 비어야" true이므로,
  // 통로가 열려있고 도착이 빈 점이라면 실제로 이동 후보에 나타남
  const neighA = neighborsReachable(A.r, A.c).some(v => v.nr===B.r && v.nc===B.c);
  const neighB = neighborsReachable(B.r, B.c).some(v => v.nr===A.r && v.nc===A.c);
  if (neighA || neighB) openPass = 1;

  // 가중 합: 상대 근접도 *2 + 개방 통로 차단 *3
  return nearOpp*2 + openPass*3;
}

// DOM 셀 → 보드 좌표 (r,c)
function cellToRC(cell){
  if (!cell) return null;
  // grid[r][c]를 만들어둘 때 참조를 저장했으므로, 빠르게 역탐색:
  for (let r=0;r<GRID;r++){
    for (let c=0;c<GRID;c++){
      if (grid[r][c]===cell) return {r,c};
    }
  }
  return null;
}

/* ===================== [드롭인 AI 교체] 1-수 시뮬레이션 ===================== */

/* --- 가중치 (난이도에 따라 자동 스케일) --- */
const W_TERR_EZ   = 1.0, W_TRAP_EZ = 0.8, W_MOB_EZ = 0.6, W_CLASH_EZ = 0.6;
const W_TERR_MD   = 1.4, W_TRAP_MD = 1.2, W_MOB_MD = 0.9, W_CLASH_MD = 0.8;
const W_TERR_HARD = 1.8, W_TRAP_HARD = 1.8, W_MOB_HARD = 1.2, W_CLASH_HARD = 1.0;

function weightsByLevel(level){
  if(level==='hard')   return {WT:W_TERR_HARD, WP:W_TRAP_HARD, WM:W_MOB_HARD, WC:W_CLASH_HARD};
  if(level==='medium') return {WT:W_TERR_MD,   WP:W_TRAP_MD,   WM:W_MOB_MD,   WC:W_CLASH_MD};
  return {WT:W_TERR_EZ, WP:W_TRAP_EZ, WM:W_MOB_EZ, WC:W_CLASH_EZ};
}

/* --- 상태 전용 유틸 (DOM 의존 없음) --- */
function keyRC(r,c){ return `${r},${c}`; }
function wallKey(wr,wc){ return `w:${wr},${wc}`; }

function pointsNeighborsByWalls(wallsSet, r, c){
  const out=[];
  const dirs = [[-2,0],[2,0],[0,-2],[0,2]];
  for(const [dr,dc] of dirs){
    const nr=r+dr, nc=c+dc;
    if(nr<0||nr>=GRID||nc<0||nc>=GRID||nr%2||nc%2) continue;
    const wr=r+dr/2, wc=c+dc/2;
    if(wallsSet.has(wallKey(wr,wc))) continue; // 벽이면 막힘
    out.push([nr,nc]);
  }
  return out;
}

function listMovableState(wallsSet, occSet, sr, sc){
  const v = new Set([keyRC(sr,sc)]);
  const q = [{r:sr,c:sc,d:0}];
  const dest=[];
  while(q.length){
    const {r,c,d} = q.shift();
    if(d>0 && d<=2 && !occSet.has(keyRC(r,c))) dest.push({r,c});
    if(d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,r,c)){
      const k = keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}

function mobilityAtState(wallsSet, occSet, r, c){
  const v = new Set([keyRC(r,c)]);
  const q = [{r,c,d:0}];
  let cnt=0;
  while(q.length){
    const cur = q.shift();
    if(cur.d>0 && cur.d<=2 && !occSet.has(keyRC(cur.r,cur.c))) cnt++;
    if(cur.d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cur.r,cur.c)){
      const k=keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:cur.d+1}); }
    }
  }
  return cnt;
}

function regionsFromState(wallsSet, p0Set, p1Set){
  const visited = new Set();
  const regs=[];
  for(let r=0;r<GRID;r+=2){
    for(let c=0;c<GRID;c+=2){
      const start = keyRC(r,c);
      if(visited.has(start)) continue;
      const q=[[r,c]];
      visited.add(start);
      const points=[];
      let has0=false, has1=false;
      while(q.length){
        const [cr,cc]=q.shift();
        points.push([cr,cc]);
        const k=keyRC(cr,cc);
        if(p0Set.has(k)) has0=true;
        if(p1Set.has(k)) has1=true;
        for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cr,cc)){
          const nk=keyRC(nr,nc);
          if(!visited.has(nk)){ visited.add(nk); q.push([nr,nc]); }
        }
      }
      regs.push({points, has0, has1});
    }
  }
  return regs;
}

function territoryDiffAfter(wallsSet, p0Set, p1Set){
  const regs = regionsFromState(wallsSet,p0Set,p1Set);
  let me=0, opp=0;
  for(const reg of regs){
    if(reg.has0 && !reg.has1) opp+=reg.points.length;
    else if(reg.has1 && !reg.has0) me+=reg.points.length;
  }
  return me - opp; // 내 순영역
}

/* --- 1-수(이동+벽) 시뮬레이션 평가 --- */
function evaluateMovePlusBestWall(s, pieceFrom, moveTo, level){
  const {WT,WP,WM,WC} = weightsByLevel(level);

  // 세트 구성
  const wallsSet = new Set(s.walls.map(w=>wallKey(w.r,w.c)));
  const p0Set = new Set(s.pieces['0'].map(p=>keyRC(p.r,p.c)));
  const p1 = s.pieces['1'].map(p=>({r:p.r,c:p.c}));
  // 내 말 이동 가상 반영
  const idx = p1.findIndex(pp => pp.r===pieceFrom.r && pp.c===pieceFrom.c);
  p1[idx] = {r:moveTo.r, c:moveTo.c};
  const p1Set = new Set(p1.map(p=>keyRC(p.r,p.c)));

  // 기동력(이동 후 기준)
  const occForMob = new Set([...p0Set, ...p1Set]);
  const myMob = mobilityAtState(wallsSet, occForMob, moveTo.r, moveTo.c);

  // 상대 기동력 총합 (잡는/가두는 가치 반영)
  let oppMobBefore=0, oppMobAfter=0;
  for(const k of p0Set){
    const [r,c] = k.split(',').map(Number);
    oppMobBefore += mobilityAtState(wallsSet, occForMob, r, c);
  }

  // 벽 후보: 이동지 주변 우선, 없으면 전체 빈 벽
  let candWalls = [];
  for(const [wr,wc] of [[moveTo.r-1,moveTo.c],[moveTo.r+1,moveTo.c],[moveTo.r,moveTo.c-1],[moveTo.r,moveTo.c+1]]){
    const isWallPos = wr>=0&&wr<GRID&&wc>=0&&wc<GRID && ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
    if(isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr,c:wc});
  }
  if(candWalls.length===0){
    for(let wr=0;wr<GRID;wr++){
      for(let wc=0;wc<GRID;wc++){
        const isWallPos = ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
        if(isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr,c:wc});
      }
    }
  }

  // 각 벽을 가정해 최고 점수 선택
  let bestScore=-Infinity, bestWall=null;
  for(const w of candWalls){
    const ws = new Set(wallsSet); ws.add(wallKey(w.r,w.c));

    // 영역 차(내-상대)
    const terrDiff = territoryDiffAfter(ws, p0Set, p1Set);

    // 상대 기동력(벽 반영 후)
    oppMobAfter = 0;
    for(const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      oppMobAfter += mobilityAtState(ws, occForMob, r, c);
    }
    const trapGain = Math.max(0, oppMobBefore - oppMobAfter); // 줄었을수록 좋음

    // 충돌 위험(상대와 너무 붙어있으면 페널티)
    let minOpp=Infinity;
    for(const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      const d = Math.abs(r - moveTo.r) + Math.abs(c - moveTo.c);
      if(d<minOpp) minOpp=d;
    }
    const clashPenalty = Math.max(0, 3 - (isFinite(minOpp)?minOpp:99)); // 1~2칸이면 1~2 페널티

    const score = WT*terrDiff + WP*trapGain + WM*myMob - WC*clashPenalty;
    if(score>bestScore){ bestScore=score; bestWall=w; }
  }

  return {score: bestScore, bestWall};
}

/* --- AI 메인: 이동+벽 동시 결정 --- */
function aiMove(s){
  const myPieces = s.pieces['1'];
  let best=null, bestScore=-Infinity, bestWall=null;

  // 현재 점유 세트(시뮬 목적)
  for(const p of myPieces){
    const moves = listMovable(s, p.r, p.c); // ← DOM 기반이지만 "현재" 상태 조회는 OK
    for(const m of moves){
      const {score, bestWall:wallChoice} = evaluateMovePlusBestWall(s, p, m, local.aiLevel);
      if(score>bestScore){ bestScore=score; best={from:p, to:m}; bestWall=wallChoice; }
    }
  }

  if(best){
    // 실제 반영
    const arr = s.pieces['1'];
    const idx = arr.findIndex(pp=>pp.r===best.from.r && pp.c===best.from.c);
    arr[idx] = {r:best.to.r, c:best.to.c};
    s.phase = 'wall';
    s.lastMoved = {r:best.to.r, c:best.to.c};
     audioMal.play();

    // 다음 단계에서 벽을 바로 둘 수 있도록 저장
    s._aiPlannedWall = bestWall; // 임시 속성
  }
}

function aiPlaceWall(s){
  let pick = s._aiPlannedWall || null;
  if(!pick){
    // 혹시 이동 단계에서 못 정했으면(이동 불가 등) 기본 후보로 보정
    let candidates = [];
    if (s.lastMoved) candidates = adjacentEmptyWallsOfPoint(s, s.lastMoved.r, s.lastMoved.c);
    if (candidates.length === 0) candidates = listEmptyWallsFromState(s);
    pick = candidates && candidates.length ? candidates[0] : null;
  }
  if(pick) s.walls.push({ r:pick.r, c:pick.c, owner:1 });
  audioWall.play();

  delete s._aiPlannedWall;
  s.current = 0; s.phase = 'move'; s.lastMoved = null;
}

/* --- 더 이상 쓰지 않음: evalMoveScore (남겨두면 호출되지 않도록 주석처리) --- */
// function evalMoveScore(...) { ... }





function distToOpponent(pos) {
  const oppPieces = local.state.pieces['0']; // AI는 1번 플레이어로 가정
  let minDist = Infinity;
  for (const p of oppPieces) {
    const d = Math.abs(p.r - pos.r) + Math.abs(p.c - pos.c);
    if (d < minDist) minDist = d;
  }
  return minDist;
}

function distToCenter(pos) {
  const center = { r: Math.floor(GRID/2), c: Math.floor(GRID/2) };
  return Math.abs(center.r - pos.r) + Math.abs(center.c - pos.c);
}

function freedomScore(pos) {
  return neighborsReachable(pos.r, pos.c).length;
}
function makeBoard() {
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
  boardEl.style.gridTemplateRows = `repeat(${GRID}, auto)`;
  grid = Array.from({ length: GRID }, () => Array(GRID).fill(null));

  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');

      if (r % 2 === 0 && c % 2 === 0) {
        cell.classList.add('point');
        cell.addEventListener('click', () => onPointClick(r, c));
      } else if (r % 2 === 1 && c % 2 === 0) {
        cell.classList.add('h-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else if (r % 2 === 0 && c % 2 === 1) {
        cell.classList.add('v-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else {
        cell.classList.add('blank');
      }

      boardEl.appendChild(cell);
      grid[r][c] = cell;
    }
  }
  resizeBoard();
}
function renderFromState() {
  const s = normalizeState(local.state);
  if (!s) return;

  const phaseLabel = s.phase === 'place-extra' ? ' — 말 배치'
                    : s.phase === 'move' ? ' — 말 이동'
                    : s.phase === 'wall' ? ' — 벽 설치'
                    : s.phase === 'ended' ? ' — 종료' : '';
  turnEl.textContent = ((s.current === 0) ? 'P1(빨강)' : 'P2(파랑)') + ' 차례' + phaseLabel;
  turnEl.style.color = COLORS[s.current];

  skipWallBtn.disabled = !(s.phase === 'move' && s.current === local.role);

  document.querySelectorAll('.piece').forEach(el => el.remove());
  for (const pid of [0, 1]) {
    for (const p of s.pieces[String(pid)]) {
      const cell = grid[p.r]?.[p.c];
      if (!cell) continue;
      const dot = document.createElement('div');
      dot.classList.add('piece');
      dot.style.background = COLORS[pid];
      dot.dataset.player = String(pid);
      cell.appendChild(dot);
    }
  }

  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = grid[r][c];
      if (!cell) continue;
      if (cell.classList.contains('h-wall') || cell.classList.contains('v-wall')) {
        cell.classList.remove('placed');
        cell.style.background = '#fff';
      }
    }
  }
  for (const w of s.walls) {
    const cell = grid[w.r]?.[w.c];
    if (cell) {
      cell.classList.add('placed');
      cell.style.background = COLORS[w.owner];
    }
  }

  updateScoresLocal();
}
function onPointClick(r, c) {
  const s = normalizeState(local.state);
  if (!s) return;

  if (s.phase === 'place-extra') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    if (cell.querySelector('.piece')) return;
    s.pieces[String(s.current)].push({ r, c });
    audioMal.play();   // 🔊 말 놓기 소리
    s.extraIdx++;
    if (s.extraIdx >= s.extraOrder.length) {
      s.phase = 'move';
    } else {
      s.current = s.extraOrder[s.extraIdx];
    }
    commitState();
    return;
  }

  if (s.phase === 'move') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    const piece = cell.querySelector('.piece');

    if (local.selected && local.selected.r === r && local.selected.c === c) {
      local.selected = null;
      clearMovable();
      return;
    }

    if (!local.selected && piece && +piece.dataset.player === local.role) {
      local.selected = { r, c };
      const cnt = showMovableFrom(r, c);
      if (cnt === 0) {
        local.selected = null;
        clearMovable();
      }
      return;
    }

    if (local.selected && cell.classList.contains('movable')) {
      const arr = s.pieces[String(local.role)];
      const idx = arr.findIndex(p => p.r === local.selected.r && p.c === local.selected.c);
      if (idx >= 0) {
        arr[idx] = { r, c };
        audioMal.play();   // 🔊 말 이동 소리
        s.phase = 'wall';
        s.lastMoved = { r, c };
        clearMovable();
        local.selected = null;
        commitState();
      }
    }
  }
}

function onWallClick(r, c) {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'wall' || s.current !== local.role) return;
  const cell = grid[r][c];
  const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
  if (!isWall || cell.classList.contains('placed')) return;

  s.walls.push({ r, c, owner: local.role });
  audioWall.play();  // 🔊 벽 설치 소리
  s.current = 1 - s.current;
  s.phase = 'move';
  s.lastMoved = null;
  clearMovable();
  commitState();
}

skipWallBtn.addEventListener('click', () => {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'move' || s.current !== local.role) return;
  clearMovable();
  local.selected = null;
  s.phase = 'wall';
  s.lastMoved = null;
  commitState();
});
function computeRegionsLocal() {
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const regions = [];
  let hasMixed = false;

  for (let r = 0; r < GRID; r += 2) {
    for (let c = 0; c < GRID; c += 2) {
      if (visited[r][c]) continue;
      const q = [{ r, c }];
      visited[r][c] = true;
      const pts = [];
      const present = new Set();
      while (q.length) {
        const cur = q.shift();
        pts.push(cur);
        const piece = grid[cur.r][cur.c].querySelector('.piece');
        if (piece) present.add(+piece.dataset.player);
        for (const { nr, nc } of neighborsByWall(cur.r, cur.c)) {
          if (!visited[nr][nc]) {
            visited[nr][nc] = true;
            q.push({ r: nr, c: nc });
          }
        }
      }
      if (present.size >= 2) hasMixed = true;
      regions.push({ points: pts, players: present });
    }
  }
  return { regions, hasMixed };
}

function updateScoresLocal(){
  const ended = checkGameEndAndScoreLocal();
  if (ended && local.state?.phase !== 'ended'){
    local.state.phase = 'ended';
    showWinnerWithPaintLocal();
  }
}

function showWinnerWithPaintLocal(){
  audioWin.play(); // 🔊 경기 종료 소리
  fillFinalRegionsLocal(); // 최종 영역 칠하기
  const p1 = +s1El.textContent, p2 = +s2El.textContent;
  alert(
    `게임 종료!\nP1(빨강): ${p1} / P2(파랑): ${p2}\n` +
    (p1>p2 ? '승자: P1(빨강)' : p2>p1 ? '승자: P2(파랑)' : '무승부')
  );
}

/* 보드 연결을 기준으로 영역을 계산해 점수를 산출하고,
   두 플레이어 말이 함께 있는 영역이 하나도 없으면 즉시 종료 */
function checkGameEndAndScoreLocal(){
  const { regions, hasMixed } = computeRegionsLocal();
  const sc = [0, 0];

  for (const reg of regions){
    if (reg.players.size === 1){
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;     // 해당 영역의 모든 점을 소유자 점수로
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];

  // 혼합 영역이 없으면 모든 영역의 소유자가 결정된 상태 → 종료
  return !hasMixed;
}

/* 최종 영역에 색을 칠해 가시화 */
function fillFinalRegionsLocal(){
  const { regions } = computeRegionsLocal();
  for (const reg of regions){
    if (reg.players.size !== 1) continue;
    const owner = [...reg.players][0];
    for (const { r, c } of reg.points){
      grid[r][c].classList.remove('movable');
      if (owner === 0) grid[r][c].classList.add('final-p1-region');
      else grid[r][c].classList.add('final-p2-region');
    }
  }
}




/* ===== 도움말 오버레이 핸들러 ===== */
function openHelp(){ 
  const ov = document.getElementById('helpOverlay');
  if (ov) ov.style.display = 'flex';
}
function closeHelp(){ 
  const ov = document.getElementById('helpOverlay');
  if (ov) ov.style.display = 'none';
}
/* 전역에서 호출될 수 있게 노출 */
window.openHelp = openHelp;
window.closeHelp = closeHelp;

/* 닫기 버튼/오버레이 클릭으로 닫기 */
const helpCloseBtn = document.getElementById('helpCloseBtn');
if (helpCloseBtn) helpCloseBtn.addEventListener('click', closeHelp);
const helpOverlay = document.getElementById('helpOverlay');
if (helpOverlay) {
  helpOverlay.addEventListener('click', (e)=>{
    if (e.target === helpOverlay) closeHelp();
  });
}




/* ======== 나머지 함수들 ======== 
- distToOpponent, distToCenter, freedomScore
- makeBoard, resizeBoard, renderFromState
- onPointClick, onWallClick, skipWallBtn 이벤트
- 점수 계산, 승리 판정
모두 기존 index.html 코드에서 그대로 붙여주세요
*/
</script>
</body>
</html>
