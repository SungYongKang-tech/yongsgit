<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Wall-baduk (ì˜¨ë¼ì¸ 2ì¸ Â· 7x7)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root { --bar-h: 60px; }
    body {
      font-family: sans-serif; background:#f5f5f5; text-align:center; margin:0; min-height:100vh;
      display:grid; grid-template-rows:auto auto auto auto auto;
    }
    h1 { margin: 8px 0 4px; }

    /* ë¡œë¹„ */
    #setup { margin:10px 0 4px; }
    #setup .row { display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; }
    #roomInput { width:min(260px, 70vw); padding:10px 12px; border:1px solid #bbb; border-radius:8px; font-size:16px; }
    #setup button { padding:12px 14px; border-radius:10px; border:1px solid #999; background:#fff; cursor:pointer; }
    #roomLine { font-size:13px; color:#555; margin:6px 0 6px; }

    /* ìƒë‹¨ íŒ¨ë„ */
    #panel { margin:4px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    #panel button { padding:10px 14px; border:1px solid #999; border-radius:10px; background:#fff; cursor:pointer; }

    #turnLine { margin:2px 0; font-size:16px; display:flex; gap:8px; justify-content:center; align-items:center; }
    #turnColor { font-weight:700; }
    #timer {
      font-variant-numeric: tabular-nums; padding:2px 6px; border:1px solid #ddd; border-radius:8px; background:#fff;
      min-width: 54px; display:inline-block;
    }
    #scores   { margin:0 0 4px; font-size:14px; }

    /* ì˜¤ë””ì˜¤ ì»¨íŠ¸ë¡¤ */
    .audio-wrap {
      display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #ddd; border-radius:10px; background:#fff;
    }
    #volSlider { width: 160px; }
    #volVal { min-width:36px; display:inline-block; text-align:right; }

    /* ë³´ë“œ */
    #wrap { display:flex; justify-content:center; align-items:flex-start; padding:0 10px 6px; overflow:auto; }
    #board { display:grid; background:#fff; border:2px solid #333; user-select:none; touch-action:manipulation; }
    .cell { box-sizing:border-box; border:1px solid #000; display:flex; align-items:center; justify-content:center; }
    .point { width:42px; height:42px; background:#fff; position:relative; cursor:pointer; transition:background .1s; }
    .piece { width:80%; height:80%; border-radius:50%; pointer-events:none; }
    .h-wall { width:42px; height:15px; background:#fff; cursor:pointer; }
    .v-wall { width:15px; height:42px; background:#fff; cursor:pointer; }
    .blank  { width:15px; height:15px; background:#15326b; }

    .movable { background:#d0d0d0 !important; } /* ì´ë™ ê°€ëŠ¥ ì  í‘œì‹œ */
    .final-p1-region { background:#ffd6e7 !important; }
    .final-p2-region { background:#d6ecff !important; }

    /* í•˜ë‹¨ ë°” */
    #bottomBar {
      position:sticky; bottom:0; left:0; right:0; background:#ffffffcc; backdrop-filter:blur(6px);
      border-top:1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center; padding:6px 12px;
    }
    #skipWallBtn { width:min(340px,92vw); height:40px; border-radius:12px; font-weight:700; background:#ffd6e7; border:1px solid #e7a3bd; }
    button:disabled { opacity:.5; cursor:not-allowed; }

    /* ë„ì›€ë§ ëª¨ë‹¬ */
    #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:10000; padding:16px; }
    #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
    #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
    #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
    #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
    #helpBody ul ul { margin-left:6px; padding-left:10px; }
    #helpBody li { margin:4px 0; }
    #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
    .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }

    @media (max-width:420px){
      .point { width:36px; height:36px; }
      .h-wall { width:36px; height:14px; }
      .v-wall { width:14px; height:36px; }
      #volSlider { width:120px; }
    }
  </style>
</head>
<body>
  <h1>Wall-baduk (ë²½ë°”ë‘‘)</h1>

  <!-- ë°© ìƒì„±/ì°¸ì—¬ -->
  <div id="setup">
    <div class="row">
      <input id="roomInput" type="text" placeholder="ë°© ì´ë¦„ì„ ì ì–´ì£¼ì„¸ìš” (ì˜ˆ: ë¶€ì—‰ì´1929)" />
      <button id="btnCreate">ë°© ìƒì„±í•˜ê¸°</button>
      <button id="btnJoin">ë°© ì°¸ì—¬í•˜ê¸°</button>
    </div>
    <div id="roomLine">ëŒ€ê¸° ì¤‘â€¦</div>
  </div>

  <!-- ê²Œì„ íŒ¨ë„ -->
  <div id="panel" style="display:none">
    <button id="resetBtn">ìƒˆë¡œ ì‹œì‘</button>
    <button id="helpBtn" onclick="openHelp()">ë„ì›€ë§</button>
    <button id="endBtn">ê²Œì„ ì¢…ë£Œ</button>

    <div class="audio-wrap" title="íš¨ê³¼ìŒ ë³¼ë¥¨">
      <button id="muteBtn" aria-pressed="false">ğŸ”Š</button>
      <input id="volSlider" type="range" min="0" max="1" step="0.05" />
      <span id="volVal">100%</span>
    </div>
  </div>

  <div id="turnLine" style="display:none">í˜„ì¬ í„´: <span id="turnColor"></span> <span id="timer"></span></div>
  <div id="scores"   style="display:none">P1(ë¹¨ê°•): <span id="s1">0</span> / P2(íŒŒë‘): <span id="s2">0</span></div>

  <div id="wrap"><div id="board"></div></div>

  <div id="bottomBar" style="display:none">
    <button id="skipWallBtn" disabled>ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜</button>
  </div>

 <!-- ì„¤ëª… íŒì—… -->
<div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div id="helpCard">
    <div id="helpHeader"><span id="helpTitle">ê²Œì„ ì„¤ëª…</span></div>
    <div id="helpBody">
      <ul>
        <li><strong>ëª©í‘œ</strong>: ë²½ìœ¼ë¡œ ë³´ë“œë¥¼ ë‚˜ëˆ  <strong>ë‚´ ë§ë§Œ í¬í•¨ëœ êµ¬ì—­</strong>ì„ ë§ì´ ë§Œë“¤ê¸°</li>

        <li><strong>í„´ ì§„í–‰</strong>:
          <ul>
            <li>ë‚´ ë§ í•˜ë‚˜ ì„ íƒ â†’ <strong>ì´ë™</strong>(ë˜ëŠ” ìƒëµ) â†’ <strong>ë²½ 1ê°œ ì„¤ì¹˜</strong> â†’ ìƒëŒ€ í„´</li>
          </ul>
        </li>
        <li><strong>ì´ë™ ê·œì¹™</strong>:
          <ul>
            <li>ìƒ/í•˜/ì¢Œ/ìš° ë°©í–¥ìœ¼ë¡œ <strong>ìµœëŒ€ 2ì¹¸</strong> ì´ë™(ì§ê°ìœ¼ë¡œ 1+1ì¹¸ ê°€ëŠ¥)</li>
            <li>ë²½ì€ í†µê³¼ ë¶ˆê°€, ë„ì°© ì¹¸ì— ë§ì´ ìˆìœ¼ë©´ ì´ë™ ë¶ˆê°€</li>
            <li><strong>ì´ë™ ì‹œê°„(60ì´ˆ) ì´ˆê³¼</strong> ì‹œ â†’ ì´ë™ ì—†ì´ <strong>ë²½ ì„¤ì¹˜ ë‹¨ê³„</strong>ë¡œ ë°”ë¡œ ì „í™˜</li>
          </ul>
        </li>

        <li><strong>ë²½ ì„¤ì¹˜ ê·œì¹™</strong>:
          <ul>
            <li>ë¹ˆ ê°€ë¡œ/ì„¸ë¡œ ë²½ ì¹¸ì— <strong>1ê°œ</strong> ì„¤ì¹˜(ì„¤ì¹˜ í›„ ì œê±° ë¶ˆê°€)</li>
            <li><strong>ë²½ ì„¤ì¹˜ ì‹œê°„(10ì´ˆ) ì´ˆê³¼</strong> ì‹œ â†’ <strong>ëœë¤ ë²½ ì„¤ì¹˜</strong>:
            </li>
          </ul>
        </li>

        <li><strong>ì˜ì—­ & ìŠ¹ë¦¬</strong>:
          <ul>
            <li><strong>í•œìª½ í”Œë ˆì´ì–´ì˜ ë§ë§Œ</strong> ìˆëŠ” êµ¬ì—­ë§Œ ê·¸ í”Œë ˆì´ì–´ ì†Œìœ </li>
            <li>ë‘ í”Œë ˆì´ì–´ ë§ì´ í•¨ê»˜ ìˆìœ¼ë©´ <strong>ì£¼ì¸ì—†ëŠ” êµ¬ì—­</strong></li>
            <li>ëª¨ë“  êµ¬ì—­ ì†Œìœ ìê°€ ìƒê¸°ëŠ”ìˆœê°„ ì¦‰ì‹œ ì¢…ë£Œ â†’ ê°ì <strong>ìì‹ ì˜ êµ¬ì—­ ì  ê°œìˆ˜ í•©</strong>ì´ ë” í° ì‚¬ëŒì´ ìŠ¹ë¦¬</li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="helpFooter">
      <button class="helpBtn" id="helpCloseBtn">ì‹œì‘í•˜ê¸°</button>
    </div>
  </div>
</div>


  <!-- ì•± ìŠ¤í¬ë¦½íŠ¸ -->
  <script type="module">
    /* ================= Firebase ================= */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getDatabase, ref, get, set, onValue, runTransaction, onDisconnect, remove, update } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.appspot.com",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:8cc90ab5a17c364b91a561"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    /* ================= ê³µí†µ ìœ í‹¸/ìƒìˆ˜ ================= */
    const uid = (() => {
      const key='wb_uid_tab';
      let v = sessionStorage.getItem(key);
      if (!v) { v = (crypto.randomUUID?.() || ('u_'+Math.random().toString(36).slice(2))); sessionStorage.setItem(key, v); }
      return v;
    })();

    function sanitizeRoomName(raw){ return raw.trim().replace(/[.#$/\[\]\/]/g,'-').slice(0,32); }
    function requireRoomName(){
      const raw = document.getElementById('roomInput').value;
      const id = sanitizeRoomName(raw||'');
      if (!id) { alert('ë°© ì´ë¦„ì„ ì ì–´ì£¼ì„¸ìš”. (ì˜ˆ: ë¶€ì—‰ì´1929)'); return null; }
      return id;
    }

    const MAX_ROOMS=10;
    const BOARD_POINTS=7, GRID=BOARD_POINTS*2-1;
    const COLORS=['#e74c3c','#3498db'];

    const MOVE_SECONDS=60;
    const WALL_SECONDS=10;

    const boardEl=document.getElementById('board');
    const roomLine=document.getElementById('roomLine');
    const resetBtn=document.getElementById('resetBtn');
    const helpOverlay=document.getElementById('helpOverlay');
    const helpCloseBtn=document.getElementById('helpCloseBtn');
    const endBtn=document.getElementById('endBtn');
    const skipWallBtn=document.getElementById('skipWallBtn');
    const turnEl=document.getElementById('turnColor');
    const timerEl=document.getElementById('timer');
    const s1El=document.getElementById('s1');
    const s2El=document.getElementById('s2');

    // ì˜¤ë””ì˜¤ UI
    const volSlider=document.getElementById('volSlider');
    const volVal=document.getElementById('volVal');
    const muteBtn=document.getElementById('muteBtn');

    // íš¨ê³¼ìŒ
    const sndMove = new Audio('mal.mp3');
    const sndWall = new Audio('wall.mp3');
    const sndWin  = new Audio('win.mp3');
    const allSounds=[sndMove, sndWall, sndWin];
    function playSafe(a){ try{ a.currentTime=0; a.play().catch(()=>{}); }catch(e){} }

    // ë¡œì»¬ ìƒíƒœ
    let grid=[], unsubRoom=null, unsubPlayers=null, cleanupScheduled=false;
    let local = { roomId:null, role:0, state:null, selected:null, prevWallCount:null };

    // íƒ€ì´ë¨¸
    let turnTimerId=null, turnDeadline=0;
    function clearTurnTimer(){ if(turnTimerId){ clearInterval(turnTimerId); turnTimerId=null; } timerEl.textContent=''; }
    function startTurnTimer(seconds){
      clearTurnTimer();
      turnDeadline = Date.now() + seconds*1000;
      tickTimer();
      turnTimerId = setInterval(tickTimer, 200);
    }
    function tickTimer(){
      const remain=Math.max(0, turnDeadline - Date.now());
      const sec=Math.ceil(remain/1000), mm=String(Math.floor(sec/60)).padStart(2,'0'), ss=String(sec%60).padStart(2,'0');
      timerEl.textContent=`${mm}:${ss}`;
      if(remain<=0){ clearTurnTimer(); handleTurnTimeout(); }
    }

    function isMyTurn(){
      const s = normalizeState(local.state);
      return !!s && s.current === local.role && (s.phase==='move' || s.phase==='wall');
    }

    /* ================= ì´ˆê¸° ìƒíƒœ/ë³´ë“œ ================= */
    function pt(p){ return (p-1)*2; }
    function initialState(){
      return {
        phase:'place-extra',
        current:0,
        extraOrder:[0,1,1,0],
        extraIdx:0,
        pieces:{ '0':[ {r:pt(2),c:pt(2)}, {r:pt(6),c:pt(6)} ],
                 '1':[ {r:pt(6),c:pt(2)}, {r:pt(2),c:pt(6)} ] },
        walls:[],
        lastMoved: null   // ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™ ì™„ë£Œëœ ë§ ì¢Œí‘œ(ë²½ íƒ€ì„ì•„ì›ƒ í›„ë³´ìš©)
      };
    }
    const asArray = x => Array.isArray(x) ? x : (x && typeof x==='object') ? Object.values(x) : [];
    function normalizeState(s){
      if(!s) return s;
      s.walls = asArray(s.walls);
      if(!s.pieces) s.pieces={'0':[],'1':[]};
      s.pieces['0']=asArray(s.pieces['0']);
      s.pieces['1']=asArray(s.pieces['1']);
      s.extraOrder=asArray(s.extraOrder||[0,1,1,0]);
      if (s.lastMoved && (typeof s.lastMoved.r!=='number' || typeof s.lastMoved.c!=='number')) s.lastMoved=null;
      return s;
    }

    function makeBoard(){
      boardEl.innerHTML='';
      boardEl.style.gridTemplateColumns=`repeat(${GRID}, auto)`;
      boardEl.style.gridTemplateRows=`repeat(${GRID}, auto)`;
      grid = Array.from({length:GRID},()=>Array(GRID).fill(null));
      for(let r=0;r<GRID;r++){
        for(let c=0;c<GRID;c++){
          const cell=document.createElement('div'); cell.classList.add('cell');
          if(r%2===0 && c%2===0){ cell.classList.add('point'); cell.addEventListener('click',()=>onPointClick(r,c)); }
          else if(r%2===1 && c%2===0){ cell.classList.add('h-wall'); cell.addEventListener('click',()=>onWallClick(r,c)); }
          else if(r%2===0 && c%2===1){ cell.classList.add('v-wall'); cell.addEventListener('click',()=>onWallClick(r,c)); }
          else { cell.classList.add('blank'); }
          boardEl.appendChild(cell); grid[r][c]=cell;
        }
      }
    }
    function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }
    function inBounds(r,c){ return r>=0&&r<GRID&&c>=0&&c<GRID; }
    function isPoint(r,c){ return (r%2===0)&&(c%2===0); }

    /* ================= ë Œë”/ì ìˆ˜ ================= */
    function renderFromState(){
      const s=normalizeState(local.state);
      if(!s) return;

      // í„´ í‘œì‹œ
      const phaseLabel = s.phase==='place-extra' ? ' â€” ë§ ë°°ì¹˜'
                        : s.phase==='move' ? ' â€” ë§ ì´ë™'
                        : s.phase==='wall' ? ' â€” ë²½ ì„¤ì¹˜'
                        : s.phase==='ended' ? ' â€” ì¢…ë£Œ' : '';
      turnEl.textContent = ((s.current===0)?'P1(ë¹¨ê°•)':'P2(íŒŒë‘)') + ' ì°¨ë¡€' + phaseLabel;
      turnEl.style.color = COLORS[s.current];

      // ë²„íŠ¼
      skipWallBtn.disabled = !(s.phase==='move' && s.current===local.role);

      // ë§ ë Œë”
      document.querySelectorAll('.piece').forEach(el=>el.remove());
      for(const pid of [0,1]){
        for(const p of asArray(s.pieces[String(pid)])){
          const cell=grid[p.r]?.[p.c]; if(!cell) continue;
          const dot=document.createElement('div'); dot.classList.add('piece'); dot.style.background=COLORS[pid]; dot.dataset.player=String(pid);
          cell.appendChild(dot);
        }
      }
      // ë²½ ë Œë”
      for(let r=0;r<GRID;r++){ for(let c=0;c<GRID;c++){
        const cell=grid[r][c]; if(!cell) continue;
        if(cell.classList.contains('h-wall')||cell.classList.contains('v-wall')){ cell.classList.remove('placed'); cell.style.background='#fff'; }
      }}      
      for(const w of asArray(s.walls)){
        const cell=grid[w.r]?.[w.c]; if(cell){ cell.classList.add('placed'); cell.style.background=COLORS[w.owner]; }
      }

      // ìë™/ìˆ˜ë™ ë²½ ì„¤ì¹˜ ì‚¬ìš´ë“œ: walls ê¸¸ì´ ì¦ê°€ ê°ì§€
      if (local.prevWallCount == null) {
        local.prevWallCount = s.walls.length;
      } else if (s.walls.length > local.prevWallCount) {
        playSafe(sndWall);
        local.prevWallCount = s.walls.length;
      } else {
        local.prevWallCount = s.walls.length;
      }

      // íƒ€ì´ë¨¸: ë‚´ í„´ì´ë©´ ì‹œì‘, ì•„ë‹ˆë©´ ì •ì§€
      if (isMyTurn()) {
        startTurnTimer(s.phase==='move' ? MOVE_SECONDS : WALL_SECONDS);
      } else {
        clearTurnTimer();
      }

      updateScoresLocal();
    }

    function neighborsReachable(r,c){
      const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
      for(const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
        const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
        if(!isWallPos) continue; if(wall.classList.contains('placed')) continue;
        if(grid[nr][nc].querySelector('.piece')) continue; out.push({nr,nc});
      }
      return out;
    }
    function markMovable(sr,sc,mark=true){
      const v=Array.from({length:GRID},()=>Array(GRID).fill(false)); const q=[]; v[sr][sc]=true; q.push({r:sr,c:sc,d:0}); let cnt=0;
      while(q.length){
        const {r,c,d}=q.shift();
        if(d>0&&d<=2&&isPoint(r,c)&&!grid[r][c].querySelector('.piece')){ if(mark) grid[r][c].classList.add('movable'); cnt++; }
        if(d===2) continue;
        for(const {nr,nc} of neighborsReachable(r,c)){ if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); } }
      }
      return cnt;
    }
    function showMovableFrom(sr,sc){ clearMovable(); return markMovable(sr,sc,true); }

    function neighborsByWall(r,c){
      const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
      for(const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
        const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
        if(!isWallPos) continue; if(wall.classList.contains('placed')) continue; out.push({nr,nc});
      }
      return out;
    }
    function computeRegionsLocal(){
      const visited=Array.from({length:GRID},()=>Array(GRID).fill(false)); const regions=[]; let hasMixed=false;
      for(let r=0;r<GRID;r+=2){ for(let c=0;c<GRID;c+=2){
        if(visited[r][c]) continue; const q=[{r,c}]; visited[r][c]=true; const pts=[]; const present=new Set();
        while(q.length){
          const cur=q.shift(); pts.push(cur);
          const piece=grid[cur.r][cur.c].querySelector('.piece'); if(piece) present.add(+piece.dataset.player);
          for(const {nr,nc} of neighborsByWall(cur.r,cur.c)){ if(!visited[nr][nc]){ visited[nr][nc]=true; q.push({r:nr,c:nc}); } }
        }
        if(present.size>=2) hasMixed=true; regions.push({points:pts, players:present});
      }}
      return {regions, hasMixed};
    }
    function checkGameEndAndScoreLocal(){
      const {regions,hasMixed}=computeRegionsLocal(); const sc=[0,0];
      for(const reg of regions){ if(reg.players.size===1){ const owner=[...reg.players][0]; sc[owner]+=reg.points.length; } }
      s1El.textContent=sc[0]; s2El.textContent=sc[1]; return !hasMixed;
    }
    function updateScoresLocal(){
      const end=checkGameEndAndScoreLocal();
      if(end && local.state?.phase!=='ended'){ showWinnerWithPaintLocal(); }
    }
    function fillFinalRegionsLocal(){
      const {regions}=computeRegionsLocal();
      for(const reg of regions){
        if(reg.players.size!==1) continue; const owner=[...reg.players][0];
        for(const {r,c} of reg.points){
          grid[r][c].classList.remove('movable');
          (owner===0?grid[r][c].classList.add('final-p1-region'):grid[r][c].classList.add('final-p2-region'));
        }
      }
    }
    function showWinnerWithPaintLocal(){
      fillFinalRegionsLocal();
      const p1=+s1El.textContent, p2=+s2El.textContent;
      playSafe(sndWin);
      alert(`ê²Œì„ ì¢…ë£Œ!\nP1(ë¹¨ê°•): ${p1} / P2(íŒŒë‘): ${p2}\n`+(p1>p2?'ìŠ¹ì: P1(ë¹¨ê°•)':p2>p1?'ìŠ¹ì: P2(íŒŒë‘)':'ë¬´ìŠ¹ë¶€'));
      if(local.state){
        local.state.phase='ended'; commitState(); cleanupRoomAfterEnd(local.roomId, 2500);
      }
    }

    /* ================= ì…ë ¥/ì•¡ì…˜ ================= */
    function onPointClick(r,c){
      local.state = normalizeState(local.state);
      const s=local.state; if(!s) return;

      if(s.phase==='place-extra'){
        if(s.current!==local.role) return;
        const cell=grid[r][c]; if(cell.querySelector('.piece')) return;
        s.pieces[String(s.current)].push({r,c});
        s.extraIdx++;
        if(s.extraIdx>=s.extraOrder.length){ s.phase='move'; }
        else { s.current=s.extraOrder[s.extraIdx]; }
        s.lastMoved = null;
        commitState();
        return;
      }

      if(s.phase==='move'){
        if(s.current!==local.role) return;
        const cell=grid[r][c]; const piece=cell.querySelector('.piece');

        if(local.selected && local.selected.r===r && local.selected.c===c){
          local.selected=null; clearMovable(); return;
        }

        if(!local.selected && piece && +piece.dataset.player===local.role){
          local.selected={r,c};
          const cnt=showMovableFrom(r,c);
          if(cnt===0){ local.selected=null; clearMovable(); }
          return;
        }

        if(local.selected && cell.classList.contains('movable')){
          const arr=s.pieces[String(local.role)];
          const idx=arr.findIndex(p=>p.r===local.selected.r&&p.c===local.selected.c);
          if(idx>=0){
            arr[idx]={r,c};
            playSafe(sndMove);
            s.phase='wall';
            s.lastMoved = { r, c };   // ë§ˆì§€ë§‰ ì´ë™ ë§ ê¸°ë¡
            clearMovable(); local.selected=null;
            commitState();
          }
        }
      }
    }

    function onWallClick(r,c){
      local.state = normalizeState(local.state);
      const s=local.state; if(!s||s.phase!=='wall'||s.current!==local.role) return;
      const cell=grid[r][c];
      const isWall=cell.classList.contains('h-wall')||cell.classList.contains('v-wall');
      if(!isWall||cell.classList.contains('placed')) return;

      s.walls.push({r,c,owner:local.role});
      // ì‚¬ìš´ë“œëŠ” ë Œë”ì—ì„œ ì¦ê°€ ê°ì§€ë¡œ ì¬ìƒ
      s.current=1-s.current; s.phase='move'; s.lastMoved = null;
      clearMovable();
      commitState();
    }

    // ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜
    skipWallBtn.addEventListener('click',()=>{
      local.state = normalizeState(local.state);
      const s=local.state; if(!s||s.phase!=='move'||s.current!==local.role) return;
      clearMovable(); local.selected=null; s.phase='wall'; s.lastMoved = null;
      commitState();
    });

    /* ================= íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ ================= */
    function listEmptyWallsFromState(s){
      const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
      const out=[];
      for(let r=0;r<GRID;r++){
        for(let c=0;c<GRID;c++){
          const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
          if(!isWallPos) continue;
          const key=`${r},${c}`;
          if(!occupied.has(key)) out.push({r,c});
        }
      }
      return out;
    }
    // íŠ¹ì • ì (ë§) ì£¼ë³€ì˜ ë¹ˆ ë²½ í›„ë³´(ìƒ/í•˜/ì¢Œ/ìš°)
    function adjacentEmptyWallsOfPoint(s, pr, pc){
      const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
      const cand = [{r:pr-1,c:pc},{r:pr+1,c:pc},{r:pr,c:pc-1},{r:pr,c:pc+1}];
      return cand.filter(({r,c})=>{
        const inBoard = r>=0 && r<GRID && c>=0 && c<GRID;
        const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
        const free = !occupied.has(`${r},${c}`);
        return inBoard && isWallPos && free;
      });
    }

    async function handleTurnTimeout(){
      if(!local.roomId) return;
      const stateRef = ref(db, `wbaduk/rooms/${local.roomId}/state`);

      await runTransaction(stateRef, (raw)=>{
        const s = normalizeState(raw);
        if(!s) return raw;

        // ì—¬ì „íˆ ë‚´ í„´ì¸ì§€ ê²€ì¦
        if(!(s.current===local.role && (s.phase==='move' || s.phase==='wall'))) return raw;

        // 1) ì´ë™ ë‹¨ê³„ ì´ˆê³¼ â†’ ë²½ ë‹¨ê³„ë¡œë§Œ ì „í™˜
        if (s.phase === 'move') {
          s.phase = 'wall';
          s.lastMoved = null;   // ì´ë™ ì•ˆ í–ˆìœ¼ë¯€ë¡œ ê¸°ì¤€ ì—†ìŒ
          return s;
        }

        // 2) ë²½ ë‹¨ê³„ ì´ˆê³¼ â†’ ìë™ ë²½ ì„¤ì¹˜
        let candidates = [];

        // (a) ì´ë²ˆ í„´ ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™í•œ ë§ ì£¼ë³€
        if (s.lastMoved) {
          candidates = adjacentEmptyWallsOfPoint(s, s.lastMoved.r, s.lastMoved.c);
        }

        // (b) ì´ë™ ì•ˆ í–ˆê±°ë‚˜ ì£¼ë³€ì´ ë§‰íŒ ê²½ìš° â†’ í˜„ì¬ í”Œë ˆì´ì–´ ëª¨ë“  ë§ ì£¼ë³€ í•©ì¹˜ê¸°
        if (candidates.length === 0) {
          const myPieces = asArray(s.pieces[String(s.current)]);
          for (const p of myPieces) {
            const adj = adjacentEmptyWallsOfPoint(s, p.r, p.c);
            if (adj.length) candidates.push(...adj);
          }
        }

        // (c) ê·¸ë˜ë„ ì—†ìœ¼ë©´ â†’ ì „ì²´ ë¹ˆ ë²½
        if (candidates.length === 0) {
          candidates = listEmptyWallsFromState(s);
        }

        if (candidates.length > 0) {
          const pick = candidates[Math.floor(Math.random()*candidates.length)];
          s.walls.push({ r: pick.r, c: pick.c, owner: s.current });
        }

        // í„´ êµëŒ€
        s.current = 1 - s.current;
        s.phase   = 'move';
        s.lastMoved = null;
        return s;
      });
      // ì»¤ë°‹ í›„ ë‹¤ìŒ ì°¨ë¡€ ìª½ì—ì„œ íƒ€ì´ë¨¸ ìë™ ì‹œì‘
    }

    /* ================= DB ë™ê¸°í™” ================= */
    async function commitState(){
      if(!local.roomId||!local.state) return;
      await set(ref(db, `wbaduk/rooms/${local.roomId}/state`), local.state);
    }
    function applyRemote(state){
      local.state = normalizeState(state);
      renderFromState();
    }

    /* ================= ë°© ìƒì„±/ì°¸ì—¬ ================= */
    async function pruneRoomsToMax(max=MAX_ROOMS){
      const roomsRef=ref(db,'wbaduk/rooms'); const snap=await get(roomsRef); if(!snap.exists()) return;
      let rooms=Object.entries(snap.val()||{}).map(([id,r])=>({id,createdAt:r?.createdAt||0}));
      if(rooms.length<=max) return;
      rooms.sort((a,b)=>a.createdAt-b.createdAt);
      while(rooms.length>max){ const victim=rooms.shift(); await remove(ref(db,`wbaduk/rooms/${victim.id}`)); }
    }

    const btnCreate=document.getElementById('btnCreate');
    const btnJoin  =document.getElementById('btnJoin');

    btnCreate.onclick = async ()=>{
      const roomId=requireRoomName(); if(!roomId) return;
      await pruneRoomsToMax(10);
      const roomRef=ref(db,`wbaduk/rooms/${roomId}`);
      const exist=await get(roomRef);
      if(exist.exists()){ alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°© ì´ë¦„ì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì´ë¦„ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”.'); return; }

      const now=Date.now();
      await set(roomRef,{
        name:roomId, status:'waiting', createdAt:now, playerCount:1,
        players:{ [uid]:{ role:0, joinedAt:now } },
        state: initialState()
      });
      await pruneRoomsToMax(10);
      onDisconnect(ref(db, `wbaduk/rooms/${roomId}/players/${uid}`)).remove();
      enterRoom(roomId, 0);
    };

    btnJoin.onclick = async ()=>{
      const roomId=requireRoomName(); if(!roomId) return;
      const roomRef=ref(db,`wbaduk/rooms/${roomId}`);
      const playersRef=ref(db,`wbaduk/rooms/${roomId}/players`);
      const stateRef=ref(db,`wbaduk/rooms/${roomId}/state`);
      const roomSnap=await get(roomRef);
      if(!roomSnap.exists()){ alert('í•´ë‹¹ ë°©ì´ ì—†ìŠµë‹ˆë‹¤. ë°© ì´ë¦„ì„ í™•ì¸í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„±í•´ì£¼ì„¸ìš”.'); return; }

      let myRole=1;
      const txn=await runTransaction(playersRef,(players)=>{
        players = players || {};
        const ids=Object.keys(players);
        const hasMe=!!players[uid];
        if(!hasMe && ids.length>=2) return; // full
        if(hasMe){ myRole=players[uid].role??1; return players; }
        const rolesTaken=Object.values(players).map(p=>p.role);
        myRole = rolesTaken.includes(0)?1:0;
        players[uid]={ role:myRole, joinedAt:Date.now() };
        return players;
      });
      if(!txn.committed){
        const after=await get(playersRef);
        const cnt=after.exists()?Object.keys(after.val()).length:0;
        if(cnt>=2 && !(after.val() && after.val()[uid])) alert('ì´ë¯¸ 2ëª…ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë°©ì„ ì´ìš©í•´ ì£¼ì„¸ìš”.');
        else alert('ì…ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
        return;
      }
      const playersNow=txn.snapshot.val()||{};
      const cntNow=Math.min(2,Object.keys(playersNow).length);
      await update(roomRef,{ playerCount:cntNow, status: cntNow>=2?'playing':'waiting' });
      const st=await get(stateRef); if(!st.exists()) await set(stateRef, initialState());
      onDisconnect(ref(db, `wbaduk/rooms/${roomId}/players/${uid}`)).remove();
      enterRoom(roomId, myRole);
    };

    function enterRoom(roomId, role){
      local.roomId=roomId; local.role=role;

      if(unsubRoom){ unsubRoom(); unsubRoom=null; }
      if(unsubPlayers){ unsubPlayers(); unsubPlayers=null; }

      document.getElementById('setup').style.display='none';
      document.getElementById('panel').style.display='flex';
      document.getElementById('turnLine').style.display='block';
      document.getElementById('scores').style.display='block';
      document.getElementById('bottomBar').style.display='flex';

      roomLine.textContent=`ë°©: ${roomId} â€” ë‚˜ëŠ” ${role===0?'P1(ë¹¨ê°•)':'P2(íŒŒë‘)'} ì…ë‹ˆë‹¤.`;

      makeBoard();

      unsubRoom = onValue(ref(db, `wbaduk/rooms/${roomId}`), snap=>{
        const room=snap.val();
        if(!room){ alert('ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.'); location.reload(); return; }
        if(room.state) applyRemote(room.state);
        if(room.state?.phase==='ended'){ cleanupRoomAfterEnd(roomId, 1500); }
        if(room.status==='waiting'){ const t=document.getElementById('turnColor'); t.textContent='ìƒëŒ€ ëŒ€ê¸° ì¤‘â€¦'; t.style.color='#777'; }
      });

      unsubPlayers = onValue(ref(db, `wbaduk/rooms/${roomId}/players`), snap=>{
        if(cleanupScheduled) return;
        const cnt = snap.exists()?Object.keys(snap.val()).length:0;
        update(ref(db, `wbaduk/rooms/${roomId}`), { playerCount:Math.min(2,cnt), status: cnt>=2?'playing':'waiting' });
      });

      resetBtn.onclick = async ()=>{
        await runTransaction(ref(db, `wbaduk/rooms/${roomId}`), room=>{
          if(!room) return room;
          room.status = (room.players && Object.keys(room.players).length>=2) ? 'playing' : 'waiting';
          room.state = initialState();
          return room;
        });
      };

      helpOverlay.style.display='flex';
      helpCloseBtn.onclick = ()=> helpOverlay.style.display='none';
    }

    window.addEventListener('beforeunload', ()=>{
      if(local.roomId) remove(ref(db, `wbaduk/rooms/${local.roomId}/players/${uid}`));
    });

    /* ================= ë°© ì •ë¦¬ ================= */
    async function cleanupRoomAfterEnd(roomId, delay=2500){
      if(!roomId || cleanupScheduled) return;
      cleanupScheduled=true;
      setTimeout(async()=>{
        try{
          if(unsubRoom){unsubRoom();unsubRoom=null;}
          if(unsubPlayers){unsubPlayers();unsubPlayers=null;}
          const lockRef=ref(db,`wbaduk/rooms/${roomId}/__cleanupLock`);
          const res=await runTransaction(lockRef,v=>v||uid);
          if(!res.committed || res.snapshot.val()!==uid) return;
          await remove(ref(db,`wbaduk/rooms/${roomId}`));
          const latestSnap=await get(ref(db,'wbaduk/latestRoom'));
          if(latestSnap.exists() && latestSnap.val()?.roomCode===roomId){ await remove(ref(db,'wbaduk/latestRoom')); }
        }catch(e){ console.error('ë°© ìë™ ì‚­ì œ ì¤‘ ì˜¤ë¥˜:',e); }
        finally{ location.reload(); }
      }, delay);
    }

    // ë„ì›€ë§ open/close ì „ì—­ ë…¸ì¶œ
    function openHelp(){ helpOverlay.style.display='flex'; }
    function closeHelp(){ helpOverlay.style.display='none'; }
    window.openHelp=openHelp; window.closeHelp=closeHelp;
    helpOverlay.addEventListener('click',(e)=>{ if(e.target===helpOverlay) closeHelp(); });

    // ì¢…ë£Œ ë²„íŠ¼
    endBtn.onclick = async ()=>{
      if(!local.roomId) return;
      const roomId=local.roomId;
      const ok=confirm('ì •ë§ ê²Œì„ì„ ì¢…ë£Œí•˜ê³  ë°©ì„ ì‚­ì œí• ê¹Œìš”?'); if(!ok) return;
      try{
        if(unsubRoom){unsubRoom();unsubRoom=null;}
        if(unsubPlayers){unsubPlayers();unsubPlayers=null;}
        await remove(ref(db,`wbaduk/rooms/${roomId}`));
        const latestSnap=await get(ref(db,'wbaduk/latestRoom'));
        if(latestSnap.exists() && latestSnap.val()?.roomCode===roomId){ await remove(ref(db,'wbaduk/latestRoom')); }
      }catch(e){
        alert('ë°© ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        console.error(e);
      }finally{ location.reload(); }
    };

    /* ================= ì˜¤ë””ì˜¤ UI ================= */
    function applyVolumeUI(volume, muted){
      allSounds.forEach(a=>{ a.volume=volume; a.muted=muted; });
      volSlider.value=String(volume);
      volVal.textContent=`${Math.round(volume*100)}%`;
      muteBtn.textContent = muted ? 'ğŸ”‡' : 'ğŸ”Š';
      muteBtn.setAttribute('aria-pressed', muted ? 'true' : 'false');
    }
    function restoreAudioPrefs(){
      const savedVol=parseFloat(localStorage.getItem('wb_vol')??'1');
      const savedMute=localStorage.getItem('wb_mute')==='1';
      applyVolumeUI(isNaN(savedVol)?1:savedVol, savedMute);
    }
    volSlider.addEventListener('input', (e)=>{
      const v=parseFloat(e.target.value);
      applyVolumeUI(v, muteBtn.getAttribute('aria-pressed')==='true');
      localStorage.setItem('wb_vol', String(v));
    });
    muteBtn.addEventListener('click', ()=>{
      const nowMuted = !(muteBtn.getAttribute('aria-pressed')==='true');
      applyVolumeUI(parseFloat(volSlider.value||'1'), nowMuted);
      localStorage.setItem('wb_mute', nowMuted ? '1':'0');
    });
    restoreAudioPrefs();
  </script>
</body>
</html>
