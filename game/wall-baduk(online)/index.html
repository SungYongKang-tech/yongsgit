<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Wall-baduk (온라인 2인 · 7x7)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root { --bar-h: 60px; }
    body {
      font-family: sans-serif;
      background: #f5f5f5;
      text-align: center;
      margin: 0;
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto auto auto auto auto; /* 모두 auto로 간격 최소화 */
    }
    h1 { margin: 8px 0 4px; }
    #panel { margin: 4px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    button {
      padding: 10px 14px; border: 1px solid #999; border-radius: 10px; background: #fff; cursor: pointer; font-size: 15px;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }
    #roomLine { font-size: 13px; color:#555; margin: 2px 0 4px; }
    #turnLine { margin: 2px 0; font-size: 16px; }
    #scores   { margin: 0 0 4px; font-size: 14px; }

    #wrap { display:flex; justify-content:center; align-items:flex-start; padding: 0 10px 6px; overflow:auto; }
    #board {
      display: grid; background: #fff; border: 2px solid #333; user-select: none; touch-action: manipulation;
    }
    .cell { box-sizing: border-box; border: 1px solid #000; display:flex; align-items:center; justify-content:center; }
    .point { width: 42px; height: 42px; background:#fff; position:relative; cursor:pointer; transition: background .1s; }
    .piece { width: 80%; height: 80%; border-radius: 50%; pointer-events:none; }
    .h-wall { width: 42px; height: 15px; background:#fff; cursor:pointer; }
    .v-wall { width: 15px; height: 42px; background:#fff; cursor:pointer; }
    .blank  { width: 15px; height: 15px; background:#15326b; }

    .movable { background:#d0d0d0 !important; }
    .placed  { }

    .final-p1-region { background:#ffd6e7 !important; }
    .final-p2-region { background:#d6ecff !important; }

    #bottomBar {
      position: sticky; bottom: 0; left: 0; right: 0;
      background: #ffffffcc; backdrop-filter: blur(6px);
      border-top: 1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center; padding: 6px 12px;
    }
    #skipWallBtn {
      width: min(340px, 92vw); height: 40px; border-radius: 12px; font-weight: 700;
      background:#ffd6e7; border:1px solid #e7a3bd;
    }

    /* 도움말 모달 */
    #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:9999; padding:16px; }
    #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
    #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
    #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
    #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
    #helpBody ul ul { margin-left:6px; padding-left:10px; }
    #helpBody li { margin:4px 0; }
    #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
    .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }

    @media (max-width: 420px){
      .point { width: 36px; height: 36px; }
      .h-wall { width: 36px; height: 14px; }
      .v-wall { width: 14px; height: 36px; }
    }
  </style>
</head>
<body>
  <h1>Wall-baduk (벽바둑)</h1>

  <div id="panel">
    <button id="resetBtn">새로 시작</button>
    <button id="helpBtn">도움말</button>
  </div>

  <div id="roomLine">방 연결 중…</div>
  <div id="turnLine">현재 턴: <span id="turnColor"></span></div>
  <div id="scores">P1(빨강): <span id="s1">0</span> / P2(파랑): <span id="s2">0</span></div>

  <div id="wrap"><div id="board"></div></div>

  <div id="bottomBar">
    <button id="skipWallBtn" disabled>이동 없이 벽 설치</button>
  </div>

  <!-- 도움말 -->
  <div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div id="helpCard">
      <div id="helpHeader"><span id="helpTitle">게임 설명</span></div>
      <div id="helpBody">
        <ul>
          <li><strong>목표</strong>: 벽으로 보드를 나눠 <strong>한쪽만 포함된 구역</strong>을 많이 만들기.</li>
          <li><strong>턴 진행</strong>: 내 말 하나 선택 → <strong>이동</strong>(또는 생략) → <strong>벽 1개 설치</strong> → 상대 턴.</li>
          <li><strong>이동 규칙</strong>:
            <ul>
              <li>상하좌우 <strong>1칸</strong> 또는 <strong>1칸+1칸</strong>(직각 가능).</li>
              <li><strong>벽 통과 불가</strong>, 도착 칸에 말 있으면 불가.</li>
              <li>이동 가능 칸은 <strong>짙은 회색</strong>으로 표시.</li>
              <li>갈 곳이 없으면 <strong>이동 없이 바로 벽 설치</strong>.</li>
            </ul>
          </li>
          <li><strong>벽 설치</strong>: 빈 가로/세로 벽 칸에 <strong>1개</strong> 설치, <strong>제거 불가</strong>.</li>
          <li><strong>구역/승리</strong>: 벽 없이 이어진 점들의 집합이 구역. 한쪽 말만 있으면 그쪽 소유. 혼재 구역이 없어지면 종료, 소유 구역 점 합으로 승부.</li>
        </ul>
      </div>
      <div id="helpFooter">
        <button class="helpBtn" id="helpCloseBtn">시작하기</button>
      </div>
    </div>
  </div>

  <!-- 앱 스크립트 (모듈) -->
  <script type="module">
    /* ================= Firebase ================= */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, get, set, onValue, runTransaction, onDisconnect
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.firebasestorage.app",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:1f66d8195af8c6ce91a561"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    // 탭마다 고유 uid (같은 브라우저 2탭 테스트 가능)
    const uid = (() => {
      const key = 'wb_uid_tab';
      let v = sessionStorage.getItem(key);
      if (!v) {
        v = (crypto.randomUUID?.() || ('u_' + Math.random().toString(36).slice(2)));
        sessionStorage.setItem(key, v);
      }
      return v;
    })();

    /* ====== 자동 방 매칭: 1분 내 waiting 방 찾기 → 없으면 생성 ====== */
    async function autoRoom() {
      const now = Date.now();

      // 1) 전체 rooms 읽고 조건에 맞는 첫 방 고르기 (인덱스/쿼리 불필요)
      const snap = await get(ref(db, "rooms"));
      let targetId = null;

      snap.forEach(cs => {
        const r = cs.val() || {};
        const created = typeof r.createdAt === 'number' ? r.createdAt : 0;
        const cnt = r.playerCount || 0;
        if (!targetId && r.status === "waiting" && cnt < 2 && (now - created) <= 60_000) {
          targetId = cs.key;
        }
      });

      // 2) 없으면 새 방 생성
      if (!targetId) {
        const roomId = crypto.randomUUID?.() || ('r_' + Math.random().toString(36).slice(2));
        const nowMs = Date.now();
        await set(ref(db, `rooms/${roomId}`), {
          status: "waiting",
          createdAt: nowMs,      // serverTimestamp() 미사용 (환경 의존 제거)
          playerCount: 1,
          players: { [uid]: { role: 0, joinedAt: nowMs } }
        });
        onDisconnect(ref(db, `rooms/${roomId}/players/${uid}`)).remove();
        return { roomId, role: 0 };
      }

      // 3) 있으면 트랜잭션으로 합류 (2명 제한)
      let myRole = 1;
      await runTransaction(ref(db, `rooms/${targetId}`), room => {
        if (!room) return;
        const cnt = room.playerCount || 0;
        if (cnt >= 2) return; // 꽉 찼으면 취소

        if (!room.players) room.players = {};
        const rolesTaken = Object.values(room.players).map(p => p.role);
        myRole = rolesTaken.includes(0) ? 1 : 0;

        const nowMs = Date.now();
        room.players[uid] = { role: myRole, joinedAt: nowMs };

        // 실제 인원 다시 산정(같은 uid 중복 방지)
        const uniqueCount = new Set(Object.keys(room.players)).size;
        room.playerCount = Math.min(2, uniqueCount);

        if (room.playerCount === 2) {
          room.status = "playing";
          if (!room.state) room.state = initialState();
        }
        return room;
      });

      onDisconnect(ref(db, `rooms/${targetId}/players/${uid}`)).remove();
      return { roomId: targetId, role: myRole };
    }

    /* ================= 게임 로직(동기화) ================= */
    const BOARD_POINTS = 7;
    const GRID = BOARD_POINTS * 2 - 1;
    const COLORS = ['#e74c3c', '#3498db'];

    const boardEl = document.getElementById('board');
    const turnEl  = document.getElementById('turnColor');
    const s1El    = document.getElementById('s1');
    const s2El    = document.getElementById('s2');
    const resetBtn= document.getElementById('resetBtn');
    const helpBtn = document.getElementById('helpBtn');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpCloseBtn = document.getElementById('helpCloseBtn');
    const skipWallBtn = document.getElementById('skipWallBtn');
    const roomLine = document.getElementById('roomLine');

    let grid = [];
    let local = {
      roomId: null,
      role: 0,
      state: null,        // 방의 단일 진실
      selected: null,
      applyingRemote: false
    };

    function pt(p){ return (p-1)*2; }
    function initialState(){
      return {
        phase: 'place-extra',               // 'place-extra' | 'move' | 'wall' | 'ended'
        current: 0,                         // 현재 플레이어(0=P1,1=P2)
        extraOrder: [0,1,1,0],
        extraIdx: 0,
        pieces: {
          "0": [{r:pt(2),c:pt(2)}, {r:pt(6),c:pt(6)}],
          "1": [{r:pt(6),c:pt(2)}, {r:pt(2),c:pt(6)}]
        },
        walls: []                           // {r,c,owner}
      };
    }

    function makeBoard(){
      boardEl.innerHTML = '';
      boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
      boardEl.style.gridTemplateRows    = `repeat(${GRID}, auto)`;
      grid = Array.from({length: GRID}, () => Array(GRID).fill(null));

      for (let r=0;r<GRID;r++){
        for (let c=0;c<GRID;c++){
          const cell = document.createElement('div');
          cell.classList.add('cell');
          if (r%2===0 && c%2===0){
            cell.classList.add('point');
            cell.addEventListener('click', ()=>onPointClick(r,c));
          } else if (r%2===1 && c%2===0){
            cell.classList.add('h-wall');
            cell.addEventListener('click', ()=>onWallClick(r,c));
          } else if (r%2===0 && c%2===1){
            cell.classList.add('v-wall');
            cell.addEventListener('click', ()=>onWallClick(r,c));
          } else {
            cell.classList.add('blank');
          }
          boardEl.appendChild(cell);
          grid[r][c] = cell;
        }
      }
    }

    function clearFinalPaint(){
      document.querySelectorAll('.final-p1-region, .final-p2-region').forEach(el=>{
        el.classList.remove('final-p1-region','final-p2-region');
        if (el.classList.contains('point')) el.style.background = '#fff';
      });
    }
    function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }

    function renderFromState(){
      const state = local.state;
      if (!state) return;

      // 상단 안내/버튼
      turnEl.textContent = `Player ${state.current+1}`;
      turnEl.style.color = COLORS[state.current];
      skipWallBtn.disabled = (state.phase !== 'move') || (state.current !== local.role);

      // 기존 표시 초기화
      clearMovable();
      if (state.phase !== 'ended') clearFinalPaint();

      // 말 초기화
      document.querySelectorAll('.piece').forEach(el => el.remove());
      for (const pid of [0,1]){
        for (const p of state.pieces[String(pid)]){
          const cell = grid[p.r][p.c];
          const dot = document.createElement('div');
          dot.classList.add('piece');
          dot.style.background = COLORS[pid];
          dot.dataset.player = String(pid);
          cell.appendChild(dot);
        }
      }
      // 벽 초기화
      for (let r=0;r<GRID;r++){
        for(let c=0;c<GRID;c++){
          const cell=grid[r][c];
          if (!cell) continue;
          if (cell.classList.contains('h-wall') || cell.classList.contains('v-wall')){
            cell.classList.remove('placed');
            cell.style.background = '#fff';
          }
        }
      }
      for (const w of state.walls){
        const cell = grid[w.r]?.[w.c];
        if (cell){
          cell.classList.add('placed');
          cell.style.background = COLORS[w.owner];
        }
      }

      // 점수/종료 반영
      updateScoresLocal();
      if (state.phase === 'ended') fillFinalRegionsLocal(); // 재접속 시 색 유지
    }

    function isMyTurn(){ return local.state && local.state.current === local.role; }

    // ===== UI 이벤트 =====
    function onPointClick(r,c){
      const state = local.state;
      if (!state) return;

      // 배치 단계
      if (state.phase === 'place-extra'){
        if (!isMyTurn()) return;
        const cell = grid[r][c];
        if (cell.querySelector('.piece')) return;

        state.pieces[String(state.current)].push({r,c});
        state.extraIdx++;
        if (state.extraIdx >= state.extraOrder.length){
          state.phase = 'move'; // current는 그대로(0부터 시작)
        } else {
          state.current = state.extraOrder[state.extraIdx];
        }
        commitState();
        return;
      }

      // 이동 단계
      if (state.phase === 'move'){
        if (!isMyTurn()) return;
        const cell = grid[r][c];
        const piece = cell.querySelector('.piece');
        if (local.selected && local.selected.r===r && local.selected.c===c){
          local.selected = null; clearMovable(); return;
        }
        if (!local.selected && piece && +piece.dataset.player === local.role){
          local.selected = { r, c };
          const cnt = showMovableFrom(r,c);
          if (cnt === 0){ local.selected = null; clearMovable(); }
          return;
        }
        if (local.selected && cell.classList.contains('movable')){
          const arr = state.pieces[String(local.role)];
          const idx = arr.findIndex(p => p.r===local.selected.r && p.c===local.selected.c);
          if (idx>=0){
            arr[idx] = { r, c };
            state.phase = 'wall';
            clearMovable();
            local.selected = null;
            commitState();
          }
        }
      }
      // wall 단계에서 점 클릭 무시
    }

    function onWallClick(r,c){
      const state = local.state;
      if (!state) return;
      if (state.phase !== 'wall') return;
      if (!isMyTurn()) return;

      const cell = grid[r][c];
      const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
      if (!isWall) return;
      if (cell.classList.contains('placed')) return;

      state.walls.push({ r, c, owner: local.role });

      // 종료 체크(로컬 계산)
      const end = checkGameEndAndScoreLocal();
      if (end){ state.phase = 'ended'; commitState(); showWinnerWithPaintLocal(); return; }

      // 턴 교대
      state.current = 1 - state.current;
      state.phase = 'move';
      commitState();
    }

    document.getElementById('skipWallBtn').addEventListener('click', ()=>{
      const state = local.state;
      if (!state) return;
      if (state.phase !== 'move') return;
      if (!isMyTurn()) return;
      clearMovable(); local.selected = null;
      state.phase = 'wall';
      commitState();
    });

    // ===== 이동/표시 유틸 =====
    function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
    function isPoint(r,c){ return (r%2===0) && (c%2===0); }

    function neighborsReachable(r,c){
      const dirs = [{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}];
      const out=[];
      for (const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc;
        if (!inBounds(nr,nc) || !isPoint(nr,nc)) continue;
        const wr=r+dr/2, wc=c+dc/2;
        const wall = grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall') || wall.classList.contains('v-wall'));
        if (!isWallPos) continue;
        if (wall.classList.contains('placed')) continue;
        if (grid[nr][nc].querySelector('.piece')) continue;
        out.push({nr,nc});
      }
      return out;
    }

    function markMovable(sr,sc,mark=true){
      const visited = Array.from({length:GRID},()=>Array(GRID).fill(false));
      const q=[]; visited[sr][sc]=true; q.push({r:sr,c:sc,d:0}); let cnt=0;
      while(q.length){
        const {r,c,d}=q.shift();
        if (d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
          if (mark) grid[r][c].classList.add('movable'); cnt++;
        }
        if (d===2) continue;
        for (const {nr,nc} of neighborsReachable(r,c)){
          if (!visited[nr][nc]){ visited[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
        }
      }
      return cnt;
    }
    function showMovableFrom(sr,sc){ clearMovable(); return markMovable(sr,sc,true); }

    // ===== 점수/종료(로컬 계산) =====
    function neighborsByWall(r,c){
      const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}];
      const out=[];
      for (const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc;
        if (!inBounds(nr,nc) || !isPoint(nr,nc)) continue;
        const wr = r+dr/2, wc = c+dc/2;
        const wall = grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall') || wall.classList.contains('v-wall'));
        if (!isWallPos) continue;
        if (wall.classList.contains('placed')) continue;
        out.push({nr,nc});
      }
      return out;
    }

    function computeRegionsLocal(){
      const visited = Array.from({length:GRID},()=>Array(GRID).fill(false));
      const regions=[]; let hasMixed=false;
      for (let r=0;r<GRID;r+=2){
        for (let c=0;c<GRID;c+=2){
          if (visited[r][c]) continue;
          const queue=[{r,c}]; visited[r][c]=true; const pts=[]; const present=new Set();
          while(queue.length){
            const cur=queue.shift(); pts.push(cur);
            const piece=grid[cur.r][cur.c].querySelector('.piece');
            if (piece) present.add(+piece.dataset.player);
            for (const {nr,nc} of neighborsByWall(cur.r,cur.c)){
              if (!visited[nr][nc]){ visited[nr][nc]=true; queue.push({r:nr,c:nc}); }
            }
          }
          if (present.size>=2) hasMixed = true;
          regions.push({points:pts, players:present});
        }
      }
      return {regions, hasMixed};
    }

    function checkGameEndAndScoreLocal(){
      const {regions, hasMixed}=computeRegionsLocal();
      const scores=[0,0];
      for (const reg of regions){
        if (reg.players.size===1){
          const owner=[...reg.players][0];
          scores[owner]+=reg.points.length;
        }
      }
      s1El.textContent = scores[0];
      s2El.textContent = scores[1];
      return !hasMixed;
    }
    function updateScoresLocal(){ const end = checkGameEndAndScoreLocal(); if (end && local.state?.phase!=='ended'){ showWinnerWithPaintLocal(); } }
    function showWinnerWithPaintLocal(){
      fillFinalRegionsLocal();
      const p1 = parseInt(s1El.textContent,10);
      const p2 = parseInt(s2El.textContent,10);
      let msg = `게임 종료!\nP1(빨강): ${p1} / P2(파랑): ${p2}\n`;
      if (p1>p2) msg += '승자: P1(빨강)'; else if (p2>p1) msg += '승자: P2(파랑)'; else msg += '무승부';
      if (local.state?.phase!=='ended') alert(msg);
      if (local.state) { local.state.phase='ended'; commitState(); }
    }
    function fillFinalRegionsLocal(){
      const {regions}=computeRegionsLocal();
      for (const reg of regions){
        if (reg.players.size!==1) continue;
        const owner=[...reg.players][0];
        for (const {r,c} of reg.points){
          grid[r][c].classList.remove('movable');
          if (owner===0) grid[r][c].classList.add('final-p1-region');
          else grid[r][c].classList.add('final-p2-region');
        }
      }
    }

    /* ===== DB 커밋/구독 ===== */
    async function commitState(){
      if (!local.roomId || !local.state) return;
      await set(ref(db, `rooms/${local.roomId}/state`), local.state);
    }

    function applyRemote(state){
      local.applyingRemote = true;
      local.state = state;
      renderFromState();
      local.applyingRemote = false;
    }

    /* ===== 초기화 & 매칭 ===== */
    function openHelp(){ helpOverlay.style.display='flex'; }
    function closeHelp(){ helpOverlay.style.display='none'; }
    helpBtn.addEventListener('click', openHelp);
    helpCloseBtn.addEventListener('click', closeHelp);
    helpOverlay.addEventListener('click', e=>{ if(e.target===helpOverlay) closeHelp(); });

    async function main(){
      makeBoard();
      const { roomId, role } = await autoRoom();
      local.roomId = roomId; local.role = role;

      roomLine.textContent = `방: ${roomId} — 나는 ${role===0?'P1(빨강)':'P2(파랑)'} 입니다.`;

      // 방 상태 구독
      onValue(ref(db, `rooms/${roomId}`), snap=>{
        const room = snap.val();
        if (!room) return;
        if (room.status==='waiting'){
          turnEl.textContent = `상대 대기 중…`; turnEl.style.color = '#888';
        }
        if (room.state){ applyRemote(room.state); }
      });

      // 리셋: 같은 방에서 새 게임 시작
      resetBtn.addEventListener('click', async ()=>{
        if (!local.roomId) return;
        await runTransaction(ref(db, `rooms/${local.roomId}`), room=>{
          if (!room) return room;
          room.status = room.playerCount>=2 ? 'playing' : 'waiting';
          room.state = initialState();
          return room;
        });
      });

      openHelp(); // 처음에 도움말
    }

    window.addEventListener('load', main);
  </script>
</body>
</html>
