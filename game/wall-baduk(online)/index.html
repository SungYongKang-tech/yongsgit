<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Wall-baduk (ì˜¨ë¼ì¸ 2ì¸ Â· 7x7)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root { --bar-h: 60px; }
    body { font-family: sans-serif; background:#f5f5f5; text-align:center; margin:0; min-height:100vh;
      display:grid; grid-template-rows:auto auto auto auto auto; }
    h1 { margin: 8px 0 4px; }
    #setup { margin:10px 0 4px; }
    #setup .row { display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; }
    #roomInput { width:min(260px, 70vw); padding: 10px 12px; border:1px solid #bbb; border-radius:8px; font-size:16px; }
    #setup button { padding: 12px 14px; border-radius:10px; border:1px solid #999; background:#fff; cursor:pointer; }
    #roomLine { font-size:13px; color:#555; margin: 6px 0 6px; }
    #turnLine { margin:2px 0; font-size:16px; }
    #scores   { margin:0 0 4px; font-size:14px; }

    #wrap { display:flex; justify-content:center; align-items:flex-start; padding: 0 10px 6px; overflow:auto; }
    #board { display:grid; background:#fff; border:2px solid #333; user-select:none; touch-action:manipulation; }
    .cell { box-sizing:border-box; border:1px solid #000; display:flex; align-items:center; justify-content:center; }
    .point { width:42px; height:42px; background:#fff; position:relative; cursor:pointer; transition:background .1s; }
    .piece { width:80%; height:80%; border-radius:50%; pointer-events:none; }
    .h-wall { width:42px; height:15px; background:#fff; cursor:pointer; }
    .v-wall { width:15px; height:42px; background:#fff; cursor:pointer; }
    .blank  { width:15px; height:15px; background:#15326b; }
    .movable { background:#d0d0d0 !important; }
    .final-p1-region { background:#ffd6e7 !important; }
    .final-p2-region { background:#d6ecff !important; }

    #bottomBar { position:sticky; bottom:0; left:0; right:0; background:#ffffffcc; backdrop-filter:blur(6px);
      border-top:1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center; padding:6px 12px; }
    #skipWallBtn { width:min(340px,92vw); height:40px; border-radius:12px; font-weight:700; background:#ffd6e7; border:1px solid #e7a3bd; }

    #panel { margin:4px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    #panel button { padding:10px 14px; border:1px solid #999; border-radius:10px; background:#fff; cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }

    /* ë„ì›€ë§ ëª¨ë‹¬ */
    #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:10000; padding:16px; }
    #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
    #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
    #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
    #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
    #helpBody ul ul { margin-left:6px; padding-left:10px; }
    #helpBody li { margin:4px 0; }
    #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
    .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }

    @media (max-width:420px){
      .point { width:36px; height:36px; }
      .h-wall { width:36px; height:14px; }
      .v-wall { width:14px; height:36px; }
    }
  </style>
</head>
<body>
  <h1>Wall-baduk (ë²½ë°”ë‘‘)</h1>

  <!-- ë°© ìƒì„±/ì°¸ì—¬ -->
  <div id="setup">
    <div class="row">
      <input id="roomInput" type="text" placeholder="ë°© ì´ë¦„ì„ ì ì–´ì£¼ì„¸ìš” (ì˜ˆ: ë¶€ì—‰ì´1929)" />
      <button id="btnCreate">ë°© ìƒì„±í•˜ê¸°</button>
      <button id="btnJoin">ë°© ì°¸ì—¬í•˜ê¸°</button>
    </div>
    <div id="roomLine">ëŒ€ê¸° ì¤‘â€¦</div>
  </div>

  <!-- ê²Œì„ íŒ¨ë„ -->
  <div id="panel" style="display:none">
    <button id="resetBtn">ìƒˆë¡œ ì‹œì‘</button>
    <button id="helpBtn" onclick="openHelp()">ë„ì›€ë§</button>
    <button id="endBtn">ê²Œì„ ì¢…ë£Œ</button>
  </div>
  <div id="turnLine" style="display:none">í˜„ì¬ í„´: <span id="turnColor"></span></div>
  <div id="scores"   style="display:none">P1(ë¹¨ê°•): <span id="s1">0</span> / P2(íŒŒë‘): <span id="s2">0</span></div>

  <div id="wrap"><div id="board"></div></div>

  <div id="bottomBar" style="display:none">
    <button id="skipWallBtn" disabled>ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜</button>
  </div>

  <!-- ì„¤ëª… íŒì—… -->
  <div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div id="helpCard">
      <div id="helpHeader"><span id="helpTitle">ê²Œì„ ì„¤ëª…</span></div>
      <div id="helpBody">
        <ul>
  <li><strong>ëª©í‘œ</strong>: ë²½ìœ¼ë¡œ ì¹¸ë“¤ì„ ë§‰ì•„ <strong>ë‚´ ë§ë§Œ ë“¤ì–´ ìˆëŠ” ì˜ì—­</strong>ì„ ë§ì´ ë§Œë“¤ê¸°.</li>
  <li><strong>í„´ ì§„í–‰</strong>: ë‚´ ë§ í•˜ë‚˜ ì„ íƒ â†’ <strong>ì´ë™</strong>(ê±´ë„ˆë›°ê¸° ê°€ëŠ¥) â†’ <strong>ë²½ 1ê°œ ì„¤ì¹˜</strong> â†’ ìƒëŒ€ í„´.</li>
  <li><strong>ì´ë™ ê·œì¹™</strong>:
    <ul>
      <li>ìƒí•˜ì¢Œìš°ë¡œ <strong>1ì¹¸</strong> ë˜ëŠ” <strong>1ì¹¸+1ì¹¸</strong>(ì§ê° ì´ë™ ê°€ëŠ¥).</li>
      <li><strong>ë²½ì€ ì§€ë‚˜ê°ˆ ìˆ˜ ì—†ìŒ</strong>, ë‹¤ë¥¸ ë§ì´ ìˆëŠ” ì¹¸ìœ¼ë¡œëŠ” ì´ë™ ë¶ˆê°€.</li>
      <li>ì´ë™ ê°€ëŠ¥í•œ ì¹¸ì€ <strong>ì§™ì€ íšŒìƒ‰</strong>ìœ¼ë¡œ í‘œì‹œ.</li>
      <li>ì´ë™í•  ê³³ì´ ì—†ìœ¼ë©´ <strong>ë°”ë¡œ ë²½ ì„¤ì¹˜</strong>ë¡œ ì§„í–‰.</li>
    </ul>
  </li>
  <li><strong>ë²½ ì„¤ì¹˜</strong>: ë¹ˆ ê°€ë¡œ/ì„¸ë¡œ ë²½ ì¹¸ì—ë§Œ ì„¤ì¹˜ ê°€ëŠ¥, <strong>í•œ ë²ˆ ë†“ìœ¼ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŒ</strong>.</li>
  <li><strong>ì˜ì—­ & ìŠ¹ë¦¬</strong>:
    <ul>
      <li>ë²½ìœ¼ë¡œ ì„œë¡œ ì´ì–´ì§„ ë¹ˆ ì¹¸ë“¤ì˜ ë¬¶ìŒì„ <strong>ì˜ì—­</strong>ì´ë¼ê³  í•¨.</li>
      <li><strong>í•œìª½ í”Œë ˆì´ì–´ì˜ ë§ë§Œ</strong> ë“¤ì–´ ìˆëŠ” ì˜ì—­ë§Œ ê·¸ í”Œë ˆì´ì–´ê°€ ê°€ì§.</li>
      <li>ë‘ í”Œë ˆì´ì–´ì˜ ë§ì´ í•¨ê»˜ ìˆìœ¼ë©´ ê·¸ ì˜ì—­ì€ <strong>ì•„ë¬´ë„ ê°€ì§€ì§€ ì•ŠìŒ</strong>.</li>
      <li>ì„ì—¬ ìˆëŠ” ì˜ì—­ì´ ëª¨ë‘ ì‚¬ë¼ì§€ëŠ” ìˆœê°„ ê²Œì„ ì¢…ë£Œ â†’ <strong>ìì‹ ì˜ ì˜ì—­ì— í¬í•¨ëœ ì¹¸ ìˆ˜</strong>ê°€ ë” ë§ì€ ì‚¬ëŒì´ ìŠ¹ë¦¬.</li>
    </ul>
  </li>
</ul>

      </div>
      <div id="helpFooter">
        <button class="helpBtn" id="helpCloseBtn">ì‹œì‘í•˜ê¸°</button>
      </div>
    </div>
  </div>

  <!-- ì•± ìŠ¤í¬ë¦½íŠ¸ -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getDatabase, ref, get, set, onValue, runTransaction, onDisconnect, remove, update } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.appspot.com",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:8cc90ab5a17c364b91a561"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    /* ---------- ë°© ì´ë¦„/ìœ ì € ID ---------- */
    const uid = (() => {
      const key='wb_uid_tab'; let v=sessionStorage.getItem(key);
      if(!v){ v=(crypto.randomUUID?.()||('u_'+Math.random().toString(36).slice(2))); sessionStorage.setItem(key,v); }
      return v;
    })();

    // ê¸ˆì§€ë¬¸ì(. # $ [ ] /) ì œê±° + ì•ë’¤ ê³µë°± ì œê±°
    function sanitizeRoomName(raw){
      return raw.trim().replace(/[.#$/\[\]\/]/g,'-').slice(0, 32);
    }
    function requireRoomName() {
      const raw = document.getElementById('roomInput').value;
      const id = sanitizeRoomName(raw||'');
      if (!id) { alert('ë°© ì´ë¦„ì„ ì ì–´ì£¼ì„¸ìš”. (ì˜ˆ: ë¶€ì—‰ì´1929)'); return null; }
      return id;
    }

    /* ---------- ìƒìˆ˜/DOM ---------- */
    const MAX_ROOMS = 10;
    const BOARD_POINTS = 7;
    const GRID = BOARD_POINTS*2-1;
    const COLORS = ['#e74c3c','#3498db'];

    const boardEl = document.getElementById('board');
    const roomLine= document.getElementById('roomLine');
    const resetBtn= document.getElementById('resetBtn');
    const helpBtn = document.getElementById('helpBtn');
    const endBtn  = document.getElementById('endBtn');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpCloseBtn = document.getElementById('helpCloseBtn');
    const skipWallBtn = document.getElementById('skipWallBtn');
    const turnEl  = document.getElementById('turnColor');
    const s1El    = document.getElementById('s1');
    const s2El    = document.getElementById('s2');

    let grid = [];
    let local = { roomId:null, role:0, state:null, selected:null };

    // ğŸ”” êµ¬ë… í•¸ë“¤(ì‚­ì œ ì‹œ ì¬ìƒì„± ë°©ì§€ìš©)
    let unsubRoom = null;
    let unsubPlayers = null;

    /* ---------- ìœ í‹¸ ---------- */
    const asArray = (x) => Array.isArray(x) ? x : (x && typeof x==='object') ? Object.values(x) : [];
    const playerCountOf = (room) => Object.keys(room?.players || {}).length;

    // ë°© 10ê°œ ì´ˆê³¼ë©´ ê°€ì¥ ì˜¤ë˜ëœ ê²ƒë¶€í„° ì‚­ì œ
    async function pruneRoomsToMax(max = MAX_ROOMS) {
      const roomsRef = ref(db, 'wbaduk/rooms');
      const snap = await get(roomsRef);
      if (!snap.exists()) return;

      let rooms = Object.entries(snap.val() || {}).map(([id, r]) => ({
        id, createdAt: r?.createdAt || 0
      }));

      if (rooms.length <= max) return;

      rooms.sort((a, b) => a.createdAt - b.createdAt);
      while (rooms.length > max) {
        const victim = rooms.shift();
        await remove(ref(db, `wbaduk/rooms/${victim.id}`));
      }
    }

    function pt(p){ return (p-1)*2; }
    function initialState(){
      return {
        phase:'place-extra', current:0, extraOrder:[0,1,1,0], extraIdx:0,
        pieces:{ "0":[{r:pt(2),c:pt(2)},{r:pt(6),c:pt(6)}], "1":[{r:pt(6),c:pt(2)},{r:pt(2),c:pt(6)}] },
        walls:[]
      };
    }
    function normalizeState(s){
      if(!s) return s;
      s.walls = asArray(s.walls);
      if(!s.pieces) s.pieces = {"0":[], "1":[]};
      s.pieces["0"] = asArray(s.pieces["0"]);
      s.pieces["1"] = asArray(s.pieces["1"]);
      s.extraOrder  = asArray(s.extraOrder || [0,1,1,0]);
      return s;
    }

    /* ---------- ë³´ë“œ ìƒì„±/ë Œë” ---------- */
    function makeBoard(){
      boardEl.innerHTML='';
      boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
      boardEl.style.gridTemplateRows    = `repeat(${GRID}, auto)`;
      grid = Array.from({length:GRID},()=>Array(GRID).fill(null));
      for(let r=0;r<GRID;r++){
        for(let c=0;c<GRID;c++){
          const cell=document.createElement('div'); cell.classList.add('cell');
          if(r%2===0&&c%2===0){ cell.classList.add('point'); cell.addEventListener('click',()=>onPointClick(r,c)); }
          else if(r%2===1&&c%2===0){ cell.classList.add('h-wall'); cell.addEventListener('click',()=>onWallClick(r,c)); }
          else if(r%2===0&&c%2===1){ cell.classList.add('v-wall'); cell.addEventListener('click',()=>onWallClick(r,c)); }
          else { cell.classList.add('blank'); }
          boardEl.appendChild(cell); grid[r][c]=cell;
        }
      }
    }

    function renderFromState(){
      const s = normalizeState(local.state);
      if(!s) return;

      const phaseLabel =
        s.phase === 'place-extra' ? ' â€” ë§ ë°°ì¹˜' :
        s.phase === 'move'        ? ' â€” ë§ ì´ë™' :
        s.phase === 'wall'        ? ' â€” ë²½ ì„¤ì¹˜' : '';
      turnEl.textContent = ((s.current===0)?'P1(ë¹¨ê°•)':'P2(íŒŒë‘)') + ' ì°¨ë¡€' + phaseLabel;
      turnEl.style.color = COLORS[s.current];

      skipWallBtn.disabled = (s.phase!=='move') || (s.current!==local.role);

      document.querySelectorAll('.piece').forEach(el=>el.remove());
      for(const pid of [0,1]){
        for(const p of asArray(s.pieces[String(pid)])){
          const cell=grid[p.r]?.[p.c]; if(!cell) continue;
          const dot=document.createElement('div');
          dot.classList.add('piece'); dot.style.background=COLORS[pid]; dot.dataset.player=String(pid);
          cell.appendChild(dot);
        }
      }
      for(let r=0;r<GRID;r++){ for(let c=0;c<GRID;c++){
        const cell=grid[r][c]; if(!cell) continue;
        if(cell.classList.contains('h-wall')||cell.classList.contains('v-wall')){ cell.classList.remove('placed'); cell.style.background='#fff'; }
      }}      
      for(const w of asArray(s.walls)){
        const cell=grid[w.r]?.[w.c]; if(cell){ cell.classList.add('placed'); cell.style.background=COLORS[w.owner]; }
      }
      updateScoresLocal();
    }

    /* ---------- ì ìˆ˜/ì˜ì—­ ê³„ì‚° ---------- */
    function inBounds(r,c){ return r>=0&&r<GRID&&c>=0&&c<GRID; }
    function isPoint(r,c){ return (r%2===0)&&(c%2===0); }
    function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }
    function neighborsReachable(r,c){
      const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
      for(const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
        const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
        if(!isWallPos) continue; if(wall.classList.contains('placed')) continue;
        if(grid[nr][nc].querySelector('.piece')) continue; out.push({nr,nc});
      } return out;
    }
    function markMovable(sr,sc,mark=true){
      const v=Array.from({length:GRID},()=>Array(GRID).fill(false)); const q=[]; v[sr][sc]=true; q.push({r:sr,c:sc,d:0}); let cnt=0;
      while(q.length){ const {r,c,d}=q.shift();
        if(d>0&&d<=2&&isPoint(r,c)&&!grid[r][c].querySelector('.piece')){ if(mark) grid[r][c].classList.add('movable'); cnt++; }
        if(d===2) continue; for(const {nr,nc} of neighborsReachable(r,c)){ if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); } }
      } return cnt;
    }
    function showMovableFrom(sr,sc){ clearMovable(); return markMovable(sr,sc,true); }

    function neighborsByWall(r,c){
      const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
      for(const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
        const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
        if(!isWallPos) continue; if(wall.classList.contains('placed')) continue; out.push({nr,nc});
      } return out;
    }
    function computeRegionsLocal(){
      const visited=Array.from({length:GRID},()=>Array(GRID).fill(false)); const regions=[]; let hasMixed=false;
      for(let r=0;r<GRID;r+=2){ for(let c=0;c<GRID;c+=2){
        if(visited[r][c]) continue; const q=[{r,c}]; visited[r][c]=true; const pts=[]; const present=new Set();
        while(q.length){ const cur=q.shift(); pts.push(cur);
          const piece=grid[cur.r][cur.c].querySelector('.piece'); if(piece) present.add(+piece.dataset.player);
          for(const {nr,nc} of neighborsByWall(cur.r,cur.c)){ if(!visited[nr][nc]){ visited[nr][nc]=true; q.push({r:nr,c:nc}); } }
        }
        if(present.size>=2) hasMixed=true; regions.push({points:pts, players:present});
      }} return {regions, hasMixed};
    }
    function checkGameEndAndScoreLocal(){
      const {regions,hasMixed}=computeRegionsLocal(); const sc=[0,0];
      for(const reg of regions){ if(reg.players.size===1){ const owner=[...reg.players][0]; sc[owner]+=reg.points.length; } }
      s1El.textContent=sc[0]; s2El.textContent=sc[1]; return !hasMixed;
    }
    function updateScoresLocal(){ const end=checkGameEndAndScoreLocal(); if(end && local.state?.phase!=='ended'){ showWinnerWithPaintLocal(); } }
    function fillFinalRegionsLocal(){
      const {regions}=computeRegionsLocal();
      for(const reg of regions){ if(reg.players.size!==1) continue; const owner=[...reg.players][0];
        for(const {r,c} of reg.points){ grid[r][c].classList.remove('movable'); (owner===0?grid[r][c].classList.add('final-p1-region'):grid[r][c].classList.add('final-p2-region')); }
      }
    }
    function showWinnerWithPaintLocal(){
      fillFinalRegionsLocal();
      const p1=+s1El.textContent, p2=+s2El.textContent;
      alert(`ê²Œì„ ì¢…ë£Œ!\nP1(ë¹¨ê°•): ${p1} / P2(íŒŒë‘): ${p2}\n`+(p1>p2?'ìŠ¹ì: P1(ë¹¨ê°•)':p2>p1?'ìŠ¹ì: P2(íŒŒë‘)':'ë¬´ìŠ¹ë¶€'));
      if(local.state){
        local.state.phase='ended';
        commitState();
        // ì¢…ë£Œ ìƒíƒœ ì»¤ë°‹ í›„ ë°© ìë™ ì‚­ì œ ì˜ˆì•½
        cleanupRoomAfterEnd(local.roomId, 2500);
      }
    }
    function isMyTurn(){ return local.state && normalizeState(local.state).current===local.role; }

    /* ---------- ì…ë ¥ ì²˜ë¦¬ ---------- */
    function onPointClick(r,c){
      local.state = normalizeState(local.state);
      const s=local.state; if(!s) return;

      if(s.phase==='place-extra'){
        if(!isMyTurn()) return;
        const cell=grid[r][c]; if(cell.querySelector('.piece')) return;
        s.pieces[String(s.current)].push({r,c}); s.extraIdx++;
        if(s.extraIdx>=s.extraOrder.length){ s.phase='move'; } else { s.current=s.extraOrder[s.extraIdx]; }
        commitState(); return;
      }

      if(s.phase==='move'){
        if(!isMyTurn()) return;
        const cell=grid[r][c]; const piece=cell.querySelector('.piece');
        if(local.selected && local.selected.r===r && local.selected.c===c){ local.selected=null; clearMovable(); return; }
        if(!local.selected && piece && +piece.dataset.player===local.role){
          local.selected={r,c}; const cnt=showMovableFrom(r,c); if(cnt===0){ local.selected=null; clearMovable(); } return;
        }
        if(local.selected && cell.classList.contains('movable')){
          const arr=s.pieces[String(local.role)]; const idx=arr.findIndex(p=>p.r===local.selected.r&&p.c===local.selected.c);
          if(idx>=0){ arr[idx]={r,c}; s.phase='wall'; clearMovable(); local.selected=null; commitState(); }
        }
      }
    }
    function onWallClick(r,c){
      local.state = normalizeState(local.state);
      const s=local.state; if(!s||s.phase!=='wall'||!isMyTurn()) return;
      const cell=grid[r][c]; const isWall=cell.classList.contains('h-wall')||cell.classList.contains('v-wall');
      if(!isWall||cell.classList.contains('placed')) return;
      s.walls.push({r,c,owner:local.role});
      const end=checkGameEndAndScoreLocal(); if(end){ s.phase='ended'; commitState(); showWinnerWithPaintLocal(); return; }
      s.current=1-s.current; s.phase='move'; commitState();
    }
    skipWallBtn.addEventListener('click',()=>{
      local.state = normalizeState(local.state);
      const s=local.state; if(!s||s.phase!=='move'||!isMyTurn()) return; clearMovable(); local.selected=null; s.phase='wall'; commitState();
    });

    /* ---------- DB ë™ê¸°í™” ---------- */
    async function commitState(){
      if(!local.roomId||!local.state) return;
      await set(ref(db, `wbaduk/rooms/${local.roomId}/state`), local.state);
    }
    function applyRemote(state){ local.state = normalizeState(state); renderFromState(); }

    /* ---------- ë°© ìƒì„±/ì°¸ì—¬ ---------- */
    const btnCreate=document.getElementById('btnCreate');
    const btnJoin  =document.getElementById('btnJoin');

    btnCreate.onclick = async ()=>{
      const roomId = requireRoomName();
      if (!roomId) return;

      await pruneRoomsToMax(10);

      const roomRef = ref(db, `wbaduk/rooms/${roomId}`);
      const exist = await get(roomRef);
      if (exist.exists()) { alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°© ì´ë¦„ì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì´ë¦„ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”.'); return; }

      const now = Date.now();
      await set(roomRef, {
        name: roomId,
        status: 'waiting',
        createdAt: now,
        playerCount: 1,
        players: { [uid]: { role: 0, joinedAt: now } },
        state: initialState()
      });

      // ìƒì„± ì§í›„ì—ë„ 10ê°œ ìœ ì§€
      await pruneRoomsToMax(10);

      onDisconnect(ref(db, `wbaduk/rooms/${roomId}/players/${uid}`)).remove();
      enterRoom(roomId, 0);
    };

    btnJoin.onclick = async () => {
      const roomId = requireRoomName();
      if (!roomId) return;

      const roomRef    = ref(db, `wbaduk/rooms/${roomId}`);
      const playersRef = ref(db, `wbaduk/rooms/${roomId}/players`);
      const stateRef   = ref(db, `wbaduk/rooms/${roomId}/state`);

      // 1) ë°© ì¡´ì¬ í™•ì¸
      const roomSnap = await get(roomRef);
      if (!roomSnap.exists()) {
        alert('í•´ë‹¹ ë°©ì´ ì—†ìŠµë‹ˆë‹¤. ë°© ì´ë¦„ì„ í™•ì¸í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„±í•´ì£¼ì„¸ìš”.');
        return;
      }

      // 2) playersë§Œ íŠ¸ëœì­ì…˜(ì¬ì…ì¥ í—ˆìš©, 2ëª… ì œí•œ)
      let myRole = 1;
      const txn = await runTransaction(playersRef, (players) => {
        players = players || {};
        const ids = Object.keys(players);
        const hasMe = !!players[uid];

        // ê°€ë“ ì°¼ê³ , ë‚´ê°€ ì•„ì§ ì•ˆ ë“¤ì–´ê°„ ê²½ìš° â†’ ì¤‘ë‹¨
        if (!hasMe && ids.length >= 2) return;

        if (hasMe) {
          // ì¬ì…ì¥
          myRole = players[uid].role ?? 1;
          return players;
        }

        // ìƒˆë¡œ ë“¤ì–´ê° â†’ ì—­í•  ë°°ì •
        const rolesTaken = Object.values(players).map(p => p.role);
        myRole = rolesTaken.includes(0) ? 1 : 0;
        players[uid] = { role: myRole, joinedAt: Date.now() };
        return players;
      });

      if (!txn.committed) {
        // ì‹¤ì œ ìƒíƒœë¥¼ í•œ ë²ˆ ë” ë³´ê³  ì •í™•íˆ ì•ˆë‚´
        const after = await get(playersRef);
        const cnt = after.exists() ? Object.keys(after.val()).length : 0;
        if (cnt >= 2 && !(after.val() && after.val()[uid])) {
          alert('ì´ë¯¸ 2ëª…ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë°©ì„ ì´ìš©í•´ ì£¼ì„¸ìš”.');
        } else {
          alert('ì…ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
        }
        return;
      }

      // 3) íŒŒìƒê°’ ê°±ì‹  + state ë³´ì •
      const playersNow = txn.snapshot.val() || {};
      const cntNow = Math.min(2, Object.keys(playersNow).length);
      await update(roomRef, {
        playerCount: cntNow,
        status: cntNow >= 2 ? 'playing' : 'waiting'
      });
      const st = await get(stateRef);
      if (!st.exists()) {
        await set(stateRef, initialState());
      }

      // 4) ì—°ê²° ëŠê¸¸ ë•Œ ìë™ ì œê±°(ë² ìŠ¤íŠ¸ ì—í¬íŠ¸) + ì…ì¥
      onDisconnect(ref(db, `wbaduk/rooms/${roomId}/players/${uid}`)).remove();
      enterRoom(roomId, myRole);
    };

    function enterRoom(roomId, role){
      local.roomId = roomId; local.role = role;

      // ê¸°ì¡´ êµ¬ë… í•´ì œ(ì¬ìƒì„± ë°©ì§€)
      if (unsubRoom)   { unsubRoom();   unsubRoom = null; }
      if (unsubPlayers){ unsubPlayers();unsubPlayers = null; }

      // UI ì „í™˜
      document.getElementById('setup').style.display='none';
      document.getElementById('panel').style.display='flex';
      document.getElementById('turnLine').style.display='block';
      document.getElementById('scores').style.display='block';
      document.getElementById('bottomBar').style.display='flex';

      roomLine.textContent = `ë°©: ${roomId} â€” ë‚˜ëŠ” ${role===0?'P1(ë¹¨ê°•)':'P2(íŒŒë‘)'} ì…ë‹ˆë‹¤.`;

      makeBoard();

      // ë°© ì „ì²´ êµ¬ë…
      unsubRoom = onValue(ref(db, `wbaduk/rooms/${roomId}`), snap => {
        const room = snap.val();
        if (!room) {
          alert('ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.');
          location.reload();
          return;
        }
        if (room.state) applyRemote(room.state);

        // ìƒëŒ€ê°€ ì¢…ë£Œì‹œì¼œì„œ ended ë‚´ë ¤ì˜¤ë©´ ìë™ ì‚­ì œ ì˜ˆì•½
        if (room.state?.phase === 'ended') {
          cleanupRoomAfterEnd(roomId, 1500);
        }

        if (room.status === 'waiting') {
          const t = document.getElementById('turnColor');
          t.textContent = 'ìƒëŒ€ ëŒ€ê¸° ì¤‘â€¦';
          t.style.color = '#777';
        }
      });

      // í”Œë ˆì´ì–´ ìˆ˜ ë³€ë™ ì‹œ íŒŒìƒê°’ ìë™ ì •ë¦¬ (ì‚­ì œ ì˜ˆì•½ ì¤‘ì—ëŠ” ì“°ì§€ ì•ŠìŒ)
      unsubPlayers = onValue(ref(db, `wbaduk/rooms/${roomId}/players`), snap => {
        if (cleanupScheduled) return;
        const cnt = snap.exists() ? Object.keys(snap.val()).length : 0;
        update(ref(db, `wbaduk/rooms/${roomId}`), {
          playerCount: Math.min(2, cnt),
          status: cnt >= 2 ? 'playing' : 'waiting'
        });
      });

      // ë¦¬ì…‹
      resetBtn.onclick = async ()=>{
        await runTransaction(ref(db, `wbaduk/rooms/${roomId}`), room=>{
          if(!room) return room;
          room.status = playerCountOf(room)>=2 ? 'playing' : 'waiting';
          room.state = initialState();
          return room;
        });
      };

      // ì„¤ëª… íŒì—… í•œë²ˆ ë„ìš°ê¸°
      helpOverlay.style.display='flex';
      document.getElementById('helpCloseBtn').onclick = ()=> helpOverlay.style.display='none';
    }

    // íƒ­ ì¢…ë£Œ ì‹œ ìë™ í‡´ì¥(ë² ìŠ¤íŠ¸ ì—í¬íŠ¸)
    window.addEventListener('beforeunload', () => {
      if (local.roomId) remove(ref(db, `wbaduk/rooms/${local.roomId}/players/${uid}`));
    });

    // ë„ì›€ë§ open/close (ì „ì—­)
    function openHelp(){
      const ov = document.getElementById('helpOverlay');
      if (ov) ov.style.display = 'flex';
    }
    function closeHelp(){
      const ov = document.getElementById('helpOverlay');
      if (ov) ov.style.display = 'none';
    }
    // ì „ì—­ ë…¸ì¶œ
    window.openHelp = openHelp;
    window.closeHelp = closeHelp;

    // ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ(ì¤‘ë³µ ë¬´í•´)
    const helpBtnEl = document.getElementById('helpBtn');
    const helpCloseBtnEl = document.getElementById('helpCloseBtn');
    const helpOverlayEl = document.getElementById('helpOverlay');
    if (helpBtnEl) helpBtnEl.addEventListener('click', openHelp);
    if (helpCloseBtnEl) helpCloseBtnEl.addEventListener('click', closeHelp);
    if (helpOverlayEl) {
      helpOverlayEl.addEventListener('click', (e)=>{ if (e.target === helpOverlayEl) closeHelp(); });
    }

    // ìˆ˜ë™ ì¢…ë£Œ ë²„íŠ¼
    endBtn.onclick = async () => {
      if (!local.roomId) return;
      const roomId = local.roomId;

      const ok = confirm('ì •ë§ ê²Œì„ì„ ì¢…ë£Œí•˜ê³  ë°©ì„ ì‚­ì œí• ê¹Œìš”?');
      if (!ok) return;

      try {
        // êµ¬ë… í•´ì œ(ì¬ìƒì„± ë°©ì§€)
        if (unsubRoom)   { unsubRoom();   unsubRoom = null; }
        if (unsubPlayers){ unsubPlayers();unsubPlayers = null; }

        // ë°© ì‚­ì œ
        await remove(ref(db, `wbaduk/rooms/${roomId}`));

        // latestRoomê°€ ì´ ë°©ì´ë©´ ì •ë¦¬(ì˜µì…˜)
        const latestSnap = await get(ref(db, 'wbaduk/latestRoom'));
        if (latestSnap.exists() && latestSnap.val()?.roomCode === roomId) {
          await remove(ref(db, 'wbaduk/latestRoom'));
        }
      } catch (e) {
        alert('ë°© ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        console.error(e);
      } finally {
        location.reload();
      }
    };

    // ğŸ”’ ì¤‘ë³µ ë°© ì‚­ì œ ë°©ì§€ìš© í”Œë˜ê·¸
    let cleanupScheduled = false;

    // âœ… ì¢…ë£Œ í›„ ë°© ìë™ ì‚­ì œ(+ë ˆì´ìŠ¤ ë°©ì§€)
    async function cleanupRoomAfterEnd(roomId, delay = 2500) {
      if (!roomId || cleanupScheduled) return;
      cleanupScheduled = true;

      setTimeout(async () => {
        try {
          // êµ¬ë… í•´ì œ(ì¬ìƒì„± ë°©ì§€)
          if (unsubRoom)   { unsubRoom();   unsubRoom = null; }
          if (unsubPlayers){ unsubPlayers();unsubPlayers = null; }

          // í•œ í´ë¼ì´ì–¸íŠ¸ë§Œ ì •ë¦¬í•˜ë„ë¡ ì ê¸ˆ
          const lockRef = ref(db, `wbaduk/rooms/${roomId}/__cleanupLock`);
          const res = await runTransaction(lockRef, v => v || uid);
          if (!res.committed || res.snapshot.val() !== uid) {
            return; // ë‹¤ë¥¸ ìª½ì´ ì •ë¦¬í•¨
          }

          // ë°© ì‚­ì œ
          await remove(ref(db, `wbaduk/rooms/${roomId}`));

          // (ì˜µì…˜) latestRoomê°€ ê°€ë¦¬í‚¤ë©´ ì •ë¦¬
          const latestSnap = await get(ref(db, 'wbaduk/latestRoom'));
          if (latestSnap.exists() && latestSnap.val()?.roomCode === roomId) {
            await remove(ref(db, 'wbaduk/latestRoom'));
          }
        } catch (e) {
          console.error('ë°© ìë™ ì‚­ì œ ì¤‘ ì˜¤ë¥˜:', e);
        } finally {
          location.reload();
        }
      }, delay);
    }
  </script>
</body>
</html>
