<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Wall-baduk (온라인 2인 · 7x7)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>

  <style>
    :root{
      --bar-h: 56px;
      /* 점(포인트) 한 칸의 변 길이 */
      --pt: clamp(28px, 7.2vw, 46px);
      /* 벽/교차칸 두께(비율 유지) */
      --gap: calc(var(--pt) * 0.357);
    }
    @media (orientation: landscape){
      :root{ --pt: clamp(22px, 4.6vh, 44px); }
    }

    body{
      font-family:sans-serif; background:#f5f5f5; text-align:center; margin:0; min-height:100vh;
      display:grid; grid-template-rows:auto auto auto auto auto;
    }
    h1{ margin:6px 0 2px; font-size:clamp(20px,5.6vw,34px); }

    /* 매칭 섹션 */
    #setup{ margin:6px 0 2px; }
    #setup button{
      width:min(46vw,180px);
      padding:12px 14px; margin:4px; border-radius:10px; border:1px solid #999; background:#fff; cursor:pointer;
    }
    #roomLine{ font-size:13px; color:#555; margin:2px 0 2px; }

    /* 상단 정보 */
    #turnLine{ margin:2px 0; font-size:clamp(14px,3.6vw,16px); }
    #scores  { margin:0 0 2px; font-size:clamp(13px,3.2vw,15px); }

    /* 보드 래퍼 */
    #wrap{ display:flex; justify-content:center; align-items:flex-start; padding:2px 8px 6px; overflow:auto; }
    #board{
      display:grid; background:#fff; border:2px solid #333; user-select:none; touch-action:manipulation;
      max-width:100vw;
    }

    /* 셀 */
    .cell{ box-sizing:border-box; border:1px solid #000; display:flex; align-items:center; justify-content:center; }
    .point{ width:var(--pt); height:var(--pt); background:#fff; position:relative; cursor:pointer; transition:background .1s; }
    .piece{ width:80%; height:80%; border-radius:50%; pointer-events:none; }
    .h-wall{ width:var(--pt);  height:var(--gap); background:#fff; cursor:pointer; }
    .v-wall{ width:var(--gap); height:var(--pt);  background:#fff; cursor:pointer; }
    .blank { width:var(--gap); height:var(--gap); background:#15326b; }

    .movable{ background:#d0d0d0 !important; }
    .final-p1-region{ background:#ffd6e7 !important; }
    .final-p2-region{ background:#d6ecff !important; }

    /* 게임 패널 */
    #panel{ margin:4px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    #panel button{ padding:10px 14px; border:1px solid #999; border-radius:10px; background:#fff; cursor:pointer; }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    /* 하단 고정 바 (노치 안전영역 고려) */
    #bottomBar{
      position:sticky; bottom:0; left:0; right:0;
      background:#ffffffcc; backdrop-filter:blur(6px);
      border-top:1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center;
      padding:6px 12px calc(6px + env(safe-area-inset-bottom));
    }
    #skipWallBtn{
      width:min(360px, 94vw); height:44px; border-radius:12px; font-weight:700;
      background:#ffd6e7; border:1px solid #e7a3bd;
    }

    /* 도움말 모달 */
    #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:9999; padding:16px; }
    #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
    #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
    #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
    #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
    #helpBody ul ul { margin-left:6px; padding-left:10px; }
    #helpBody li { margin:4px 0; }
    #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
    .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }
  </style>
</head>
<body>
  <h1>Wall-baduk (벽바둑)</h1>

  <!-- 방 생성/참여 -->
  <div id="setup">
    <button id="btnCreate">방 생성하기</button>
    <button id="btnJoin">방 참여하기</button>
    <div id="roomLine">대기 중…</div>
  </div>

  <!-- 게임 패널 -->
  <div id="panel" style="display:none">
    <button id="resetBtn">새로 시작</button>
    <button id="helpBtn">도움말</button>
  </div>
  <div id="turnLine" style="display:none">현재 턴: <span id="turnColor"></span></div>
  <div id="scores"   style="display:none">P1(빨강): <span id="s1">0</span> / P2(파랑): <span id="s2">0</span></div>

  <div id="wrap"><div id="board"></div></div>

  <div id="bottomBar" style="display:none">
    <button id="skipWallBtn" disabled>이동 없이 벽 설치</button>
  </div>

  <!-- 설명 팝업 -->
  <div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div id="helpCard">
      <div id="helpHeader"><span id="helpTitle">게임 설명</span></div>
      <div id="helpBody">
        <ul>
          <li><strong>목표</strong>: 벽으로 보드를 나눠 <strong>한쪽만 포함된 구역</strong>을 많이 만들기.</li>
          <li><strong>턴 진행</strong>: 내 말 하나 선택 → <strong>이동</strong>(또는 생략) → <strong>벽 1개 설치</strong> → 상대 턴.</li>
          <li><strong>이동 규칙</strong>:
            <ul>
              <li>상하좌우 <strong>1칸</strong> 또는 <strong>1칸+1칸</strong>(직각 가능).</li>
              <li><strong>벽 통과 불가</strong>, 도착 칸에 말 있으면 불가.</li>
              <li>이동 가능 칸은 <strong>짙은 회색</strong>으로 표시.</li>
              <li>갈 곳이 없으면 <strong>이동 없이 바로 벽 설치</strong>.</li>
            </ul>
          </li>
          <li><strong>벽 설치</strong>: 빈 가로/세로 벽 칸에 <strong>1개</strong> 설치, <strong>제거 불가</strong>.</li>
          <li><strong>구역 판단</strong>:
            <ul>
              <li>벽 없이 이어진 점들의 집합 = <strong>구역</strong>.</li>
              <li><strong>한 플레이어의 말만</strong> 있는 구역만 그 플레이어 소유.</li>
              <li>두 플레이어 말이 함께 있으면 <strong>무주지</strong>.</li>
            </ul>
          </li>
          <li><strong>종료 & 승리</strong>: 모든 구역에서 <strong>혼재 구역이 사라지면</strong> 즉시 종료 → 각자 <strong>소유 구역의 점 개수 합</strong> 비교로 승리 결정.</li>
        </ul>
      </div>
      <div id="helpFooter">
        <button class="helpBtn" id="helpCloseBtn">시작하기</button>
      </div>
    </div>
  </div>

  <!-- 앱 스크립트 -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getDatabase, ref, get, set, onValue, runTransaction, onDisconnect } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.appspot.com",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:8cc90ab5a17c364b91a561"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    /* ---- 서버 시간(offset) 동기화 ---- */
    let serverOffset = 0;
    onValue(ref(db, '.info/serverTimeOffset'), s => {
      serverOffset = s.val() || 0;
    });
    const serverNow = () => Date.now() + serverOffset;

    /* ---- 방 이름/유저 ID ---- */
    const uid = (() => {
      const key='wb_uid_tab'; let v=sessionStorage.getItem(key);
      if(!v){ v=(crypto.randomUUID?.()||('u_'+Math.random().toString(36).slice(2))); sessionStorage.setItem(key,v); }
      return v;
    })();
    function randomRoomName(){
      const animals=['부엉이','호랑이','고래','곰','여우','사자','토끼','수달','펭귄','판다'];
      const num = Math.floor(1000 + Math.random()*9000);
      return animals[Math.floor(Math.random()*animals.length)] + num; // 예: 부엉이1929
    }

    /* ---- 보드/상태 ---- */
    const BOARD_POINTS = 7;
    const GRID = BOARD_POINTS*2-1;
    const COLORS = ['#e74c3c','#3498db'];

    const boardEl = document.getElementById('board');
    const roomLine= document.getElementById('roomLine');
    const resetBtn= document.getElementById('resetBtn');
    const helpBtn = document.getElementById('helpBtn');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpCloseBtn = document.getElementById('helpCloseBtn');
    const skipWallBtn = document.getElementById('skipWallBtn');
    const turnEl  = document.getElementById('turnColor');
    const s1El    = document.getElementById('s1');
    const s2El    = document.getElementById('s2');

    let grid = [];
    let local = { roomId:null, role:0, state:null, selected:null };

    /* ---- RTDB 배열 정규화 ---- */
    const asArray = (x) => Array.isArray(x) ? x : (x && typeof x==='object') ? Object.values(x) : [];
    function normalizeState(s){
      if(!s) return s;
      s.walls = asArray(s.walls);
      if(!s.pieces) s.pieces = {"0":[], "1":[]};
      s.pieces["0"] = asArray(s.pieces["0"]);
      s.pieces["1"] = asArray(s.pieces["1"]);
      s.extraOrder  = asArray(s.extraOrder || [0,1,1,0]);
      return s;
    }

    /* ---- 보드 생성 ---- */
    function makeBoard(){
      boardEl.innerHTML='';
      boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
      boardEl.style.gridTemplateRows    = `repeat(${GRID}, auto)`;
      grid = Array.from({length:GRID},()=>Array(GRID).fill(null));
      for(let r=0;r<GRID;r++){
        for(let c=0;c<GRID;c++){
          const cell=document.createElement('div'); cell.classList.add('cell');
          if(r%2===0&&c%2===0){ cell.classList.add('point'); cell.addEventListener('click',()=>onPointClick(r,c)); }
          else if(r%2===1&&c%2===0){ cell.classList.add('h-wall'); cell.addEventListener('click',()=>onWallClick(r,c)); }
          else if(r%2===0&&c%2===1){ cell.classList.add('v-wall'); cell.addEventListener('click',()=>onWallClick(r,c)); }
          else { cell.classList.add('blank'); }
          boardEl.appendChild(cell); grid[r][c]=cell;
        }
      }
    }

    function pt(p){ return (p-1)*2; }
    function initialState(){
      return {
        phase:'place-extra', current:0, extraOrder:[0,1,1,0], extraIdx:0,
        pieces:{ "0":[{r:pt(2),c:pt(2)},{r:pt(6),c:pt(6)}], "1":[{r:pt(6),c:pt(2)},{r:pt(2),c:pt(6)}] },
        walls:[]
      };
    }

    function renderFromState(){
      const s = normalizeState(local.state);
      if(!s) return;

      turnEl.textContent = `Player ${s.current+1}`;
      turnEl.style.color = COLORS[s.current];
      skipWallBtn.disabled = (s.phase!=='move') || (s.current!==local.role);

      // 말 다시 그림
      document.querySelectorAll('.piece').forEach(el=>el.remove());
      for(const pid of [0,1]){
        for(const p of asArray(s.pieces[String(pid)])){
          const cell=grid[p.r][p.c]; if(!cell) continue;
          const dot=document.createElement('div');
          dot.classList.add('piece'); dot.style.background=COLORS[pid]; dot.dataset.player=String(pid);
          cell.appendChild(dot);
        }
      }
      // 벽 초기화 후 칠하기
      for(let r=0;r<GRID;r++){ for(let c=0;c<GRID;c++){
        const cell=grid[r][c]; if(!cell) continue;
        if(cell.classList.contains('h-wall')||cell.classList.contains('v-wall')){
          cell.classList.remove('placed'); cell.style.background='#fff';
        }
      }}      
      for(const w of asArray(s.walls)){
        const cell=grid[w.r]?.[w.c]; if(cell){ cell.classList.add('placed'); cell.style.background=COLORS[w.owner]; }
      }
      updateScoresLocal();
    }

    /* ---- 도움말 ---- */
    function openHelp(){ helpOverlay.style.display='flex'; }
    function closeHelp(){ helpOverlay.style.display='none'; }
    helpBtn.addEventListener('click', openHelp);
    helpCloseBtn.addEventListener('click', closeHelp);
    helpOverlay.addEventListener('click', e=>{ if(e.target===helpOverlay) closeHelp(); });

    /* ---- 이동/점수 유틸 ---- */
    function inBounds(r,c){ return r>=0&&r<GRID&&c>=0&&c<GRID; }
    function isPoint(r,c){ return (r%2===0)&&(c%2===0); }
    function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }
    function neighborsReachable(r,c){
      const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
      for(const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
        const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
        if(!isWallPos) continue; if(wall.classList.contains('placed')) continue;
        if(grid[nr][nc].querySelector('.piece')) continue; out.push({nr,nc});
      } return out;
    }
    function markMovable(sr,sc,mark=true){
      const v=Array.from({length:GRID},()=>Array(GRID).fill(false)); const q=[]; v[sr][sc]=true; q.push({r:sr,c:sc,d:0}); let cnt=0;
      while(q.length){ const {r,c,d}=q.shift();
        if(d>0&&d<=2&&isPoint(r,c)&&!grid[r][c].querySelector('.piece')){ if(mark) grid[r][c].classList.add('movable'); cnt++; }
        if(d===2) continue; for(const {nr,nc} of neighborsReachable(r,c)){ if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); } }
      } return cnt;
    }
    function showMovableFrom(sr,sc){ clearMovable(); return markMovable(sr,sc,true); }

    function neighborsByWall(r,c){
      const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
      for(const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
        const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
        const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
        if(!isWallPos) continue; if(wall.classList.contains('placed')) continue; out.push({nr,nc});
      } return out;
    }
    function computeRegionsLocal(){
      const visited=Array.from({length:GRID},()=>Array(GRID).fill(false)); const regions=[]; let hasMixed=false;
      for(let r=0;r<GRID;r+=2){ for(let c=0;c<GRID;c+=2){
        if(visited[r][c]) continue; const q=[{r,c}]; visited[r][c]=true; const pts=[]; const present=new Set();
        while(q.length){ const cur=q.shift(); pts.push(cur);
          const piece=grid[cur.r][cur.c].querySelector('.piece'); if(piece) present.add(+piece.dataset.player);
          for(const {nr,nc} of neighborsByWall(cur.r,cur.c)){ if(!visited[nr][nc]){ visited[nr][nc]=true; q.push({r:nr,c:nc}); } }
        }
        if(present.size>=2) hasMixed=true; regions.push({points:pts, players:present});
      }} return {regions, hasMixed};
    }
    function checkGameEndAndScoreLocal(){
      const {regions,hasMixed}=computeRegionsLocal(); const sc=[0,0];
      for(const reg of regions){ if(reg.players.size===1){ const owner=[...reg.players][0]; sc[owner]+=reg.points.length; } }
      s1El.textContent=sc[0]; s2El.textContent=sc[1]; return !hasMixed;
    }
    function updateScoresLocal(){ const end=checkGameEndAndScoreLocal(); if(end && local.state?.phase!=='ended'){ showWinnerWithPaintLocal(); } }
    function fillFinalRegionsLocal(){
      const {regions}=computeRegionsLocal();
      for(const reg of regions){ if(reg.players.size!==1) continue; const owner=[...reg.players][0];
        for(const {r,c} of reg.points){ grid[r][c].classList.remove('movable'); (owner===0?grid[r][c].classList.add('final-p1-region'):grid[r][c].classList.add('final-p2-region')); }
      }
    }
    function showWinnerWithPaintLocal(){
      fillFinalRegionsLocal();
      const p1=+s1El.textContent, p2=+s2El.textContent;
      alert(`게임 종료!\nP1(빨강): ${p1} / P2(파랑): ${p2}\n`+(p1>p2?'승자: P1(빨강)':p2>p1?'승자: P2(파랑)':'무승부'));
      if(local.state){ local.state.phase='ended'; commitState(); }
    }
    function isMyTurn(){ return local.state && normalizeState(local.state).current===local.role; }

    /* ---- 입력 처리 ---- */
    function onPointClick(r,c){
      local.state = normalizeState(local.state);
      const s=local.state; if(!s) return;

      if(s.phase==='place-extra'){
        if(!isMyTurn()) return;
        const cell=grid[r][c]; if(cell.querySelector('.piece')) return;
        s.pieces[String(s.current)].push({r,c}); s.extraIdx++;
        if(s.extraIdx>=s.extraOrder.length){ s.phase='move'; } else { s.current=s.extraOrder[s.extraIdx]; }
        commitState(); return;
      }

      if(s.phase==='move'){
        if(!isMyTurn()) return;
        const cell=grid[r][c]; const piece=cell.querySelector('.piece');
        if(local.selected && local.selected.r===r && local.selected.c===c){ local.selected=null; clearMovable(); return; }
        if(!local.selected && piece && +piece.dataset.player===local.role){
          local.selected={r,c}; const cnt=showMovableFrom(r,c); if(cnt===0){ local.selected=null; clearMovable(); } return;
        }
        if(local.selected && cell.classList.contains('movable')){
          const arr=s.pieces[String(local.role)]; const idx=arr.findIndex(p=>p.r===local.selected.r&&p.c===local.selected.c);
          if(idx>=0){ arr[idx]={r,c}; s.phase='wall'; clearMovable(); local.selected=null; commitState(); }
        }
      }
    }
    function onWallClick(r,c){
      local.state = normalizeState(local.state);
      const s=local.state; if(!s||s.phase!=='wall'||!isMyTurn()) return;
      const cell=grid[r][c]; const isWall=cell.classList.contains('h-wall')||cell.classList.contains('v-wall');
      if(!isWall||cell.classList.contains('placed')) return;
      s.walls.push({r,c,owner:local.role});
      const end=checkGameEndAndScoreLocal(); if(end){ s.phase='ended'; commitState(); showWinnerWithPaintLocal(); return; }
      s.current=1-s.current; s.phase='move'; commitState();
    }
    skipWallBtn.addEventListener('click',()=>{
      local.state = normalizeState(local.state);
      const s=local.state; if(!s||s.phase!=='move'||!isMyTurn()) return; clearMovable(); local.selected=null; s.phase='wall'; commitState();
    });

    /* ---- DB 동기화 ---- */
    async function commitState(){
      if(!local.roomId||!local.state) return;
      await set(ref(db, `wbaduk/rooms/${local.roomId}/state`), local.state);
    }
    function applyRemote(state){
      local.state = normalizeState(state);
      renderFromState();
    }

    /* ---- 방 생성/참여 ---- */
    const btnCreate=document.getElementById('btnCreate');
    const btnJoin  =document.getElementById('btnJoin');

    btnCreate.onclick = async ()=>{
      const latestRef = ref(db, 'wbaduk/latestRoom');
      const latestSnap= await get(latestRef);
      const now = serverNow(); // 서버 기준

      if(latestSnap.exists() && now - (latestSnap.val().createdAt||0) < 60_000){
        alert('1분 내 생성된 대기방이 있어요. [방 참여하기]로 들어가세요.');
        return;
      }

      const roomId = randomRoomName();
      const roomRef= ref(db, `wbaduk/rooms/${roomId}`);
      await set(roomRef, {
        name: roomId,
        status: 'waiting',
        createdAt: now,
        playerCount: 1,
        players: { [uid]: { role: 0, joinedAt: now } },
        state: initialState()
      });
      onDisconnect(ref(db, `wbaduk/rooms/${roomId}/players/${uid}`)).remove();
      await set(latestRef, { roomCode: roomId, createdAt: now });

      enterRoom(roomId, 0);
    };

   btnJoin.onclick = async () => {
  // 0) 들어갈 수 있는 방 고르기 (latestRoom → 전체 대기방 스캔)
  const pick = await pickJoinableRoom();
  if (!pick) {
    alert('지금 들어갈 수 있는 대기방이 없습니다. 방을 새로 만들어 주세요.');
    return;
  }
  const roomId = pick.id;
  const roomRef = ref(db, `wbaduk/rooms/${roomId}`);

  // 1) 트랜잭션으로 입장 (동시경쟁 대비 3회 재시도)
  let tries = 0;
  let myRole = 1;

  while (tries < 3) {
    const tx = await runTransaction(roomRef, room => {
      if (!room) return; // 방이 삭제됨 → abort

      const now = serverNow();
      const players = room.players || {};

      // 내가 이미 들어간 방이면 역할 유지하고 그대로 통과
      if (players[uid]) {
        myRole = players[uid].role ?? 0;
        room.playerCount = Math.min(2, new Set(Object.keys(players)).size);
        room.status = room.playerCount === 2 ? 'playing' : 'waiting';
        if (!room.state) room.state = initialState();
        return room;
      }

      // 현재 실제 인원 수
      const currentCount = Math.min(2, new Set(Object.keys(players)).size);
      if (currentCount >= 2) return; // 가득 참 → abort (committed=false)

      // 빈 역할 배정
      const rolesTaken = Object.values(players).map(p => p.role);
      myRole = rolesTaken.includes(0) ? 1 : 0;

      players[uid] = { role: myRole, joinedAt: now };
      room.players = players;
      room.playerCount = Math.min(2, new Set(Object.keys(players)).size);
      if (room.playerCount === 2) room.status = 'playing';
      if (!room.state) room.state = initialState();

      return room;
    });

    if (tx.committed) {
      // 참여 성공
      onDisconnect(ref(db, `wbaduk/rooms/${roomId}/players/${uid}`)).remove();
      enterRoom(roomId, myRole);
      return;
    }

    // 2) 충돌 → 잠시 대기 후 재시도
    tries++;
    await new Promise(r => setTimeout(r, 150 + Math.random() * 200));
  }

  alert('입장 경쟁에 밀렸어요. [방 참여하기]를 다시 눌러보세요.');
};


    function enterRoom(roomId, role){
      local.roomId = roomId; local.role = role;

      // UI 전환
      document.getElementById('setup').style.display='none';
      document.getElementById('panel').style.display='flex';
      document.getElementById('turnLine').style.display='block';
      document.getElementById('scores').style.display='block';
      document.getElementById('bottomBar').style.display='flex';

      roomLine.textContent = `방: ${roomId} — 나는 ${role===0?'P1(빨강)':'P2(파랑)'} 입니다.`;

      makeBoard();

      onValue(ref(db, `wbaduk/rooms/${roomId}`), snap=>{
        const room=snap.val(); if(!room) return;

        if (room.status === 'waiting') {
          // 대기 안내를 친절하게
          turnEl.textContent = '⏳ 매칭 대기 중 — 상대가 입장하면 자동 시작됩니다';
          turnEl.style.color = '#666';
          skipWallBtn.disabled = true;
          return;
        }

        if(room.state) applyRemote(room.state);
      });

      // 리셋: 같은 방에서 새 게임 시작
      resetBtn.onclick = async ()=>{
        await runTransaction(ref(db, `wbaduk/rooms/${roomId}`), room=>{
          if(!room) return room;
          room.status = room.playerCount>=2 ? 'playing' : 'waiting';
          room.state = initialState();
          return room;
        });
      };

      openHelp(); // 처음에 도움말
    }
  </script>
</body>
</html>
