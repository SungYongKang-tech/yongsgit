<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>장기 게임 (온라인 2인)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root{
      --cell-size:56px;
      --board-width:calc(var(--cell-size)*8);
      --board-height:calc(var(--cell-size)*9);
      --border-color:#3a2a1a;
      --board-bg:#e4c59a;
      --piece-scale:1.3;
      --dot-size:16px;
    }
    *{box-sizing:border-box}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;
      display:flex;justify-content:center;align-items:center;flex-direction:column;
      background:#f0e6d2;margin:0;padding:16px;min-height:100dvh;
    }
    h1{margin:8px 0 6px;font-size:clamp(18px,4.5vw,28px);color:#333}
    .topline{font-size:14px;margin:4px 0 10px;color:#444;text-align:center}

    .bar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center; margin:6px 0 8px; font-size:14px; color:#374151;}
    .msg { min-height:22px; font-weight:700; color:#b00020; text-align:center; }

    #janggi-board-container{
      position:relative;
      width:calc(var(--board-width)+var(--cell-size));
      height:calc(var(--board-height)+var(--cell-size));
      max-width:100vw;
      max-height:calc(100dvh - 190px);
      background:var(--board-bg);
      border:2px solid var(--border-color);
      padding:calc(var(--cell-size)/2);
      overflow:hidden;
    }
    #janggi-board{
      position:relative;
      width:var(--board-width);
      height:var(--board-height);
      background-image:
        repeating-linear-gradient(to right,
          transparent, transparent calc(var(--cell-size) - 1px),
          var(--border-color) calc(var(--cell-size) - 1px),
          var(--border-color) var(--cell-size)),
        repeating-linear-gradient(to bottom,
          transparent, transparent calc(var(--cell-size) - 1px),
          var(--border-color) calc(var(--cell-size) - 1px),
          var(--border-color) var(--cell-size));
      background-size:var(--cell-size) var(--cell-size);
      border:1px solid var(--border-color);
    }
    #palace-overlay{position:absolute;inset:0;pointer-events:none;z-index:1}
    #pieces-layer{position:absolute;inset:0;z-index:2}
    #moves-layer{position:absolute;inset:0;pointer-events:none;z-index:3}
    .move-dot{ pointer-events:auto; }

    .piece{
      position:absolute;
      width:calc(var(--cell-size) * var(--piece-scale));
      height:calc(var(--cell-size) * var(--piece-scale));
      left:calc(var(--col) * 100% / 8);
      top:calc(var(--row) * 100% / 9);
      transform:translate(-50%, -50%);
      background-size:contain;background-repeat:no-repeat;background-position:center;
      border-radius:50%;
      cursor:pointer;
      transition:box-shadow .15s ease, transform .15s ease;
    }
    .piece.selected{ box-shadow:0 0 12px 4px rgba(255,0,0,.55) }

    .move-dot{
      position:absolute; width:var(--dot-size); height:var(--dot-size);
      left:calc(var(--col) * 100% / 8); top:calc(var(--row) * 100% / 9);
      transform:translate(-50%, -50%); border-radius:50%;
      background:rgba(0,0,0,.15); border:2px solid rgba(0,0,0,.35); cursor:pointer;
    }

    .row{display:flex; gap:12px; align-items:center; justify-content:center; margin:4px 0 10px; font-size:14px;}
    label { user-select:none; }

    .banner{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      pointer-events:none; z-index:4;
      font-weight:900; letter-spacing:2px; text-shadow:0 2px 6px rgba(0,0,0,.25);
      font-size:clamp(28px, 8vw, 96px); opacity:0; transition:opacity .3s ease;
    }
    .banner.show{ opacity:.9; }
    .banner.cho{ color:#1e64ff; }
    .banner.han{ color:#e53935; }

    #result-overlay{
      position:absolute; inset:0; z-index:6; background:rgba(0,0,0,.66); display:none;
      align-items:center; justify-content:center;
    }
    #result-text{
      color:#fff; font-size:clamp(36px, 12vw, 120px); font-weight:900;
      text-shadow:0 4px 18px rgba(0,0,0,.65);
    }
  </style>
</head>
<body>
  <h1>장기 게임 (온라인)</h1>
  <div class="topline" id="roomInfo">방 정보 불러오는 중…</div>

  <div class="bar" id="setupInfo">초 배치 / 한 배치 불러오는 중…</div>

  <div class="row"><span class="msg" id="statusMsg"></span></div>

  <div id="janggi-board-container">
    <div id="janggi-board">
      <svg id="palace-overlay" width="100%" height="100%"></svg>
      <div id="pieces-layer"></div>
      <div id="moves-layer"></div>
      <div id="turn-banner" class="banner"></div>
      <div id="result-overlay"><div id="result-text"></div></div>
    </div>
  </div>

  <audio id="moveSnd" src="button-29.mp3" preload="auto"></audio>
  <audio id="capSnd"  src="button2.mp3"  preload="auto"></audio>

  <script type="module">
    /* ================= Firebase ================= */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getDatabase, ref, get, set, runTransaction, onValue, update, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

    let endedFlag = false;

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.firebasestorage.app",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:dfe39687717f28b891a561"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);
    const auth = getAuth(app);

    async function ensureAnon(){
      if (auth.currentUser) return auth.currentUser;
      return new Promise((resolve,reject)=>{
        const unsub = onAuthStateChanged(auth, u=>{ if(u){unsub(); resolve(u);} });
        signInAnonymously(auth).catch(reject);
      });
    }
    await ensureAnon();

    /* ================ URL 파라미터 / 방 진입 ================ */
    const params = new URLSearchParams(location.search);
    const roomId = params.get('room');
    if (!roomId){ alert('room 파라미터가 없습니다.'); location.href='index.html'; }

    // ★ 전용 네임스페이스: 규칙과 일치
    const NS = 'janggiRooms';

    const roomRef    = ref(db, `${NS}/${roomId}`);
    const playersRef = ref(db, `${NS}/${roomId}/players`);
    const stateRef   = ref(db, `${NS}/${roomId}/state`);

    const roomInfo  = document.getElementById('roomInfo');
    const setupInfo = document.getElementById('setupInfo');

    let myRole = null;  // 0=초, 1=한
    let myTeam = null;  // 'cho' | 'han'
    let gameOver = false;
    let lastPly = 0;
    let roomSettings = { choPattern:'마상마상', hanPattern:'마상마상', firstTurn:'cho', creatorRole:0 };

    const roleToTeam = (r)=> r===0 ? 'cho' : 'han';
    const opp        = (t)=> t==='cho' ? 'han' : 'cho';

    async function enterRoom(){
      const uid = auth.currentUser.uid;

      // 플레이어 등록(없으면 자동 배정)
      let assigned = 0;
      const txn = await runTransaction(playersRef, (players)=>{
        players = players || {};
        if (players[uid]) return players;
        const ids = Object.keys(players);
        if (ids.length >= 2) return; // full
        const taken = Object.values(players).map(p=>p.role);
        assigned = taken.includes(0) ? 1 : 0;
        players[uid] = { role: assigned, joinedAt: Date.now() };
        return players;
      });

      if (!txn.committed){
        alert('이미 2명이 있습니다. 다른 방을 이용해 주세요.');
        location.href='index.html';
        return;
      }

      const cur = txn.snapshot.val()||{};
      myRole = cur[auth.currentUser.uid].role;
      myTeam = roleToTeam(myRole);

      // 방 설정 읽기
      const rs = await get(roomRef);
      const rv = rs.val()||{};
      roomSettings = rv.settings || roomSettings;

      // 상태 업데이트 (대기/플레이)
      const cnt = Math.min(2, Object.keys(cur).length);
      await update(roomRef, { playerCount: cnt, status: (cnt>=2?'playing':'waiting') });

      onDisconnect(ref(db, `${NS}/${roomId}/players/${uid}`)).remove();

      roomInfo.innerHTML = `방: <b>${roomId}</b> — 나는 <b>${myTeam==='cho'?'초':'한'}</b>입니다.`;
      setupInfo.textContent = `초 배치: ${roomSettings.choPattern} · 한 배치: ${roomSettings.hanPattern}`;
    }

    await enterRoom();

    /* ================== 장기 로직 (시점 반전 포함) ================== */
    const boardEl   = document.getElementById('janggi-board');
    const overlay   = document.getElementById('palace-overlay');
    const piecesLay = document.getElementById('pieces-layer');
    const movesLay  = document.getElementById('moves-layer');
    const statusMsg = document.getElementById('statusMsg');

    const moveSnd = document.getElementById('moveSnd');
    const capSnd  = document.getElementById('capSnd');
    const playMove=()=>{ try{ moveSnd.currentTime=0; moveSnd.play().catch(()=>{});}catch{} }
    const playCap =()=>{ try{ capSnd.currentTime=0;  capSnd.play().catch(()=>{});}catch{} }

    const bannerEl   = document.getElementById('turn-banner');
    const resultOv   = document.getElementById('result-overlay');
    const resultText = document.getElementById('result-text');
    let bannerTimer = null;

    function showTurnBanner(team){
      bannerEl.className = 'banner ' + (team==='cho' ? 'cho' : 'han');
      bannerEl.textContent = team==='cho' ? '초 차례' : '한 차례';
      bannerEl.classList.add('show');
      clearTimeout(bannerTimer);
      bannerTimer = setTimeout(()=> bannerEl.classList.remove('show'), 900);
    }
    function showResult(winnerTeam){
      gameOver = true;
      resultText.textContent = (winnerTeam==='cho' ? '초 승' : '한 승');
      resultOv.style.display = 'flex';
    }

    // === 좌표/보드 유틸 ===
    const getCellSize = () =>
      parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
    const inside = (r,c)=> r>=0 && r<=9 && c>=0 && c<=8;
    const key = (r,c)=> `${r},${c}`;

    // 시점 변환: 내가 초면 180도 회전한 좌표로 렌더
    const toViewRC   = (r,c)=> (myTeam === 'cho') ? [9 - r, 8 - c] : [r, c];
    const fromViewRC = (vr,vc)=> (myTeam === 'cho') ? [9 - vr, 8 - vc] : [vr, vc];

    // … (중략: 장기 규칙/이동 로직은 그대로) …
    // ↓↓↓ 원본에서 주신 로직을 그대로 유지합니다 (모두 동일) ↓↓↓

    const palaceTop    = new Set(['0,3','0,4','0,5','1,3','1,4','1,5','2,3','2,4','2,5']);
    const palaceBottom = new Set(['7,3','7,4','7,5','8,3','8,4','8,5','9,3','9,4','9,5']);
    const inPalace = (r,c)=> palaceTop.has(key(r,c)) || palaceBottom.has(key(r,c));
    const palaceKind = (r,c)=> palaceTop.has(key(r,c)) ? 'top' : (palaceBottom.has(key(r,c))?'bottom':null);
    const palaceDiagNeighbors = {
      '1,4': [['0,3'],['0,5'],['2,3'],['2,5']],
      '0,3': [['1,4']], '0,5': [['1,4']], '2,3': [['1,4']], '2,5': [['1,4']],
      '8,4': [['7,3'],['7,5'],['9,3'],['9,5']],
      '7,3': [['8,4']], '7,5': [['8,4']], '9,3': [['8,4']], '9,5': [['8,4']]
    };
    const topCorners = ['0,3','0,5','2,3','2,5'];      const topCenter = '1,4';
    const botCorners = ['7,3','7,5','9,3','9,5'];      const botCenter = '8,4';
    const diagNeighbors = (r,c)=> (palaceDiagNeighbors[key(r,c)]||[]).map(([s])=>s.split(',').map(Number));
    const oppositeCorner = (r,c)=>{
      const s = key(r,c);
      if (topCorners.includes(s)){
        if (s==='0,3') return [2,5];
        if (s==='2,5') return [0,3];
        if (s==='0,5') return [2,3];
        if (s==='2,3') return [0,5];
      }
      if (botCorners.includes(s)){
        if (s==='7,3') return [9,5];
        if (s==='9,5') return [7,3];
        if (s==='7,5') return [9,3];
        if (s==='9,3') return [7,5];
      }
      return null;
    };

    function updateCellSize(){
      const titleH = (document.querySelector('h1')?.offsetHeight || 0)
                   + (document.querySelector('.topline')?.offsetHeight || 0)
                   + (document.querySelector('.bar')?.offsetHeight || 0)
                   + (document.querySelector('.row')?.offsetHeight || 0);
      const pad = 16*2, extraH = titleH + 28;
      const maxCellByW = (window.innerWidth - pad) / 9;
      const maxCellByH = (window.innerHeight - pad - extraH) / 10;
      const cell = Math.floor(Math.max(32, Math.min(maxCellByW, maxCellByH)));
      document.documentElement.style.setProperty('--cell-size', cell + 'px');
    }

    function drawPalaceLines(){
      const CELL = getCellSize();
      const W = 8 * CELL, H = 9 * CELL;
      const overlayEl = document.getElementById('palace-overlay');
      overlayEl.setAttribute('viewBox', `0 0 ${W} ${H}`);
      while(overlayEl.firstChild) overlayEl.removeChild(overlayEl.firstChild);
      const strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim() || '#3a2a1a';
      const mk = (x1,y1,x2,y2)=>{
        const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
        ln.setAttribute('x1',x1); ln.setAttribute('y1',y1);
        ln.setAttribute('x2',x2); ln.setAttribute('y2',y2);
        ln.setAttribute('stroke',strokeColor);
        ln.setAttribute('stroke-width',1);
        ln.setAttribute('stroke-opacity',0.8);
        ln.setAttribute('shape-rendering','crispEdges');
        return ln;
      };
      overlayEl.appendChild(mk(3*CELL,0*CELL,5*CELL,2*CELL));
      overlayEl.appendChild(mk(5*CELL,0*CELL,3*CELL,2*CELL));
      overlayEl.appendChild(mk(3*CELL,7*CELL,5*CELL,9*CELL));
      overlayEl.appendChild(mk(5*CELL,7*CELL,3*CELL,9*CELL));
    }

    function makeInitialSetup(pCho='마상마상', pHan='마상마상'){
      const map = {
        '마상마상': ['ma','sang','ma','sang'],
        '상마상마': ['sang','ma','sang','ma'],
        '마상상마': ['ma','sang','sang','ma'],
        '상마마상': ['sang','ma','ma','sang']
      };
      const aCho = map[pCho], aHan = map[pHan];
      const S = {};
      // 초
      S['0,0']={team:'cho',piece:'cha'};
      S['0,1']={team:'cho',piece:aCho[0]};
      S['0,2']={team:'cho',piece:aCho[1]};
      S['0,3']={team:'cho',piece:'sa'};
      S['0,5']={team:'cho',piece:'sa'};
      S['0,6']={team:'cho',piece:aCho[2]};
      S['0,7']={team:'cho',piece:aCho[3]};
      S['0,8']={team:'cho',piece:'cha'};
      S['1,4']={team:'cho',piece:'jang'};
      S['2,1']={team:'cho',piece:'po'};
      S['2,7']={team:'cho',piece:'po'};
      for (const c of [0,2,4,6,8]) S[`3,${c}`]={team:'cho',piece:'jol'};
      // 한
      S['9,0']={team:'han',piece:'cha'};
      S['9,1']={team:'han',piece:aHan[0]};
      S['9,2']={team:'han',piece:aHan[1]};
      S['9,3']={team:'han',piece:'sa'};
      S['9,5']={team:'han',piece:'sa'};
      S['9,6']={team:'han',piece:aHan[2]};
      S['9,7']={team:'han',piece:aHan[3]};
      S['9,8']={team:'han',piece:'cha'};
      S['8,4']={team:'han',piece:'jang'};
      S['7,1']={team:'han',piece:'po'};
      S['7,7']={team:'han',piece:'po'};
      for (const c of [0,2,4,6,8]) S[`6,${c}`]={team:'han',piece:'byung'};
      return S;
    }

    let currentSetup = makeInitialSetup();
    let turn = 'cho';
    let plyCount = 0;

    const setMsg = (t)=> statusMsg.textContent = t || '';

    // (이하 이동/합법수/렌더링 로직은 질문 주신 코드 그대로 유지)
    // ... [생략 없음: 원문 그대로] ...

    // 초기 보드 그리기/반응형
    const renderAll = ()=>{ updateCellSize(); drawPalaceLines(); }
    updateCellSize(); drawPalaceLines();
    placePieces(currentSetup);
    addEventListener('resize', renderAll);
    addEventListener('orientationchange', renderAll);

    /* ================== DB 동기화 ================== */
    onValue(stateRef, snap=>{
      if (!snap.exists()){
        runTransaction(stateRef, (s)=>{
          if (s) return s;
          return {
            board: makeInitialSetup(roomSettings.choPattern, roomSettings.hanPattern),
            turn: roomSettings.firstTurn || 'cho',
            plyCount: 0,
            ended: false,
            winner: null
          };
        });
        return;
      }
      const v = snap.val();
      endedFlag = !!v.ended;
      applyRemoteState(v);
    });

    // 플레이어 수 모니터링: 종료된 방 & 모두 나가면 삭제
    onValue(playersRef, async snap=>{
      const players = snap.val()||{};
      const cnt = Object.keys(players).length;
      await update(roomRef, { playerCount: cnt, status: (cnt>=2 ? 'playing' : 'waiting') });

      if (cnt === 0 && endedFlag) {
        try {
          const lockRef = ref(db, `${NS}/${roomId}/__cleanupLock`);
          const uid = auth.currentUser?.uid || Math.random().toString(36).slice(2);
          const res = await runTransaction(lockRef, v => v || uid);
          if (res.committed && res.snapshot.val() === uid) {
            await remove(roomRef);
          }
        } catch (e) {
          console.error('room cleanup failed:', e);
        }
      }
    });

    /* ================== 입력 처리 ================== */
    // ...(원문과 동일: showLegalMoves, commitMove 등) ...

    // 떠날 때 players에서 제거
    window.addEventListener('beforeunload', ()=>{
      const uid = auth.currentUser?.uid;
      if (uid) remove(ref(db, `${NS}/${roomId}/players/${uid}`));
    });
  </script>
</body>
</html>
