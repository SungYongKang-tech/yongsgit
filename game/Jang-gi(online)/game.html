<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>장기 게임 (온라인 2인)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root{
      --cell-size:56px; --board-width:calc(var(--cell-size)*8); --board-height:calc(var(--cell-size)*9);
      --border-color:#3a2a1a; --board-bg:#e4c59a; --piece-scale:1.3; --dot-size:16px;
    }
    *{box-sizing:border-box}
    body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;
      display:flex;justify-content:center;align-items:center;flex-direction:column;
      background:#f0e6d2;margin:0;padding:16px;min-height:100dvh;}
    h1{margin:8px 0 6px;font-size:clamp(18px,4.5vw,28px);color:#333}
    .topline{font-size:14px;margin:4px 0 10px;color:#444;text-align:center}
    .bar{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center; margin:6px 0 8px;
      font-size:14px; color:#374151; }
    .msg { min-height:22px; font-weight:700; color:#b00020; text-align:center; }

    /* 고정 턴 인디케이터 */
    .turnbar{ margin:8px 0 10px; text-align:center; }
    .turnchip{ display:inline-flex; align-items:center; gap:8px; padding:8px 14px; border-radius:9999px;
      font-weight:800; background:#fff; border:1px solid #e5e7eb; box-shadow:0 4px 12px rgba(0,0,0,.08);}
    .turnchip .dot{ width:10px; height:10px; border-radius:50%; }
    .turnchip.cho .dot{ background:#1e64ff; } .turnchip.han .dot{ background:#e53935; }
    .turnchip.done{ opacity:.6; }

    #janggi-board-container{
      position:relative; width:calc(var(--board-width)+var(--cell-size)); height:calc(var(--board-height)+var(--cell-size));
      max-width:100vw; max-height:calc(100dvh - 190px); background:var(--board-bg);
      border:2px solid var(--border-color); padding:calc(var(--cell-size)/2); overflow:hidden;
    }
    #janggi-board{
      position:relative; width:var(--board-width); height:var(--board-height);
      background-image:
        repeating-linear-gradient(to right,transparent,transparent calc(var(--cell-size) - 1px),var(--border-color) calc(var(--cell-size) - 1px),var(--border-color) var(--cell-size)),
        repeating-linear-gradient(to bottom,transparent,transparent calc(var(--cell-size) - 1px),var(--border-color) calc(var(--cell-size) - 1px),var(--border-color) var(--cell-size));
      background-size:var(--cell-size) var(--cell-size); border:1px solid var(--border-color);
    }
    #palace-overlay{position:absolute;inset:0;pointer-events:none;z-index:1}
    #pieces-layer{position:absolute;inset:0;pointer-events:none;z-index:2}
    #moves-layer{position:absolute;inset:0;pointer-events:auto;z-index:3}

    .piece{
      position:absolute; width:calc(var(--cell-size) * var(--piece-scale)); height:calc(var(--cell-size) * var(--piece-scale));
      left:calc(var(--col) * 100% / 8); top:calc(var(--row) * 100% / 9); transform:translate(-50%, -50%);
      background-size:contain;background-repeat:no-repeat;background-position:center; border-radius:50%;
      cursor:pointer; pointer-events:auto; transition:box-shadow .15s ease, transform .15s ease;
    }
    .piece.selected{ box-shadow:0 0 12px 4px rgba(255,0,0,.55) }
    .move-dot{
      position:absolute; width:var(--dot-size); height:var(--dot-size);
      left:calc(var(--col) * 100% / 8); top:calc(var(--row) * 100% / 9);
      transform:translate(-50%, -50%); border-radius:50%;
      background:rgba(0,0,0,.15); border:2px solid rgba(0,0,0,.35); cursor:pointer;
    }

    .row{display:flex; gap:12px; align-items:center; justify-content:center; margin:4px 0 10px; font-size:14px;}
    .banner{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:4;
      font-weight:900; letter-spacing:2px; text-shadow:0 2px 6px rgba(0,0,0,.25); font-size:clamp(28px, 8vw, 96px); opacity:0; transition:opacity .3s ease;}
    .banner.show{ opacity:.9; } .banner.cho{ color:#1e64ff; } .banner.han{ color:#e53935; }
    #result-overlay{ position:absolute; inset:0; z-index:6; background:rgba(0,0,0,.66); display:none; align-items:center; justify-content:center;}
    #result-text{ color:#fff; font-size:clamp(36px, 12vw, 120px); font-weight:900; text-shadow:0 4px 18px rgba(0,0,0,.65);}
  </style>
</head>
<body>
  <h1>장기 게임 (온라인)</h1>
  <div class="topline" id="roomInfo">방 정보 불러오는 중…</div>
  <div class="bar" id="setupInfo">초/한 배치 불러오는 중…</div>
  <div class="row"><span class="msg" id="statusMsg"></span></div>

  <!-- ✅ 항상 보이는 턴 인디케이터 -->
  <div class="turnbar"><span id="turnChip" class="turnchip cho"><span class="dot"></span><span id="turnText">초 차례</span></span></div>

  <div id="janggi-board-container">
    <div id="janggi-board">
      <svg id="palace-overlay" width="100%" height="100%"></svg>
      <div id="pieces-layer"></div>
      <div id="moves-layer"></div>
      <div id="turn-banner" class="banner"></div>
      <div id="result-overlay"><div id="result-text"></div></div>
    </div>
  </div>

  <audio id="moveSnd" src="button-29.mp3" preload="auto"></audio>
  <audio id="capSnd"  src="button2.mp3"  preload="auto"></audio>

  <script type="module">
    /* ============ Firebase ============ */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getDatabase, ref, get, set, runTransaction, onValue, update, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.firebasestorage.app",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:dfe39687717f28b891a561"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);
    const auth = getAuth(app);

    async function ensureAnon(){
      if (auth.currentUser) return auth.currentUser;
      return new Promise((resolve,reject)=>{
        const unsub = onAuthStateChanged(auth, u=>{ if(u){unsub(); resolve(u);} });
        signInAnonymously(auth).catch(reject);
      });
    }
    await ensureAnon();

    /* ============ 방 진입 ============ */
    const params = new URLSearchParams(location.search);
    const roomId = params.get('room');
    if (!roomId){ alert('room 파라미터가 없습니다.'); location.href='index.html'; }

    const roomRef    = ref(db, `janggi/rooms/${roomId}`);
    const playersRef = ref(db, `janggi/rooms/${roomId}/players`);
    const stateRef   = ref(db, `janggi/rooms/${roomId}/state`);

    let myRole = null; // 0=초, 1=한
    let myTeam = null; // 'cho' | 'han'
    let endedFlag = false;
    let gameOver = false;
    let lastPly = 0;
    let roomSettings = { choPattern:'마상마상', hanPattern:'마상마상', firstTurn:'cho', creatorRole:0 };

    const roomInfo  = document.getElementById('roomInfo');
    const setupInfo = document.getElementById('setupInfo');
    const statusMsg = document.getElementById('statusMsg');
    const turnChip  = document.getElementById('turnChip');
    const turnText  = document.getElementById('turnText');

    const roleToTeam = r => r===0 ? 'cho' : 'han';
    const opp        = t => t==='cho' ? 'han' : 'cho';
    const key        = (r,c)=>`${r},${c}`;
    const inside     = (r,c)=> r>=0 && r<=9 && c>=0 && c<=8;

    async function enterRoom(){
      const uid = auth.currentUser.uid;

      // 1) 자리 배정
      let assigned = 0;
      const tx = await runTransaction(playersRef, (players)=>{
        players = players || {};
        if (players[uid]) return players;
        const ids = Object.keys(players);
        if (ids.length>=2) return; // full
        const taken = Object.values(players).map(p=>p.role);
        assigned = taken.includes(0) ? 1 : 0;
        players[uid] = { role: assigned, joinedAt: Date.now() };
        return players;
      });
      if (!tx.committed){ alert('이미 2명입니다.'); location.href='index.html'; return; }

      const cur = tx.snapshot.val()||{};
      myRole = cur[uid].role;
      myTeam = roleToTeam(myRole);

      // 2) 방 설정 로드
      const rs = await get(roomRef);
      const rv = rs.val()||{};
      roomSettings = rv.settings || roomSettings;

      // 3) 상태 라벨/접속 상태
      const cnt = Math.min(2, Object.keys(cur).length);
      await update(roomRef, { playerCount: cnt, status: (cnt>=2?'playing':'waiting') });
      onDisconnect(ref(db, `janggi/rooms/${roomId}/players/${uid}`)).remove();

      roomInfo.innerHTML = `방: <b>${roomId}</b> — 나는 <b>${myTeam==='cho'?'초':'한'}</b>입니다.`;
      setupInfo.textContent = `초 배치: ${roomSettings.choPattern} · 한 배치: ${roomSettings.hanPattern}`;
    }
    await enterRoom();

    /* ============ 보드/뷰 ============ */
    const boardEl   = document.getElementById('janggi-board');
    const overlay   = document.getElementById('palace-overlay');
    const piecesLay = document.getElementById('pieces-layer');
    const movesLay  = document.getElementById('moves-layer');
    const bannerEl  = document.getElementById('turn-banner');
    const resultOv  = document.getElementById('result-overlay');
    const resultTx  = document.getElementById('result-text');

    const moveSnd = document.getElementById('moveSnd');
    const capSnd  = document.getElementById('capSnd');
    const playMove=()=>{ try{ moveSnd.currentTime=0; moveSnd.play().catch(()=>{});}catch{} };

    function setMsg(t){ statusMsg.textContent = t || ''; }
    function updateTurnChip(team, ended=false){
      turnChip.classList.remove('cho','han','done');
      turnChip.classList.add(team==='cho'?'cho':'han');
      if (ended) turnChip.classList.add('done');
      turnText.textContent = (team==='cho') ? '초 차례' : '한 차례';
    }
    function showResult(winner){
      gameOver = true;
      updateTurnChip('cho', true); // 회색처리
      resultTx.textContent = (winner==='cho'?'초 승':'한 승');
      resultOv.style.display='flex';
    }
    function showTurnBanner(team){
      bannerEl.className = 'banner '+(team==='cho'?'cho':'han');
      bannerEl.textContent = (team==='cho'?'초 차례':'한 차례');
      bannerEl.classList.add('show');
      setTimeout(()=>bannerEl.classList.remove('show'),900);
    }

    const getCellSize = ()=> parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
    function updateCellSize(){
      const titleH = (document.querySelector('h1')?.offsetHeight||0)
                   + (document.querySelector('.topline')?.offsetHeight||0)
                   + (document.querySelector('.bar')?.offsetHeight||0)
                   + (document.querySelector('.row')?.offsetHeight||0)
                   + (document.querySelector('.turnbar')?.offsetHeight||0);
      const pad = 32, extraH = titleH + 28;
      const maxCellByW = (window.innerWidth - pad) / 9;
      const maxCellByH = (window.innerHeight - pad - extraH) / 10;
      const cell = Math.floor(Math.max(32, Math.min(maxCellByW, maxCellByH)));
      document.documentElement.style.setProperty('--cell-size', cell + 'px');
    }
    function drawPalaceLines(){
      const CELL = getCellSize(), W=8*CELL, H=9*CELL;
      overlay.setAttribute('viewBox', `0 0 ${W} ${H}`);
      while(overlay.firstChild) overlay.removeChild(overlay.firstChild);
      const stroke = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim()||'#3a2a1a';
      const mk=(x1,y1,x2,y2)=>{ const ln=document.createElementNS('http://www.w3.org/2000/svg','line');
        ln.setAttribute('x1',x1); ln.setAttribute('y1',y1); ln.setAttribute('x2',x2); ln.setAttribute('y2',y2);
        ln.setAttribute('stroke',stroke); ln.setAttribute('stroke-width',1); ln.setAttribute('stroke-opacity',.8);
        ln.setAttribute('shape-rendering','crispEdges'); return ln; };
      overlay.appendChild(mk(3*CELL,0*CELL,5*CELL,2*CELL));
      overlay.appendChild(mk(5*CELL,0*CELL,3*CELL,2*CELL));
      overlay.appendChild(mk(3*CELL,7*CELL,5*CELL,9*CELL));
      overlay.appendChild(mk(5*CELL,7*CELL,3*CELL,9*CELL));
    }

    // 내 화면에서 내 진영이 아래쪽
    function toViewRC(r,c){ return (myTeam==='cho') ? [9-r, 8-c] : [r,c]; }

    // 초기 배치
    function makeInitialSetup(pCho='마상마상', pHan='마상마상'){
      const map = {
        '마상마상':['ma','sang','ma','sang'],
        '상마상마':['sang','ma','sang','ma'],
        '마상상마':['ma','sang','sang','ma'],
        '상마마상':['sang','ma','ma','sang']
      };
      const aCho = map[pCho], aHan = map[pHan];
      const S = {};
      // 초
      S['0,0']={team:'cho',piece:'cha'};
      S['0,1']={team:'cho',piece:aCho[0]};
      S['0,2']={team:'cho',piece:aCho[1]};
      S['0,3']={team:'cho',piece:'sa'};
      S['0,5']={team:'cho',piece:'sa'};
      S['0,6']={team:'cho',piece:aCho[2]};
      S['0,7']={team:'cho',piece:aCho[3]};
      S['0,8']={team:'cho',piece:'cha'};
      S['1,4']={team:'cho',piece:'jang'};
      S['2,1']={team:'cho',piece:'po'};
      S['2,7']={team:'cho',piece:'po'};
      for (const c of [0,2,4,6,8]) S[`3,${c}`]={team:'cho',piece:'jol'};
      // 한
      S['9,0']={team:'han',piece:'cha'};
      S['9,1']={team:'han',piece:aHan[0]};
      S['9,2']={team:'han',piece:aHan[1]};
      S['9,3']={team:'han',piece:'sa'};
      S['9,5']={team:'han',piece:'sa'};
      S['9,6']={team:'han',piece:aHan[2]};
      S['9,7']={team:'han',piece:aHan[3]};
      S['9,8']={team:'han',piece:'cha'};
      S['8,4']={team:'han',piece:'jang'};
      S['7,1']={team:'han',piece:'po'};
      S['7,7']={team:'han',piece:'po'};
      for (const c of [0,2,4,6,8]) S[`6,${c}`]={team:'han',piece:'byung'};
      return S;
    }

    let currentSetup = makeInitialSetup();
    let turn = 'cho';
    let plyCount = 0;

    /* ============ 말/규칙 ============ */
    const palaceTop = new Set(['0,3','0,4','0,5','1,3','1,4','1,5','2,3','2,4','2,5']);
    const palaceBottom = new Set(['7,3','7,4','7,5','8,3','8,4','8,5','9,3','9,4','9,5']);
    const inPalace = (r,c)=> palaceTop.has(key(r,c)) || palaceBottom.has(key(r,c));
    const palaceKind = (r,c)=> palaceTop.has(key(r,c)) ? 'top' : (palaceBottom.has(key(r,c))?'bottom':null);
    const palaceDiagNeighbors = {
      '1,4': [['0,3'],['0,5'],['2,3'],['2,5']],
      '0,3': [['1,4']], '0,5': [['1,4']], '2,3': [['1,4']], '2,5': [['1,4']],
      '8,4': [['7,3'],['7,5'],['9,3'],['9,5']],
      '7,3': [['8,4']], '7,5': [['8,4']], '9,3': [['8,4']], '9,5': [['8,4']]
    };
    const topCorners = ['0,3','0,5','2,3','2,5'], topCenter='1,4';
    const botCorners = ['7,3','7,5','9,3','9,5'], botCenter='8,4';
    const diagNeighbors = (r,c)=> (palaceDiagNeighbors[key(r,c)]||[]).map(([s])=>s.split(',').map(Number));
    const oppositeCorner = (r,c)=>{
      const s=key(r,c);
      if (topCorners.includes(s)){
        if (s==='0,3') return [2,5];
        if (s==='2,5') return [0,3];
        if (s==='0,5') return [2,3];
        if (s==='2,3') return [0,5];
      }
      if (botCorners.includes(s)){
        if (s==='7,3') return [9,5];
        if (s==='9,5') return [7,3];
        if (s==='7,5') return [9,3];
        if (s==='9,3') return [7,5];
      }
      return null;
    };

    const bGet = (B,r,c)=> B.get(key(r,c)) || null;
    function bMove(B, fr,fc, tr,tc){ const NB=new Map(B); const fromK=key(fr,fc), toK=key(tr,tc);
      const P=NB.get(fromK); if(!P) return NB; NB.delete(fromK); NB.set(toK,{team:P.team,piece:P.piece}); return NB; }
    function findKing(B, team){ for (const [k,v] of B.entries()){ if (v.piece==='jang'&&v.team===team) return k.split(',').map(Number);} return null; }
    function kingsFacing(B){
      let choK=null, hanK=null;
      for (const [k,v] of B.entries()){ if (v.piece!=='jang') continue; const rc=k.split(',').map(Number); (v.team==='cho'?choK:hanK)=rc; }
      if (!choK||!hanK) return false; const [r1,c1]=choK,[r2,c2]=hanK; if (c1!==c2) return false; const c=c1;
      const [s,e]=r1<r2?[r1+1,r2-1]:[r2+1,r1-1]; for(let r=s;r<=e;r++){ if(bGet(B,r,c)) return false; } return true;
    }

    function addLineAttacks(B, team, r,c, dr,dc, out){
      let rr=r+dr, cc=c+dc;
      while (inside(rr,cc)){
        const occ=bGet(B,rr,cc);
        if (!occ){ out.add(key(rr,cc)); rr+=dr; cc+=dc; continue; }
        if (occ.team!==team) out.add(key(rr,cc));
        return;
      }
    }
    function addPoLineAttacks(B, team, r,c, dr,dc, out){ // 포 장군/위협
      let rr=r+dr, cc=c+dc;
      while (inside(rr,cc)){
        const occ=bGet(B,rr,cc);
        if (!occ){ rr+=dr; cc+=dc; continue; }
        if (occ.piece==='po') return; // 포 위에 포로 못 넘음
        rr+=dr; cc+=dc; break;        // 발 하나 건너뛰기
      }
      while (inside(rr,cc)){
        const occ=bGet(B,rr,cc);
        if (!occ){ rr+=dr; cc+=dc; continue; }
        if (occ.team!==team && occ.piece!=='po') out.add(key(rr,cc));
        return;
      }
    }
    function addPoPalaceDiagAttack(B, team, r,c, out){ // 궁 대각 포 공격
      const kind=palaceKind(r,c); if(!kind) return;
      const s=key(r,c), center=(kind==='top')?topCenter:botCenter; const [cr,cc]=center.split(',').map(Number);
      const oppC=oppositeCorner(r,c); if(!oppC) return;
      const isCorner=(kind==='top'?topCorners.includes(s):botCorners.includes(s));
      if(!isCorner) return; const mid=bGet(B,cr,cc); if(!mid||mid.piece==='po') return;
      const [or,oc]=oppC; const occ=bGet(B,or,oc); if(occ && occ.team!==team && occ.piece!=='po') out.add(key(or,oc));
    }

    function genAttacksForPiece(B, r,c, info){
      const out=new Set(); const team=info.team, pc=info.piece; const forward=(team==='cho')?+1:-1;
      if (pc==='cha'){
        for (const d of [[1,0],[-1,0],[0,1],[0,-1]]) addLineAttacks(B,team,r,c, ...d,out);
        if (inPalace(r,c)) for (const [nr,nc] of diagNeighbors(r,c)){ const occ=bGet(B,nr,nc); if(!occ||occ.team!==team) out.add(key(nr,nc)); }
      } else if (pc==='po'){
        for (const d of [[1,0],[-1,0],[0,1],[0,-1]]) addPoLineAttacks(B,team,r,c, ...d,out);
        addPoPalaceDiagAttack(B,team,r,c,out);
      } else if (pc==='ma'){
        const legs=[{b:[-1,0],dst:[[-2,-1],[-2,1]]},{b:[1,0],dst:[[2,-1],[2,1]]},{b:[0,-1],dst:[[-1,-2],[1,-2]]},{b:[0,1],dst:[[-1,2],[1,2]]}];
        for (const {b:[br,bc],dst} of legs){ const lr=r+br, lc=c+bc; if(!inside(lr,lc)||bGet(B,lr,lc)) continue;
          for (const [dr,dc] of dst){ const rr=r+dr,cc=c+dc; if(!inside(rr,cc)) continue; const occ=bGet(B,rr,cc); if(!occ||occ.team!==team) out.add(key(rr,cc)); }}
      } else if (pc==='sang'){
        const paths=[{s1:[-1,0],s2:[-2,-1],d:[-3,-2]},{s1:[-1,0],s2:[-2,1],d:[-3,2]},{s1:[1,0],s2:[2,-1],d:[3,-2]},{s1:[1,0],s2:[2,1],d:[3,2]},
                     {s1:[0,-1],s2:[-1,-2],d:[-2,-3]},{s1:[0,-1],s2:[1,-2],d:[2,-3]},{s1:[0,1],s2:[-1,2],d:[-2,3]},{s1:[0,1],s2:[1,2],d:[2,3]}];
        for (const {s1:[a,b],s2:[c1,d1],d:[e,f]} of paths){
          const s1r=r+a,s1c=c+b,s2r=r+c1,s2c=c+d1,tr=r+e,tc=c+f;
          if(!inside(s1r,s1c)||bGet(B,s1r,s1c)) continue;
          if(!inside(s2r,s2c)||bGet(B,s2r,s2c)) continue;
          if(!inside(tr,tc)) continue;
          const occ=bGet(B,tr,tc); if(!occ||occ.team!==team) out.add(key(tr,tc));
        }
      } else if (pc==='jol' || pc==='byung'){
        const fr=r+forward; if(inside(fr,c)){ const occ=bGet(B,fr,c); if(!occ||occ.team!==team) out.add(key(fr,c)); }
        for (const dc of [-1,1]){ const cc=c+dc; if(!inside(r,cc)) continue; const occ=bGet(B,r,cc); if(!occ||occ.team!==team) out.add(key(r,cc)); }
        if (inPalace(r,c)) for (const [nr,nc] of diagNeighbors(r,c)){
          if ((team==='cho'&&nr>r)||(team==='han'&&nr<r)){ const occ=bGet(B,nr,nc); if(!occ||occ.team!==team) out.add(key(nr,nc)); } }
      } else if (pc==='jang' || pc==='sa'){
        if (!inPalace(r,c)) return out;
        for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){ const rr=r+dr,cc=c+dc; if(!inPalace(rr,cc)) continue; const occ=bGet(B,rr,cc); if(!occ||occ.team!==team) out.add(key(rr,cc)); }
        for (const [rr,cc] of diagNeighbors(r,c)){ const occ=bGet(B,rr,cc); if(!occ||occ.team!==team) out.add(key(rr,cc)); }
      }
      return out;
    }
    function isInCheck(B,team){ const K=findKing(B,team); if(!K) return false; const tgt=key(...K);
      for (const [pos,info] of B.entries()){ if(info.team===team) continue; const [r,c]=pos.split(',').map(Number);
        if (genAttacksForPiece(B,r,c,info).has(tgt)) return true; } return false; }

    function addPush(B, team, rr,cc, out){
      if (!inside(rr,cc)) return 'stop';
      const occ=bGet(B,rr,cc);
      if (!occ){ out.push([rr,cc]); return 'cont'; }
      if (occ.team!==team){ out.push([rr,cc]); return 'stop'; }
      return 'stop';
    }
    function addPoLineMoves(B, team, r,c, dr,dc, out){ // 포 이동(발 필수, 포 위 포 금지)
      let rr=r+dr, cc=c+dc;
      while (inside(rr,cc)){ const occ=bGet(B,rr,cc); if(!occ){ rr+=dr; cc+=dc; continue; }
        if(occ.piece==='po') return; rr+=dr; cc+=dc; break; } // 첫 발 하나 통과
      while (inside(rr,cc)){ const occ=bGet(B,rr,cc);
        if(!occ){ out.push([rr,cc]); rr+=dr; cc+=dc; continue; }
        if(occ.team!==team && occ.piece!=='po') out.push([rr,cc]); return; }
    }
    function addPoPalaceDiagonal(B, team, r,c, out){ // 궁 대각 포 이동
      const kind=palaceKind(r,c); if(!kind) return; const s=key(r,c);
      const center=(kind==='top')?topCenter:botCenter; const [cr,cc]=center.split(',').map(Number);
      const oppC=oppositeCorner(r,c); if(!oppC) return;
      const isCorner=(kind==='top'?topCorners.includes(s):botCorners.includes(s)); if(!isCorner) return;
      const mid=bGet(B,cr,cc); if(!mid||mid.piece==='po') return;
      const [or,oc]=oppC; const occ=bGet(B,or,oc);
      if(!occ) out.push([or,oc]); else if(occ.team!==team && occ.piece!=='po') out.push([or,oc]);
    }

    function genPseudoMoves(B, r,c, info){
      const out=[]; const team=info.team, pc=info.piece; const forward=(team==='cho')?+1:-1;
      if (pc==='cha'){
        for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){ let rr=r+dr,cc=c+dc; while(inside(rr,cc)){ const res=addPush(B,team,rr,cc,out); if(res==='stop') break; rr+=dr; cc+=dc; } }
        if (inPalace(r,c)) for (const [nr,nc] of diagNeighbors(r,c)){ const occ=bGet(B,nr,nc); if(!occ||occ.team!==team) out.push([nr,nc]); }
      } else if (pc==='po'){
        for (const d of [[1,0],[-1,0],[0,1],[0,-1]]) addPoLineMoves(B,team,r,c, ...d,out);
        addPoPalaceDiagonal(B,team,r,c,out);
      } else if (pc==='ma'){
        const legs=[{b:[-1,0],dst:[[-2,-1],[-2,1]]},{b:[1,0],dst:[[2,-1],[2,1]]},{b:[0,-1],dst:[[-1,-2],[1,-2]]},{b:[0,1],dst:[[-1,2],[1,2]]}];
        for (const {b:[br,bc],dst} of legs){ const lr=r+br,lc=c+bc; if(!inside(lr,lc)||bGet(B,lr,lc)) continue;
          for (const [dr,dc] of dst){ const rr=r+dr,cc=c+dc; if(!inside(rr,cc)) continue; const occ=bGet(B,rr,cc); if(!occ||occ.team!==team) out.push([rr,cc]); } }
      } else if (pc==='sang'){
        const paths=[{s1:[-1,0],s2:[-2,-1],d:[-3,-2]},{s1:[-1,0],s2:[-2,1],d:[-3,2]},{s1:[1,0],s2:[2,-1],d:[3,-2]},{s1:[1,0],s2:[2,1],d:[3,2]},
                     {s1:[0,-1],s2:[-1,-2],d:[-2,-3]},{s1:[0,-1],s2:[1,-2],d:[2,-3]},{s1:[0,1],s2:[-1,2],d:[-2,3]},{s1:[0,1],s2:[1,2],d:[2,3]}];
        for (const {s1:[a,b],s2:[c1,d1],d:[e,f]} of paths){
          const s1r=r+a,s1c=c+b,s2r=r+c1,s2c=c+d1,tr=r+e,tc=c+f;
          if(!inside(s1r,s1c)||bGet(B,s1r,s1c)) continue;
          if(!inside(s2r,s2c)||bGet(B,s2r,s2c)) continue;
          if(!inside(tr,tc)) continue;
          const occ=bGet(B,tr,tc); if(!occ||occ.team!==team) out.push([tr,tc]);
        }
      } else if (pc==='jol'||pc==='byung'){
        const fr=r+forward; if(inside(fr,c)){ const occ=bGet(B,fr,c); if(!occ||occ.team!==team) out.push([fr,c]); }
        for(const dc of [-1,1]){ const cc=c+dc; if(!inside(r,cc)) continue; const occ=bGet(B,r,cc); if(!occ||occ.team!==team) out.push([r,cc]); }
        if (inPalace(r,c)) for (const [nr,nc] of diagNeighbors(r,c)){
          if ((team==='cho'&&nr>r)||(team==='han'&&nr<r)){ const occ=bGet(B,nr,nc); if(!occ||occ.team!==team) out.push([nr,nc]); } }
      } else if (pc==='jang'||pc==='sa'){
        if (!inPalace(r,c)) return out;
        for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){ const rr=r+dr,cc=c+dc; if(!inPalace(rr,cc)) continue; const occ=bGet(B,rr,cc); if(!occ||occ.team!==team) out.push([rr,cc]); }
        for (const [rr,cc] of diagNeighbors(r,c)){ const occ=bGet(B,rr,cc); if(!occ||occ.team!==team) out.push([rr,cc]); }
      }
      return out;
    }
    function filterLegal(B, fr,fc, info, pseudo){
      const team=info.team, legal=[];
      for (const [tr,tc] of pseudo){
        const NB=bMove(B,fr,fc,tr,tc);
        if (kingsFacing(NB)) continue;
        if (isInCheck(NB,team)) continue;
        legal.push([tr,tc]);
      }
      return legal;
    }

    /* ============ 렌더링/입력 ============ */
    function placePieces(boardObj){
      piecesLay.innerHTML='';
      for (const [pos,info] of Object.entries(boardObj)){
        const [r,c]=pos.split(',').map(Number);
        const el=document.createElement('div');
        el.className='piece';
        const name=(info.team==='han'&&info.piece==='byung')?'byung':(info.team==='cho'&&info.piece==='jol')?'jol':info.piece;
        el.style.backgroundImage=`url('${info.team}_${name}.svg')`;
        el.dataset.team=info.team; el.dataset.piece=info.piece; el.dataset.row=r; el.dataset.col=c;
        const [vr,vc]=toViewRC(r,c); el.style.setProperty('--row',vr); el.style.setProperty('--col',vc);
        piecesLay.appendChild(el);
      }
    }
    function clearDots(){ movesLay.innerHTML=''; }
    function addDot(r,c, onClick){
      const [vr,vc]=toViewRC(r,c);
      const dot=document.createElement('div'); dot.className='move-dot';
      dot.style.setProperty('--row',vr); dot.style.setProperty('--col',vc);
      dot.addEventListener('click', e=>{ e.stopPropagation(); onClick(); });
      movesLay.appendChild(dot);
    }

    function applyRemoteState(s){
      if (!s) return;
      currentSetup = s.board || currentSetup;
      turn = s.turn || 'cho';
      plyCount = s.plyCount|0;
      endedFlag = !!s.ended;
      gameOver = !!s.ended;

      placePieces(currentSetup);
      clearDots();
      setMsg(s.message||'');
      updateTurnChip(turn, gameOver);
      if (gameOver && s.winner){ showResult(s.winner); }
      else { showTurnBanner(turn); resultOv.style.display='none'; }

      if (plyCount>lastPly) playMove();
      lastPly=plyCount;
    }

    function renderAll(){ updateCellSize(); drawPalaceLines(); }
    updateCellSize(); drawPalaceLines(); placePieces(currentSetup);
    addEventListener('resize', renderAll); addEventListener('orientationchange', renderAll);

    /* ============ 동기화/정리 ============ */
    onValue(stateRef, snap=>{
      if (!snap.exists()){
        runTransaction(stateRef, s=>{
          if (s) return s;
          return { board: makeInitialSetup(roomSettings.choPattern, roomSettings.hanPattern),
                   turn: roomSettings.firstTurn||'cho', plyCount:0, ended:false, winner:null };
        });
        return;
      }
      applyRemoteState(snap.val());
    });

    // 모두 나가고(0명) + 게임 끝났을 때만 방 삭제
    onValue(playersRef, async snap=>{
      const players=snap.val()||{}; const cnt=Object.keys(players).length;
      await update(roomRef, { playerCount: cnt, status: (cnt>=2?'playing':'waiting') });
      if (cnt===0 && endedFlag){
        try{
          const lockRef=ref(db, `janggi/rooms/${roomId}/__cleanupLock`);
          const uid=auth.currentUser?.uid || Math.random().toString(36).slice(2);
          const res=await runTransaction(lockRef, v=>v||uid);
          if (res.committed && res.snapshot.val()===uid){ await remove(roomRef); }
        }catch(e){ console.error('cleanup failed', e); }
      }
    });

    /* ============ 입력 ============ */
    let selected=null;

    function showLegal(el){
      clearDots();
      const B=new Map(Object.entries(currentSetup));
      const r=+el.dataset.row, c=+el.dataset.col;
      const info={team:el.dataset.team, piece:el.dataset.piece};
      const pseudo=genPseudoMoves(B,r,c,info);
      const legal=filterLegal(B,r,c,info,pseudo);
      legal.forEach(([rr,cc])=> addDot(rr,cc, ()=> commitMove(r,c,rr,cc)));
    }

    async function commitMove(fr,fc,tr,tc){
      if (gameOver) return;
      if (roleToTeam(myRole)!==turn){ setMsg('내 차례가 아닙니다.'); return; }

      const ok = await runTransaction(stateRef, s=>{
        if (!s || s.ended) return s;
        if (s.turn!==roleToTeam(myRole)) return s;

        const B=new Map(Object.entries(s.board||{}));
        const P=B.get(key(fr,fc)); if(!P || P.team!==s.turn) return s;

        const pseudo=genPseudoMoves(B,fr,fc,P);
        const legal=filterLegal(B,fr,fc,P,pseudo);
        const isLegal=legal.some(([rr,cc])=>rr===tr && cc===tc);
        if (!isLegal) return s;

        const NB=bMove(B,fr,fc,tr,tc);
        const next=opp(s.turn);
        let ended=false, winner=null, message='';

        const inChk=isInCheck(NB,next);
        if (inChk){
          let any=false;
          for (const [pos,info] of NB.entries()){
            if (info.team!==next) continue;
            const [r,c]=pos.split(',').map(Number);
            const lg=filterLegal(NB,r,c,info,genPseudoMoves(NB,r,c,info));
            if (lg.length){ any=true; break; }
          }
          if (!any){ ended=true; winner=s.turn; message='장군 · 외통수!'; }
          else     { message='장군!'; }
        }

        return { board:Object.fromEntries(NB.entries()),
                 turn: ended ? s.turn : next,
                 plyCount:(s.plyCount|0)+1, ended, winner, message };
      }).then(r=>r.committed);

      if (ok){ selected=null; clearDots(); } else { setMsg('이동 실패 또는 불가한 수입니다.'); }
    }

    // 말 클릭(포 포함) — pieces-layer에 이벤트 위임
    piecesLay.addEventListener('click', e=>{
      if (gameOver) return;
      const t=e.target.closest('.piece'); if(!t) return;
      setMsg('');
      if (t.dataset.team!==roleToTeam(myRole)) return;
      if (turn!==roleToTeam(myRole)){ setMsg('내 차례가 아닙니다.'); return; }
      if (selected===t){ t.classList.remove('selected'); selected=null; clearDots(); return; }
      if (selected) selected.classList.remove('selected');
      selected=t; t.classList.add('selected'); showLegal(t);
    });

    // 나가기: players에서 제거
    window.addEventListener('beforeunload', ()=>{
      const uid=auth.currentUser?.uid;
      if (uid) remove(ref(db, `janggi/rooms/${roomId}/players/${uid}`));
    });
  </script>
</body>
</html>
