<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì˜¤ëª© ëŒ€ì „</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: #f5f5f5;
      margin: 0;
      color-scheme: light only; /* âœ… ë‹¤í¬ëª¨ë“œ ê°•ì œ ë°©ì§€ */
    }
    #board {
      display: grid;
      grid-template-columns: repeat(15, 1fr);
      border: 2px solid #555;
      margin: 1rem auto;
      width: 95vmin;
      height: 95vmin;
      background-color: #d9a75f;
    }
    .cell {
      border: 1px solid #555;
      position: relative;
      background-color: transparent;
    }
    .stone {
      width: 70%;
      height: 70%;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .stone.black { background: black !important; }
    .stone.white { background: white; border: 1px solid #333; }
    .stone.gray  { background: gray; opacity: 0.5; }
    .stone.blink { animation: blink 1s infinite; }
    @keyframes blink {
      0%, 100% { box-shadow: 0 0 5px 5px rgba(255, 0, 0, 0.6); }
      50% { box-shadow: 0 0 5px 5px rgba(255, 255, 255, 0); }
    }
    #players, #turn, #room-info { font-weight: bold; margin: 0.5rem; }
    #setup { display: grid; gap: 10px; width: min(420px, 92%); margin: 12px auto; }
    button {
      width: 100%;
      padding: 14px;
      font-size: 18px;
      border: none;
      border-radius: 6px;
      background-color: #333;
      color: white;
      cursor: pointer;
    }
    button:hover { background-color: #555; }
    #soloBtn { background: #00695c; }
    #soloBtn:hover { background:#0a7d70; }

    .last-move-me { outline: 2px solid rgba(0, 123, 255, 0.9); outline-offset: 0px; z-index: 10; }
    .last-move-opponent { outline: 2px solid rgba(255, 0, 0, 0.8); outline-offset: 0px; z-index: 10; }

    /* ëª¨ë‹¬ */
    .modal { display: block; position: fixed; z-index: 1000; padding-top: 120px; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: #fff; margin: auto; padding: 30px; border: 1px solid #888; width: 90%; max-width: 400px; border-radius: 12px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.2); }
    .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
    .close:hover { color: black; }

    #control-area { margin-top: 10px; }
    #game-buttons { display: flex; justify-content: space-between; align-items: center; margin: 20px auto; width: 95vmin; max-width: 600px; gap: 8px; }
    #game-buttons button { flex: 0 0 auto; width: 48%; font-size: 16px; padding: 14px; border-radius: 8px; border: none; color: white; }
    #end-button { background-color: #d32f2f; }
    #end-button:hover { background-color: #a72828; }
    #confirm-move { background-color: #007bff; color: white; }
    #confirm-move:disabled { background-color: #999; cursor: not-allowed; }
  </style>
</head>
<body>
  <h2 id="title">âš« ì˜¤ëª© ëŒ€ì „</h2>
  <div id="setup">
    <button id="createBtn">ë°© ìƒì„±í•˜ê¸°</button>
    <button id="joinBtn">ë°© ì°¸ì—¬í•˜ê¸°</button>
    <button id="soloBtn">í˜¼ìí•˜ê¸° (ì»´í“¨í„°ì™€ ëŒ€ì „ Â· ê³ ê¸‰)</button>
    <p id="room-info"></p>
  </div>

  <div id="game" style="display:none">
    <div id="turn"></div>
    <div id="board"></div>
    <div id="game-buttons">
      <button id="end-button">ê²Œì„ ì¢…ë£Œ</button>
      <button id="confirm-move" disabled>ì°©ìˆ˜</button>
    </div>
  </div>

  <audio id="place-sound" src="button-29.mp3" preload="auto"></audio>

  <script type="module">
    /* =========================
       Firebase ì´ˆê¸°í™” + ìµëª… ë¡œê·¸ì¸ (ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œ ì‚¬ìš©)
       ========================= */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getDatabase, ref, set, get, onValue, remove } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.appspot.com",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:8cc90ab5a17c364b91a561"
    };

    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);
    const auth = getAuth(app);
    await setPersistence(auth, browserLocalPersistence);

    let currentUser = null;
    let resolveAuthReady;
    const authReady = new Promise(res => (resolveAuthReady = res));
    onAuthStateChanged(auth, (user) => { if (user) { currentUser = user; resolveAuthReady(user); } });
    try { await signInAnonymously(auth); } catch (e) { console.error(e); }

    /* =========================
       ê³µí†µ ìƒíƒœ & ìœ í‹¸
       ========================= */
    const SIZE = 15;
    const CENTER = Math.floor(SIZE/2);
    let gameMode = 'online'; // 'online' | 'solo'
    let roomCode = '', playerRole = '', playerName = '';
    let pendingMove = null; // ì„ì‹œ ë‘” ëŒ ìœ„ì¹˜ ì €ì¥

    // === SOLO ëª¨ë“œ ì „ìš© ìƒíƒœ
    let localBoard = null;  // 2ì°¨ì› ë°°ì—´
    let localTurn = 'A';    // 'A'(í‘=ì‚¬ëŒ) / 'B'(ë°±=AI)
    const HUMAN = 'A';
    const AI    = 'B';
    const STONE = { A: 'â—', B: 'â—‹' };

    function randomName() {
      const names = ['í˜¸ë‘ì´','í­ê·„','ê³ ì–‘ì´','ì‚¬ì','ë¶€ì—‰ì´','ì¹˜íƒ€'];
      return names[Math.floor(Math.random() * names.length)] + Math.floor(Math.random() * 100);
    }
    function randomRoomName() {
      const animals = ['í˜¸ë‘ì´', 'í­ê·„', 'ê³ ì–‘ì´', 'ì‚¬ì', 'ë¶€ì—‰ì´', 'ì¹˜íƒ€'];
      return animals[Math.floor(Math.random() * animals.length)] + Math.floor(Math.random() * 100) + 'ë°©';
    }
    function emptyBoard() {
      return Array.from({ length: SIZE }, () => Array(SIZE).fill(""));
    }

    /* =========================
       ê³µí†µ ë Œë”
       ========================= */
    function renderBoard() {
      const boardDiv = document.getElementById("board");
      boardDiv.innerHTML = "";
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.addEventListener("click", () => handleMove(r, c));
          boardDiv.appendChild(cell);
        }
      }
    }

    function placeStoneDOM(r, c, stoneChar) {
      const idx = r * SIZE + c;
      const cell = document.getElementById("board").children[idx];
      cell.innerHTML = "";
      if (stoneChar === "â—" || stoneChar === "â—‹") {
        const div = document.createElement("div");
        div.classList.add("stone", stoneChar === "â—" ? "black" : "white");
        cell.appendChild(div);
        cell.style.pointerEvents = "none";
      } else if (stoneChar === "preview") {
        const div = document.createElement("div");
        div.className = "stone gray";
        cell.appendChild(div);
      } else {
        cell.style.pointerEvents = "auto";
      }
    }

    function clearLastMoveHighlight() {
      document.querySelectorAll(".last-move-me, .last-move-opponent").forEach(el => el.classList.remove("last-move-me", "last-move-opponent"));
    }
    function highlightLastMove(r, c, mine) {
      const idx = r * SIZE + c;
      const cell = document.getElementById("board").children[idx];
      const stone = cell.querySelector(".stone");
      if (stone) stone.classList.add(mine ? "last-move-me" : "last-move-opponent");
    }

    /* =========================
   (ê³µìš©) ìŠ¹ë¦¬ íŒì •: ì˜¤ì§ 5ëª© ì´ìƒë§Œ ìŠ¹ë¦¬
   ========================= */
function checkWinGeneric(r, c, stone, board) {
  const directions = [[0,1],[1,0],[1,1],[1,-1]];
  for (const [dr, dc] of directions) {
    let count = 1;
    let pos = [[r, c]];

    // ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì—°ì† ì¹´ìš´íŠ¸
    for (let i = 1; i < 5; i++) {
      const nr = r - dr * i, nc = c - dc * i;
      if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) break;
      if (board[nr][nc] === stone) { count++; pos.unshift([nr, nc]); }
      else break;
    }

    // ì •ë°©í–¥ìœ¼ë¡œ ì—°ì† ì¹´ìš´íŠ¸
    for (let i = 1; i < 5; i++) {
      const nr = r + dr * i, nc = c + dc * i;
      if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) break;
      if (board[nr][nc] === stone) { count++; pos.push([nr, nc]); }
      else break;
    }

    // âœ… ì˜¤ì§ 5ëª©(ì´ìƒ)ë§Œ ìŠ¹ë¦¬. ì—´ë¦°4ëŠ” ìŠ¹ë¦¬ë¡œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ.
    if (count >= 5) return pos;
  }
  return null;
}


    /* =========================
       ì…ë ¥ ì²˜ë¦¬ (ê³µìš©)
       ========================= */
    function handleMove(r, c) {
      // ê¸°ì¡´ ì„ì‹œ ìˆ˜ ì œê±°
      if (pendingMove) {
        const prevIdx = pendingMove.row * SIZE + pendingMove.col;
        const prevCell = document.getElementById("board").children[prevIdx];
        prevCell.innerHTML = "";
      }
      pendingMove = { row: r, col: c };
      placeStoneDOM(r, c, "preview");
      document.getElementById("confirm-move").disabled = false;
    }

    /* =========================
       ì˜¨ë¼ì¸ ëª¨ë“œ (ê¸°ì¡´)
       ========================= */
    async function createRoom() {
      await authReady;
      const latestRef = ref(db, 'latestRoom');
      const latestSnap = await get(latestRef);
      const now = Date.now();
      if (latestSnap.exists() && now - latestSnap.val().createdAt < 60_000) { alert("1ë¶„ ë‚´ ìƒì„±ëœ ë°©ì´ ìˆì–´ìš”"); return; }
      roomCode = randomRoomName();
      playerName = randomName();

      await set(ref(db, 'rooms/' + roomCode), {
        players: { A: { name: playerName, uid: currentUser.uid } },
        turn: 'A',
        board: emptyBoard(),
        winner: null,
        createdAt: now,
        createdBy: currentUser.uid
      });

      // ìµœê·¼ 10ê°œë§Œ ìœ ì§€
      try {
        const roomsRef = ref(db, 'rooms');
        const snapshot = await get(roomsRef);
        if (snapshot.exists()) {
          const allRooms = snapshot.val();
          const roomsArray = Object.entries(allRooms)
            .map(([key, value]) => ({ key, createdAt: value.createdAt || 0 }))
            .sort((a, b) => b.createdAt - a.createdAt);
          const roomsToDelete = roomsArray.slice(10);
          for (const room of roomsToDelete) { try { await remove(ref(db, `rooms/${room.key}`)); } catch {} }
        }
      } catch {}
      await set(latestRef, { roomCode, createdAt: now, by: currentUser.uid });
      playerRole = 'A';
      gameMode = 'online';
      startOnline();
    }

    async function joinRoom() {
      await authReady;
      const latestSnap = await get(ref(db, 'latestRoom'));
      if (!latestSnap.exists()) { alert("ì°¸ì—¬ ê°€ëŠ¥í•œ ë°©ì´ ì—†ìŠµë‹ˆë‹¤."); return; }
      const { roomCode: code, createdAt } = latestSnap.val();
      const now = Date.now();
      if (now - createdAt > 60_000) { alert("ì°¸ì—¬ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤."); return; }

      const roomRef = ref(db, `rooms/${code}`);
      const roomSnap = await get(roomRef);
      if (!roomSnap.exists()) { alert("ë°©ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."); return; }
      const data = roomSnap.val();
      if (data.players?.B) { alert("ì´ë¯¸ ë‘ ëª…ì´ ì°¸ì—¬ ì¤‘ì…ë‹ˆë‹¤."); return; }

      playerName = randomName();
      await set(ref(db, `rooms/${code}/players/B`), { name: playerName, uid: currentUser.uid });
      roomCode = code;
      playerRole = 'B';
      gameMode = 'online';
      startOnline();
    }

    async function startOnline() {
      document.getElementById("setup").style.display = "none";
      document.getElementById("game").style.display = "block";
      document.getElementById("title").innerText = `âš« ì˜¤ëª© ëŒ€ì „ - ë°©ë²ˆí˜¸: ${roomCode}`;
      try { await remove(ref(db, `rooms/${roomCode}/winner`)); } catch {}
      renderBoard();
      listenBoardOnline();
      listenWinnerOnline();
      listenTurnOnline();
      listenPeerJoinOnline();
    }

    function listenBoardOnline() {
      onValue(ref(db, `rooms/${roomCode}/board`), snap => {
        if (!snap.exists()) return;
        const data = snap.val();
        for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) placeStoneDOM(r, c, data[r]?.[c] || "");
      });
      onValue(ref(db, `rooms/${roomCode}/lastMove`), snap => {
        const move = snap.val();
        if (!move) return;
        if (move.role !== playerRole) document.getElementById("place-sound").play().catch(()=>{});
        clearLastMoveHighlight();
        highlightLastMove(move.row, move.col, move.role === playerRole);
      });
    }

    function listenTurnOnline() {
      const btn = document.getElementById('confirm-move');
      onValue(ref(db, `rooms/${roomCode}/turn`), snap => {
        const isMyTurn = snap.val() === playerRole;
        document.getElementById("turn").innerText = isMyTurn ? "ë‚´ ì°¨ë¡€" : "ìƒëŒ€ ì°¨ë¡€";
        btn.disabled = !(isMyTurn && pendingMove);
      });
    }

    function listenPeerJoinOnline() {
      const otherPlayer = playerRole === 'A' ? 'B' : 'A';
      onValue(ref(db, `rooms/${roomCode}/players/${otherPlayer}`), snap => {
        if (snap.exists()) alert(`ğŸ® ìƒëŒ€ë°©(${snap.val().name})ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤!`);
      });
    }

    function listenWinnerOnline() {
      onValue(ref(db, `rooms/${roomCode}/winner`), snap => {
        const data = snap.val();
        if (!data || !data.name || !Array.isArray(data.positions)) return;
        const isWinner = data.name === playerName;
        alert(isWinner ? "ğŸ‰ ë‹¹ì‹ ì´ ì´ê²¼ìŠµë‹ˆë‹¤!" : "ğŸ˜¢ ë‹¹ì‹ ì´ íŒ¨ë°°í•˜ì˜€ìŠµë‹ˆë‹¤.");
        data.positions.forEach(([r, c]) => {
          const idx = r * SIZE + c;
          const cell = document.getElementById("board").children[idx];
          const stone = cell.querySelector('.stone');
          if (stone) stone.classList.add("blink");
        });
        setTimeout(async () => { await deleteRoom(roomCode); location.reload(); }, 3000);
      });
    }

    async function commitMoveOnline() {
      if (!pendingMove) return;
      const { row, col } = pendingMove;

      const turnSnap = await get(ref(db, `rooms/${roomCode}/turn`));
      const turn = turnSnap.val();
      if (turn !== playerRole) { alert("ìƒëŒ€ ì°¨ë¡€ì…ë‹ˆë‹¤"); return; }

      const boardSnap = await get(ref(db, `rooms/${roomCode}/board`));
      const board = boardSnap.val();
      if (board[row][col] !== "") { alert("ì´ë¯¸ ì°©ìˆ˜ëœ ìë¦¬ì…ë‹ˆë‹¤."); return; }

      const stone = playerRole === 'A' ? 'â—' : 'â—‹';
      board[row][col] = stone;
      const winPos = checkWinGeneric(row, col, stone, board);

      await set(ref(db, `rooms/${roomCode}/board/${row}/${col}`), stone);
      document.getElementById("place-sound").play().catch(()=>{});

      if (winPos) {
        await set(ref(db, `rooms/${roomCode}/winner`), { name: playerName, positions: winPos });
      } else {
        await set(ref(db, `rooms/${roomCode}/turn`), playerRole === 'A' ? 'B' : 'A');
      }
      await set(ref(db, `rooms/${roomCode}/lastMove`), { row, col, role: playerRole });

      pendingMove = null;
      document.getElementById("confirm-move").disabled = true;
    }

    async function deleteRoom(code) {
      try { await remove(ref(db, `rooms/${code}`)); } catch {}
      try { await remove(ref(db, `latestRoom`)); } catch {}
    }

    /* ======================================================
       ì†”ë¡œ(í˜¼ìí•˜ê¸°) ëª¨ë“œ â€” ê³ ê¸‰ AI (ì•ŒíŒŒâ€“ë² íƒ€ + íŒ¨í„´ í‰ê°€)
       ====================================================== */
    function startSolo() {
      gameMode = 'solo';
      roomCode = 'SOLO';
      playerRole = HUMAN; // ì‚¬ëŒì€ í‘
      localBoard = emptyBoard();
      localTurn = 'A';
      pendingMove = null;

      document.getElementById("setup").style.display = "none";
      document.getElementById("game").style.display = "block";
      document.getElementById("title").innerText = `âš« ì˜¤ëª© ëŒ€ì „ - í˜¼ìí•˜ê¸°(ì»´í“¨í„° Â· ê³ ê¸‰)`;
      document.getElementById("turn").innerText = "ë‚´ ì°¨ë¡€";

      renderBoard();
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) placeStoneDOM(r, c, "");
    }

    function commitMoveSolo() {
      if (!pendingMove) return;
      const { row, col } = pendingMove;
      if (localTurn !== HUMAN) { alert("ìƒëŒ€(ì»´í“¨í„°) ì°¨ë¡€ì…ë‹ˆë‹¤."); return; }
      if (localBoard[row][col] !== "") { alert("ì´ë¯¸ ì°©ìˆ˜ëœ ìë¦¬ì…ë‹ˆë‹¤."); return; }

      // ì‚¬ëŒ ìˆ˜
      localBoard[row][col] = STONE[HUMAN];
      placeStoneDOM(row, col, STONE[HUMAN]);
      clearLastMoveHighlight();
      highlightLastMove(row, col, true);
      document.getElementById("place-sound").play().catch(()=>{});

      const winPos = checkWinGeneric(row, col, STONE[HUMAN], localBoard);
      if (winPos) return finishSolo(winPos, true);

      pendingMove = null;
      localTurn = AI;
      document.getElementById("turn").innerText = "ìƒëŒ€ ì°¨ë¡€";
      document.getElementById("confirm-move").disabled = true;

      // âœ… ìš”ì²­: 2ì´ˆ ë’¤ì— AI ì°©ìˆ˜
      setTimeout(aiMoveAdvanced, 2000);
    }

    function finishSolo(winPositions, isHumanWin) {
      winPositions.forEach(([r, c]) => {
        const idx = r * SIZE + c;
        const cell = document.getElementById("board").children[idx];
        const stone = cell.querySelector('.stone');
        if (stone) stone.classList.add("blink");
      });
      alert(isHumanWin ? "ğŸ‰ ë‹¹ì‹ ì´ ì´ê²¼ìŠµë‹ˆë‹¤!" : "ğŸ¤– ì»´í“¨í„°ê°€ ì´ê²¼ìŠµë‹ˆë‹¤.");
      setTimeout(() => location.reload(), 2000);
    }

    // --- í›„ë³´ ìƒì„±: ê¸°ì¡´ ëŒì—ì„œ ë§¨í•´íŠ¼ â‰¤ 2
    function generateCandidates(board) {
      let hasStone = false;
      const cand = new Set();
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] !== "") {
            hasStone = true;
            for (let dr = -2; dr <= 2; dr++) {
              for (let dc = -2; dc <= 2; dc++) {
                const nr = r + dr, nc = c + dc;
                if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) continue;
                if (Math.abs(dr) + Math.abs(dc) > 2) continue;
                if (board[nr][nc] === "") cand.add(nr + "," + nc);
              }
            }
          }
        }
      }
      // ì´ˆë°˜ ë¹„ì–´ìˆìœ¼ë©´ ì¤‘ì•™
      if (!hasStone) return [{ r: CENTER, c: CENTER }];
      return Array.from(cand).map(s => {
        const [r, c] = s.split(",").map(Number);
        return { r, c };
      });
    }

    // --- ê°„ë‹¨ íœ´ë¦¬ìŠ¤í‹± (ì •ë ¬ìš©)
    function scoreCellHeuristic(board, r, c) {
      const centerBias = 10 - (Math.abs(CENTER - r) + Math.abs(CENTER - c));
      let neighbor = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) continue;
          if (board[nr][nc] === STONE[AI]) neighbor += 3;
          if (board[nr][nc] === STONE[HUMAN]) neighbor += 2;
        }
      }
      return centerBias + neighbor;
    }

    // --- íŒ¨í„´ í‰ê°€ (ì—´ë¦°4/ë‹«íŒ4/ì—´ë¦°3/ë‹«íŒ3/2 ë“±)
    function evaluateBoard(board) {
      // ìŠ¹ë¦¬ ì¦‰ì‹œ íŒì • ìš°ì„ 
      const winnerScore = 1_000_000;
      // ê°€ì¤‘ì¹˜ (ì¡°ì • ê°€ëŠ¥)
      const W = {
        five: 200_000,
        open4:  50_000,
        close4: 15_000,
        open3:   6_000,
        close3:  2_000,
        open2:     600,
        close2:    200
      };
      function lineScore(lineArr, stone) {
        let score = 0;
        const opp = (stone === 'â—') ? 'â—‹' : 'â—';

        // ë¬¸ìì—´ë¡œ ë³€í™˜í•´ì„œ íŒ¨í„´ íƒìƒ‰
        const s = lineArr.join('');
        // ì¦‰ìŠ¹
        if (s.includes(stone.repeat(5))) return W.five;

        // ì—´ë¦°/ë‹«íŒ íŒ¨í„´ ëŒ€ëµ ì¸¡ì •
        // ì—´ë¦°4: _XXXX_ (ë¹ˆì¹¸ + 4ì—°ì† + ë¹ˆì¹¸)
        if (s.includes(` ${stone.repeat(4)} `)) score += W.open4;
        // ë‹«íŒ4: (ëë§‰í˜ í¬í•¨) ex: OXXXX_ or _XXXXO
        if (s.match(new RegExp(`(?:${opp}|^){1}${stone.repeat(4)} `)) || s.match(new RegExp(` ${stone.repeat(4)}(?:${opp}|$){1}`))) score += W.close4;

        // ì—´ë¦°3: _XXX_ (ë‹¨, ì–‘ ëì´ ì—´ë ¤ì•¼)
        if (s.includes(` ${stone.repeat(3)} `)) score += W.open3;
        // ë‹«íŒ3:
        if (s.match(new RegExp(`(?:${opp}|^){1}${stone.repeat(3)} `)) || s.match(new RegExp(` ${stone.repeat(3)}(?:${opp}|$){1}`))) score += W.close3;

        // ì—´ë¦°2 / ë‹«íŒ2 (ì™„í™”)
        if (s.includes(` ${stone.repeat(2)} `)) score += W.open2;
        if (s.match(new RegExp(`(?:${opp}|^){1}${stone.repeat(2)} `)) || s.match(new RegExp(` ${stone.repeat(2)}(?:${opp}|$){1}`))) score += W.close2;

        return score;
      }

      function totalFor(stone) {
        let total = 0;
        // ê°€ë¡œ/ì„¸ë¡œ/ëŒ€ê°2ë°©í–¥ ë¼ì¸ë“¤ ì ìˆ˜ í•©
        for (let r = 0; r < SIZE; r++) {
          const row = Array(SIZE + 2).fill(' ').map((_,i)=> (i===0||i===SIZE+1)?' ': (board[r][i-1] || ' '));
          total += lineScore(row, stone);
        }
        for (let c = 0; c < SIZE; c++) {
          const col = Array(SIZE + 2).fill(' ').map((_,i)=> (i===0||i===SIZE+1)?' ': (board[i-1]?.[c] || ' '));
          total += lineScore(col, stone);
        }
        // diag â†˜
        for (let k = -(SIZE-1); k <= (SIZE-1); k++) {
          const diag = [];
          for (let r = 0; r < SIZE; r++) {
            const c = r - k;
            if (c < 0 || c >= SIZE) continue;
            diag.push(board[r][c] || ' ');
          }
          if (diag.length) {
            const d = [' ', ...diag, ' '];
            total += lineScore(d, stone);
          }
        }
        // diag â†—
        for (let k = 0; k <= 2*(SIZE-1); k++) {
          const diag = [];
          for (let r = 0; r < SIZE; r++) {
            const c = k - r;
            if (c < 0 || c >= SIZE) continue;
            diag.push(board[r][c] || ' ');
          }
          if (diag.length) {
            const d = [' ', ...diag, ' '];
            total += lineScore(d, stone);
          }
        }
        return total;
      }

      // ì¦‰ì‹œ ìŠ¹íŒ¨ í° ì ìˆ˜
      // (ì—¬ê¸°ì„œëŠ” íŒ¨í„´ ì ìˆ˜ì— fiveê°€ ë§¤ìš° ì»¤ì„œ ì¶©ë¶„)
      return totalFor(STONE[AI]) - totalFor(STONE[HUMAN]);
    }

    // --- Minimax with Alpha-Beta (depth=2)
    const MAX_DEPTH = 2; // ê³ ê¸‰ ê¸°ë³¸ê°’ (ëª¨ë°”ì¼ ì„±ëŠ¥ ê³ ë ¤)
    const MAX_BRANCH = 24; // í›„ë³´ ìƒí•œ

    function aiMoveAdvanced() {
      // 1) ì¦‰ì‹œ ìŠ¹ë¦¬ / ì°¨ë‹¨ ìš°ì„  (ë¹ ë¥¸ ì „ì²˜ë¦¬)
      const quick = findImmediateTactic(localBoard);
      if (quick) return placeAI(quick.r, quick.c);

      // 2) ì•ŒíŒŒâ€“ë² íƒ€ íƒìƒ‰
      const cand = generateCandidates(localBoard);
      // ì •ë ¬: íœ´ë¦¬ìŠ¤í‹± ë†’ì€ ìˆ˜ ìš°ì„ 
      cand.sort((a,b) => scoreCellHeuristic(localBoard, b.r, b.c) - scoreCellHeuristic(localBoard, a.r, a.c));
      const trimmed = cand.slice(0, MAX_BRANCH);

      let best = null;
      let alpha = -Infinity, beta = Infinity;

      for (const mv of trimmed) {
        localBoard[mv.r][mv.c] = STONE[AI];
        const val = minimax(localBoard, MAX_DEPTH-1, false, alpha, beta);
        localBoard[mv.r][mv.c] = "";

        if (best === null || val > best.score) {
          best = { r: mv.r, c: mv.c, score: val };
        }
        alpha = Math.max(alpha, val);
        if (alpha >= beta) break; // ê°€ì§€ì¹˜ê¸°
      }

      const choice = best || trimmed[0] || findFirstEmpty(localBoard) || { r: CENTER, c: CENTER };
      placeAI(choice.r, choice.c);
    }

    function minimax(board, depth, isMax, alpha, beta) {
      // ë‹¨ë§: í‰ê°€
      if (depth === 0) return evaluateBoard(board);

      // ì¦‰ìŠ¹/ì¦‰íŒ¨ ê°ì§€ ë¹ ë¥¸ ì»·
      const tactical = findImmediateTerminal(board);
      if (tactical !== null) return tactical;

      const cand = generateCandidates(board);
      cand.sort((a,b) => scoreCellHeuristic(board, b.r, b.c) - scoreCellHeuristic(board, a.r, a.c));
      const list = cand.slice(0, MAX_BRANCH);

      if (isMax) {
        let best = -Infinity;
        for (const mv of list) {
          board[mv.r][mv.c] = STONE[AI];
          const val = minimax(board, depth-1, false, alpha, beta);
          board[mv.r][mv.c] = "";
          best = Math.max(best, val);
          alpha = Math.max(alpha, val);
          if (alpha >= beta) break;
        }
        return best === -Infinity ? evaluateBoard(board) : best;
      } else {
        let best = Infinity;
        for (const mv of list) {
          board[mv.r][mv.c] = STONE[HUMAN];
          const val = minimax(board, depth-1, true, alpha, beta);
          board[mv.r][mv.c] = "";
          best = Math.min(best, val);
          beta = Math.min(beta, val);
          if (alpha >= beta) break;
        }
        return best === Infinity ? evaluateBoard(board) : best;
      }
    }

    // ì „ìˆ  ìš°ì„  íƒìƒ‰: ì¦‰ì‹œ ìŠ¹ë¦¬, ì¦‰ì‹œ ì°¨ë‹¨
    function findImmediateTactic(board) {
      // AI ì¦‰ìŠ¹
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
        if (board[r][c] !== "") continue;
        board[r][c] = STONE[AI];
        const win = checkWinGeneric(r, c, STONE[AI], board);
        board[r][c] = "";
        if (win) return { r, c };
      }
      // ì‚¬ëŒ ì¦‰ìŠ¹ ì°¨ë‹¨
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
        if (board[r][c] !== "") continue;
        board[r][c] = STONE[HUMAN];
        const win = checkWinGeneric(r, c, STONE[HUMAN], board);
        board[r][c] = "";
        if (win) return { r, c };
      }
      return null;
    }

    // í„°ë¯¸ë„ ì»·: ì¦‰ì‹œ ìŠ¹/ì¦‰ì‹œ íŒ¨ë©´ í° ì ìˆ˜ ë°˜í™˜
    function findImmediateTerminal(board) {
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
        if (board[r][c] !== "") continue;
        // AIê°€ ë‘ë©´ ìŠ¹ë¦¬?
        board[r][c] = STONE[AI];
        const aiWin = checkWinGeneric(r, c, STONE[AI], board);
        board[r][c] = "";
        if (aiWin) return 999999;

        // HUMANì´ ë‘ë©´ ìŠ¹ë¦¬?
        board[r][c] = STONE[HUMAN];
        const huWin = checkWinGeneric(r, c, STONE[HUMAN], board);
        board[r][c] = "";
        if (huWin) return -999999;
      }
      return null;
      // (ì´ í•¨ìˆ˜ëŠ” ë¹ ë¥¸ ì»· ìš©ë„ë¡œë§Œ ì‚¬ìš©)
    }

    function placeAI(r, c) {
      if (localBoard[r][c] !== "") {
        const fb = findFirstEmpty(localBoard);
        if (!fb) { alert("ë¬´ìŠ¹ë¶€!"); return setTimeout(()=>location.reload(), 1500); }
        r = fb.r; c = fb.c;
      }
      localBoard[r][c] = STONE[AI];
      placeStoneDOM(r, c, STONE[AI]);
      clearLastMoveHighlight();
      highlightLastMove(r, c, false);
      document.getElementById("place-sound").play().catch(()=>{});

      const winPos = checkWinGeneric(r, c, STONE[AI], localBoard);
      if (winPos) return finishSolo(winPos, false);

      localTurn = HUMAN;
      document.getElementById("turn").innerText = "ë‚´ ì°¨ë¡€";
    }

    function findFirstEmpty(board) {
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) if (board[r][c] === "") return { r, c };
      return null;
    }

    /* =========================
       ê³µìš© ì»¤ë°‹ ë¶„ê¸° / ì¢…ë£Œ
       ========================= */
    function commitMove() {
      if (gameMode === 'online') return commitMoveOnline();
      return commitMoveSolo();
    }

    async function endGame() {
      if (gameMode === 'online' && roomCode && roomCode !== 'SOLO') { await deleteRoom(roomCode); }
      location.reload();
    }

    /* =========================
       ë²„íŠ¼ ë°”ì¸ë”©
       ========================= */
    document.getElementById('createBtn').addEventListener('click', createRoom);
    document.getElementById('joinBtn').addEventListener('click', joinRoom);
    document.getElementById('soloBtn').addEventListener('click', startSolo);
    document.getElementById('end-button').addEventListener('click', endGame);
    document.getElementById('confirm-move').addEventListener('click', commitMove);
  </script>

  <!-- ëª¨ë‹¬ ì œì–´ -->
  <script>
    function closeModal() { document.getElementById('howToModal').style.display = 'none'; }
    window.onload = function () { document.getElementById('howToModal').style.display = 'block'; }
  </script>

  <!-- ì‚¬ìš© ë°©ë²• ëª¨ë‹¬ -->
  <div id="howToModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeModal()">&times;</span>
      <h2>ğŸ•¹ï¸ ì˜¤ëª© ëŒ€ì „ ê²Œì„ ë°©ë²•</h2>
      <ul style="text-align:left; font-size: 16px; line-height:1.6;">
        <li>1. <b>ë°© ìƒì„±í•˜ê¸°</b>: ì˜¨ë¼ì¸ ëŒ€ì „ìš© ë°©ì„ ë§Œë“­ë‹ˆë‹¤.</li>
        <li>2. <b>ë°© ì°¸ì—¬í•˜ê¸°</b>: 1ë¶„ ì´ë‚´ì— ìƒì„±ëœ ìµœì‹  ë°©ì— ì…ì¥í•©ë‹ˆë‹¤.</li>
        <li>3. <b>í˜¼ìí•˜ê¸°(ê³ ê¸‰)</b>: ì»´í“¨í„°ì™€ ì˜¤ëª©ì„ ë‘¡ë‹ˆë‹¤.</li>
        <li>4. í‘(âš«)ê³¼ ë°±(âšª)ì´ ë²ˆê°ˆì•„ ëŒì„ ë‘¡ë‹ˆë‹¤. í‘ì€ í•­ìƒ ë¨¼ì € ë‘¡ë‹ˆë‹¤.</li>
        <li>5. ê°€ë¡œ/ì„¸ë¡œ/ëŒ€ê°ì„ ìœ¼ë¡œ ê°™ì€ ìƒ‰ 5ê°œë¥¼ ë¨¼ì € ì—°ê²°í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</li>
        <li>6. ë§ˆì§€ë§‰ ë‘” ëŒì€ í…Œë‘ë¦¬ë¡œ í‘œì‹œë˜ê³ , ìŠ¹ë¦¬í•œ ëŒì€ ë°˜ì§ì…ë‹ˆë‹¤.</li>
      </ul>
    </div>
  </div>
</body>
</html>
