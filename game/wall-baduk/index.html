<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Wall-baduk (7x7 · 2인용 · 구역 점유)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    body {
      font-family: sans-serif;
      background: #f5f5f5;
      text-align: center;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    h1 { margin: 8px 0; }
    #info { margin: 6px 0 10px; font-weight: 600; }
    #board {
      display: grid;
      background: #fff;
      border: 2px solid #333;
      user-select: none;
      touch-action: manipulation;
    }
    .cell {
      box-sizing: border-box;
      border: 1px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .point { width: 42px; height: 42px; background: #fff; position: relative; cursor: pointer; }
    .piece { width: 80%; height: 80%; border-radius: 50%; pointer-events: none; }
    .h-wall { width: 42px; height: 15px; background: #fff; cursor: pointer; }
    .v-wall { width: 15px; height: 42px; background: #fff; cursor: pointer; }
    .blank  { width: 15px; height: 15px; background: #15326b; }

    /* 이동 가능 칸: 분홍색 */
    .movable { background: pink !important; }
    .placed  { }
    #panel { margin: 8px 0 14px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
    button { padding: 8px 12px; border: 1px solid #999; border-radius: 8px; background: #fafafa; cursor: pointer; }
    #turnLine { margin: 6px 0; font-size: 16px; }
    #scores { margin: 6px 0; font-size: 14px; }
  </style>
</head>
<body>
  <h1>Wall-baduk (벽바둑)</h1>
  <div id="info">초기 배치: P1, P2, P1, P2 순서로 각 2개씩 배치합니다.</div>
  <div id="panel">
    <button id="resetBtn">새로 시작</button>
    <button id="scoreBtn">현재 구역 계산</button>
  </div>
  <div id="turnLine">현재 턴: <span id="turnColor"></span></div>
  <div id="scores">P1: <span id="s1">0</span> / P2: <span id="s2">0</span></div>
  <div id="board"></div>

  <script>
    // ===== 보드 / 상태 =====
    const BOARD_POINTS = 7;                    // 7x7 점
    const GRID = BOARD_POINTS * 2 - 1;         // 내부 그리드 13x13
    const boardEl = document.getElementById('board');
    const infoEl  = document.getElementById('info');
    const turnEl  = document.getElementById('turnColor');
    const s1El    = document.getElementById('s1');
    const s2El    = document.getElementById('s2');
    const resetBtn= document.getElementById('resetBtn');
    const scoreBtn= document.getElementById('scoreBtn');

    const COLORS = ['#e74c3c', '#3498db'];     // P1 빨강, P2 파랑
    const PCOUNT = 2;

    let grid = [];                // DOM 셀 2D
    let current = 0;              // 0 or 1
    let phase   = 'place-initial';// 'place-initial' | 'place-extra' | 'move' | 'wall'
    let pieces  = [[], []];       // 각 플레이어 말 위치 배열 [{r,c}, ...]
    let selected = null;          // 선택된 말 위치 {r,c}

    // 배치 단계 제어
    const initialOrder = [0,1,0,1]; // 각 2개
    let initialIdx = 0;
    const extraOrder   = [0,1,1,0]; // 각 +1개 → 최종 4개씩
    let extraIdx = 0;

    // ===== 초기화 =====
    function init() {
      boardEl.innerHTML = '';
      boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
      boardEl.style.gridTemplateRows    = `repeat(${GRID}, auto)`;
      grid = Array.from({length: GRID}, () => Array(GRID).fill(null));

      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');

          if (r % 2 === 0 && c % 2 === 0) {
            cell.classList.add('point');
            cell.addEventListener('click', () => onPointClick(r, c));
          } else if (r % 2 === 1 && c % 2 === 0) {
            cell.classList.add('h-wall');
            cell.addEventListener('click', () => onWallClick(r, c));
          } else if (r % 2 === 0 && c % 2 === 1) {
            cell.classList.add('v-wall');
            cell.addEventListener('click', () => onWallClick(r, c));
          } else {
            cell.classList.add('blank');
          }

          boardEl.appendChild(cell);
          grid[r][c] = cell;
        }
      }

      current   = initialOrder[0];
      phase     = 'place-initial';
      pieces    = [[], []];
      selected  = null;
      initialIdx= 0;
      extraIdx  = 0;

      updateTurnText('말을 배치하세요');
      infoEl.textContent = '초기 배치: P1, P2, P1, P2 순서로 각 2개씩 배치합니다.';
      clearMovable();
      updateScores(); // 0,0
    }

    // ===== 공용 유틸 =====
    function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
    function isPoint(r,c){ return (r%2===0) && (c%2===0); }

    function updateTurnText(extra=''){
      turnEl.textContent = `Player ${current+1}`;
      turnEl.style.color = COLORS[current];
      if (extra) turnEl.textContent += ` — ${extra}`;
    }

    function clearMovable(){
      document.querySelectorAll('.movable').forEach(el => el.classList.remove('movable'));
    }

    // ===== 클릭 처리 =====
    function onPointClick(r,c){
      const cell = grid[r][c];
      if (!cell.classList.contains('point')) return;

      if (phase === 'place-initial'){
        if (cell.querySelector('.piece')) return;
        const who = initialOrder[initialIdx];
        placePiece(who, r, c);
        initialIdx++;

        if (initialIdx >= initialOrder.length){
          // 추가 배치 단계로
          phase = 'place-extra';
          current = extraOrder[0];
          infoEl.textContent = '추가 배치: P1, P2, P2, P1 순서로 각 1개씩 더 배치합니다.';
          updateTurnText('말을 배치하세요');
        } else {
          current = initialOrder[initialIdx];
          updateTurnText('말을 배치하세요');
        }
        return;
      }

      if (phase === 'place-extra'){
        if (cell.querySelector('.piece')) return;
        const who = extraOrder[extraIdx];
        placePiece(who, r, c);
        extraIdx++;

        if (extraIdx >= extraOrder.length){
          // 본 게임 시작
          startMovePhase(); // <-- 변경: 이동 가능성 체크 포함
        } else {
          current = extraOrder[extraIdx];
          updateTurnText('말을 배치하세요');
        }
        return;
      }

      if (phase === 'move'){
        const piece = cell.querySelector('.piece');

        // 선택 해제: 이미 선택된 같은 말 다시 클릭
        if (selected && selected.r === r && selected.c === c) {
          selected = null;
          clearMovable();
          updateTurnText('말을 이동하세요');
          return;
        }

        // 내 말 선택
        if (!selected && piece && +piece.dataset.player === current){
          selected = { r, c };
          const cnt = showMovableFrom(r,c); // 가능 칸 수 리턴
          if (cnt === 0){
            // 이 말은 이동 불가 → 전체 말 중 이동 가능 여부 확인
            selected = null;
            clearMovable();
            if (!anyMovableForPlayer(current)) {
              // 이동 가능한 말이 하나도 없으면 즉시 벽 놓기 단계로
              phase = 'wall';
              updateTurnText('이동 불가: 빈 벽을 하나 세우세요');
            } else {
              // 다른 말을 선택하도록 유도
              updateTurnText('이동 불가: 다른 말을 선택하세요');
            }
          }
          return;
        }

        // 이동 목적지
        if (selected && cell.classList.contains('movable')){
          moveSelectedTo(r,c);
          phase = 'wall';
          clearMovable();
          selected = null;
          updateTurnText('빈 벽을 하나 세우세요');
          return;
        }
      }

      // phase === 'wall'일 때 점 클릭은 무시
    }

    function onWallClick(r,c){
      // 벽은 'wall' 단계에서만 설치
      if (phase !== 'wall') return;

      const cell = grid[r][c];
      const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
      if (!isWall) return;
      if (cell.classList.contains('placed')) return;

      // 벽 설치
      cell.classList.add('placed');
      cell.style.background = COLORS[current];

      // 벽 설치 후 구역 계산 & 종료 체크
      const end = checkGameEndAndScore();
      if (end){
        showWinner();
        return;
      }

      // 턴 교대 → 이동 단계 시작 (이동 불가면 자동으로 벽 단계로 전환)
      current = 1 - current;
      startMovePhase();
    }

    // ===== 단계 전환 보조 =====
    function startMovePhase(){
      phase = 'move';
      selected = null;
      clearMovable();
      if (!anyMovableForPlayer(current)){
        // 이동할 수 있는 말이 하나도 없으면 즉시 벽 설치로
        phase = 'wall';
        updateTurnText('이동 불가: 빈 벽을 하나 세우세요');
      } else {
        updateTurnText('말을 이동하세요');
      }
    }

    function anyMovableForPlayer(player){
      // 플레이어의 모든 말에 대해 이동 가능 칸이 하나라도 있으면 true
      for (const p of pieces[player]){
        if (countMovableFrom(p.r, p.c) > 0) return true;
      }
      return false;
    }

    // ===== 말 배치/이동 =====
    function placePiece(player, r, c){
      const cell = grid[r][c];
      const p = document.createElement('div');
      p.classList.add('piece');
      p.style.background = COLORS[player];
      p.dataset.player = String(player);
      cell.appendChild(p);
      pieces[player].push({r,c});
    }

    function moveSelectedTo(nr,nc){
      const idx = pieces[current].findIndex(p => p.r===selected.r && p.c===selected.c);
      if (idx < 0) return;

      const fromCell = grid[selected.r][selected.c];
      const toCell   = grid[nr][nc];
      const pieceEl  = fromCell.querySelector('.piece');
      if (!pieceEl) return;

      fromCell.removeChild(pieceEl);
      toCell.appendChild(pieceEl);
      pieces[current][idx] = { r:nr, c:nc };
    }

    // 인접 점으로 갈 수 있는 곳(1칸): 벽/점 검증
    function neighborsReachable(r,c){
      const dirs = [
        {dr:-2, dc:0}, {dr:2, dc:0}, {dr:0, dc:-2}, {dr:0, dc:2}
      ];
      const out = [];
      for (const {dr,dc} of dirs){
        const nr = r+dr, nc=c+dc;
        if (!inBounds(nr,nc) || !isPoint(nr,nc)) continue;
        // 중간 벽 위치
        const wr = r + dr/2, wc = c + dc/2;
        if (!inBounds(wr,wc)) continue;
        const wall = grid[wr][wc];
        const isWallPos = wall.classList.contains('h-wall') || wall.classList.contains('v-wall');
        if (!isWallPos) continue;
        if (wall.classList.contains('placed')) continue; // 벽 있으면 막힘
        if (grid[nr][nc].querySelector('.piece')) continue; // 말 있으면 불가
        out.push({nr,nc});
      }
      return out;
    }

    // 1칸 또는 1칸+1칸 (직각 가능, 경로 중간도 비어있어야 함)
    function showMovableFrom(sr,sc){
      clearMovable();
      return markMovable(sr,sc);
    }

    function countMovableFrom(sr,sc){
      return markMovable(sr,sc, /*mark*/ false);
    }

    // BFS 깊이2, mark=true면 .movable 표시, false면 개수만 카운트
    function markMovable(sr,sc, mark=true){
      const visited = Array.from({length:GRID},()=>Array(GRID).fill(false));
      const q = [];
      visited[sr][sc] = true;
      q.push({r:sr,c:sc,d:0});
      let cnt = 0;

      while(q.length){
        const {r,c,d} = q.shift();

        if (d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
          if (mark) grid[r][c].classList.add('movable');
          cnt++;
        }
        if (d===2) continue;

        for (const {nr,nc} of neighborsReachable(r,c)){
          if (!visited[nr][nc]){
            visited[nr][nc] = true;
            q.push({r:nr,c:nc,d:d+1});
          }
        }
      }
      return cnt;
    }

    // ===== 구역 계산 & 종료 =====
    function checkGameEndAndScore(){
      const { regions, hasMixed } = computeRegions();
      const scores = [0,0];

      for (const reg of regions){
        if (reg.players.size === 1){
          const owner = [...reg.players][0];
          scores[owner] += reg.points.length; // 구역의 점 개수 합산
        }
      }
      s1El.textContent = scores[0];
      s2El.textContent = scores[1];

      // 혼재 구역(두 플레이어가 같은 구역에 공존)이 하나도 없으면 종료
      return !hasMixed;
    }

    function updateScores(){
      const end = checkGameEndAndScore();
      if (end && phase!=='place-initial' && phase!=='place-extra'){
        showWinner();
      }
    }

    function showWinner(){
      const p1 = parseInt(s1El.textContent,10);
      const p2 = parseInt(s2El.textContent,10);
      let msg = `게임 종료!\nP1: ${p1} / P2: ${p2}\n`;
      if (p1>p2) msg += '승자: Player 1';
      else if (p2>p1) msg += '승자: Player 2';
      else msg += '무승부';
      alert(msg);
      // init(); // 자동 재시작을 원하면 주석 해제
    }

    // 연결 컴포넌트(구역) 계산: 점들만 대상으로, 벽이 없는 간선만 연결
    function computeRegions(){
      const visited = Array.from({length:GRID},()=>Array(GRID).fill(false));
      const regions = [];
      let hasMixed = false;

      for (let r=0;r<GRID;r+=2){
        for (let c=0;c<GRID;c+=2){
          if (visited[r][c]) continue;

          // BFS로 컴포넌트 수집
          const queue = [{r,c}];
          visited[r][c] = true;
          const pts = [];
          const presentPlayers = new Set();

          while(queue.length){
            const cur = queue.shift();
            pts.push(cur);

            const piece = grid[cur.r][cur.c].querySelector('.piece');
            if (piece){
              presentPlayers.add(+piece.dataset.player);
            }

            for (const {nr,nc} of neighborsByWall(cur.r,cur.c)){
              if (!visited[nr][nc]){
                visited[nr][nc] = true;
                queue.push({r:nr,c:nc});
              }
            }
          }

          if (presentPlayers.size >= 2) hasMixed = true;
          regions.push({ points: pts, players: presentPlayers });
        }
      }
      return { regions, hasMixed };
    }

    // 벽 유무로 연결 판단(점 기준 상하좌우 1칸만)
    function neighborsByWall(r,c){
      const dirs = [
        {dr:-2, dc:0}, {dr:2, dc:0}, {dr:0, dc:-2}, {dr:0, dc:2}
      ];
      const out=[];
      for (const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc;
        if (!inBounds(nr,nc) || !isPoint(nr,nc)) continue;
        const wr = r+dr/2, wc=c+dc/2;
        const wall = grid[wr][wc];
        const isWallPos = wall.classList.contains('h-wall') || wall.classList.contains('v-wall');
        if (!isWallPos) continue;
        if (wall.classList.contains('placed')) continue; // 벽 있으면 연결 안 됨
        out.push({nr,nc});
      }
      return out;
    }

    // ===== 이벤트 =====
    resetBtn.addEventListener('click', init);
    scoreBtn.addEventListener('click', updateScores);

    init();
  </script>
</body>
</html>
