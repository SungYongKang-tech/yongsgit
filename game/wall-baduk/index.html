<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Wall-baduk (7x7 Â· 2ì¸ìš© Â· ê³ ì • ì´ˆê¸°ë°°ì¹˜)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root { --bar-h: 64px; }
    body {
      font-family: sans-serif;
      background: #f5f5f5;
      text-align: center;
      margin: 0;
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto auto auto 1fr var(--bar-h);
    }
    h1 { margin: 8px 0; }
    #panel { margin: 6px 0; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; align-items:center; }
    button {
      padding: 10px 14px; border: 1px solid #999; border-radius: 10px;
      background: #fff; cursor: pointer; font-size: 15px;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }
    #turnLine { margin: 4px 0; font-size: 16px; display:flex; gap:8px; justify-content:center; align-items:center; }
    #turnColor { font-weight:700; }
    #timer { font-variant-numeric: tabular-nums; padding:2px 6px; border:1px solid #ddd; border-radius:8px; background:#fff; }
    #scores { margin: 4px 0 6px; font-size: 14px; }

    /* ì˜¤ë””ì˜¤ ì»¨íŠ¸ë¡¤ */
    .audio-wrap {
      display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #ddd; border-radius:10px; background:#fff;
    }
    #volSlider { width: 160px; }

    /* ë³´ë“œ */
    #wrap {
      display:flex; justify-content:center; align-items:flex-start; padding:10px;
      overflow:auto;
    }
    #board {
      display: grid;
      background: #fff;
      border: 2px solid #333;
      user-select: none;
      touch-action: manipulation;
    }
    .cell {
      box-sizing: border-box;
      border: 1px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .point { width: 42px; height: 42px; background: #fff; position: relative; cursor: pointer; }
    .piece { width: 80%; height: 80%; border-radius: 50%; pointer-events: none; }
    .h-wall { width: 42px; height: 15px; background: #fff; cursor: pointer; }
    .v-wall { width: 15px; height: 42px; background: #fff; cursor: pointer; }
    .blank  { width: 15px; height: 15px; background: #15326b; }

    /* ì´ë™ ê°€ëŠ¥ ì¹¸ */
    .movable { background: #d0d0d0 !important; }

    /* ìµœì¢… êµ¬ì—­ ì±„ìƒ‰(ê²Œì„ ì¢…ë£Œ í›„) */
    .final-p1-region { background: #ffd6e7 !important; } /* ë¶„í™ */
    .final-p2-region { background: #d6ecff !important; } /* í•˜ëŠ˜ìƒ‰ */

    /* í•˜ë‹¨ ê³ ì • ë°”(ëª¨ë°”ì¼ ì¹œí™”) */
    #bottomBar {
      position: sticky; bottom: 0; left: 0; right: 0; height: var(--bar-h);
      background: #ffffffcc; backdrop-filter: blur(6px);
      border-top: 1px solid #ddd;
      display:flex; gap:10px; align-items:center; justify-content:center; padding: 8px 12px;
    }
    #skipWallBtn {
      flex:1; max-width: 520px;
      height: 44px; border-radius: 12px; font-weight: 700;
      background: #ffd6e7; border: 1px solid #e7a3bd;
    }

    /* ë„ì›€ë§ ëª¨ë‹¬ */
    #helpOverlay {
      position: fixed; inset: 0; background: rgba(0,0,0,.45);
      display: none; align-items: center; justify-content: center; z-index: 9999;
      padding: 16px;
    }
    #helpCard {
      width: 100%; max-width: 560px; background: #fff; border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.2); text-align: left; overflow: hidden;
    }
    #helpHeader {
      padding: 14px 18px; background: #222; color: #fff; font-weight: 800;
    }
    #helpBody {
      padding: 14px 18px; color: #222; line-height: 1.5; font-size: 15px;
    }
    #helpBody ul {margin: 6px 0 0 8px; padding-left: 12px;}
    #helpBody ul ul {margin-left: 6px; padding-left: 10px;}
    #helpBody li { margin: 4px 0; }
    #helpFooter {
      display:flex; gap:10px; justify-content:flex-end; padding: 12px 16px; background: #fafafa;
    }
    .helpBtn {
      padding: 10px 14px; border: 1px solid #ccc; border-radius: 10px; background: #fff; cursor: pointer;
    }

    @media (max-width: 520px){
      .point { width: 36px; height: 36px; }
      .h-wall { width: 36px; height: 14px; }
      .v-wall { width: 14px; height: 36px; }
      #volSlider { width: 120px; }
    }

    /* ë ˆì´ì•„ì›ƒ íƒ€ì´íŠ¸ + ë°”ë‹¥ ë²„íŠ¼ ì§§ê²Œ */
    body { grid-template-rows: auto auto auto auto auto auto auto !important; }
    #turnLine { margin: 2px 0 !important; }
    #scores   { margin: 0 0 2px !important; }
    #wrap     { padding: 0 10px 6px !important; }
    #bottomBar { height: auto !important; padding: 6px 12px !important; }
    #skipWallBtn {
      flex: 0 0 auto !important;
      width: min(340px, 92vw) !important;
      height: 40px !important;
    }
  </style>
</head>
<body>
  <h1>Wall-baduk (ë²½ë°”ë‘‘)</h1>

  <div id="panel">
    <button id="resetBtn">ìƒˆë¡œ ì‹œì‘</button>
    <button id="helpBtn">ë„ì›€ë§</button>

    <div class="audio-wrap" title="íš¨ê³¼ìŒ ë³¼ë¥¨">
      <button id="muteBtn" aria-pressed="false">ğŸ”Š</button>
      <input id="volSlider" type="range" min="0" max="1" step="0.05" />
      <span id="volVal" style="min-width:36px; display:inline-block; text-align:right;">100%</span>
    </div>
  </div>

  <div id="turnLine">
    í˜„ì¬ í„´: <span id="turnColor"></span>
    <span id="timer" aria-live="polite"></span>
  </div>
  <div id="scores">P1(ë¹¨ê°•): <span id="s1">0</span> / P2(íŒŒë‘): <span id="s2">0</span></div>

  <div id="wrap"><div id="board"></div></div>

  <div id="bottomBar">
    <button id="skipWallBtn" disabled>ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜</button>
  </div>

  <!-- ì„¤ëª… íŒì—… -->
  <div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div id="helpCard">
      <div id="helpHeader"><span id="helpTitle">ê²Œì„ ì„¤ëª…</span></div>
      <div id="helpBody">
        <ul>
          <li><strong>ëª©í‘œ</strong>: ë²½ìœ¼ë¡œ ë³´ë“œë¥¼ ë‚˜ëˆ  <strong>í•œìª½ë§Œ í¬í•¨ëœ êµ¬ì—­</strong>ì„ ë§ì´ ë§Œë“¤ê¸°.</li>
          <li><strong>í„´ ì§„í–‰</strong>: ë‚´ ë§ í•˜ë‚˜ ì„ íƒ â†’ <strong>ì´ë™</strong>(ë˜ëŠ” ìƒëµ) â†’ <strong>ë²½ 1ê°œ ì„¤ì¹˜</strong> â†’ ìƒëŒ€ í„´.</li>
          <li><strong>ì´ë™ ê·œì¹™</strong>:
            <ul>
              <li>ìƒí•˜ì¢Œìš° <strong>1ì¹¸</strong> ë˜ëŠ” <strong>1ì¹¸+1ì¹¸</strong>(ì§ê° ê°€ëŠ¥).</li>
              <li><strong>ë²½ í†µê³¼ ë¶ˆê°€</strong>, ë„ì°© ì¹¸ì— ë§ ìˆìœ¼ë©´ ë¶ˆê°€.</li>
              <li>ì´ë™ ê°€ëŠ¥ ì¹¸ì€ <strong>ì§™ì€ íšŒìƒ‰</strong>ìœ¼ë¡œ í‘œì‹œ.</li>
              <li>ê°ˆ ê³³ì´ ì—†ìœ¼ë©´ <strong>ì´ë™ ì—†ì´ ë°”ë¡œ ë²½ ì„¤ì¹˜</strong>.</li>
            </ul>
          </li>
          <li><strong>ë²½ ì„¤ì¹˜</strong>: ë¹ˆ ê°€ë¡œ/ì„¸ë¡œ ë²½ ì¹¸ì— <strong>1ê°œ</strong> ì„¤ì¹˜, <strong>ì œê±° ë¶ˆê°€</strong>.</li>
          <li><strong>êµ¬ì—­ íŒë‹¨</strong>:
            <ul>
              <li>ë²½ ì—†ì´ ì´ì–´ì§„ ì ë“¤ì˜ ì§‘í•© = <strong>êµ¬ì—­</strong>.</li>
              <li><strong>í•œ í”Œë ˆì´ì–´ì˜ ë§ë§Œ</strong> ìˆëŠ” êµ¬ì—­ë§Œ ê·¸ í”Œë ˆì´ì–´ ì†Œìœ .</li>
              <li>ë‘ í”Œë ˆì´ì–´ ë§ì´ í•¨ê»˜ ìˆìœ¼ë©´ <strong>ë¬´ì£¼ì§€</strong>.</li>
            </ul>
          </li>
          <li><strong>ì¢…ë£Œ & ìŠ¹ë¦¬</strong>: ëª¨ë“  êµ¬ì—­ì—ì„œ <strong>í˜¼ì¬ êµ¬ì—­ì´ ì‚¬ë¼ì§€ë©´</strong> ì¦‰ì‹œ ì¢…ë£Œ â†’ ê°ì <strong>ì†Œìœ  êµ¬ì—­ì˜ ì  ê°œìˆ˜ í•©</strong> ë¹„êµë¡œ ìŠ¹ë¦¬ ê²°ì •.</li>
        </ul>
      </div>
      <div id="helpFooter">
        <button class="helpBtn" id="helpCloseBtn">ì‹œì‘í•˜ê¸°</button>
      </div>
    </div>
  </div>

  <script>
    // ===== ë³´ë“œ / ìƒíƒœ =====
    const BOARD_POINTS = 7;                    // 7x7 ì 
    const GRID = BOARD_POINTS * 2 - 1;         // 13x13 ë‚´ë¶€ ê·¸ë¦¬ë“œ
    const boardEl = document.getElementById('board');
    const turnEl  = document.getElementById('turnColor');
    const timerEl = document.getElementById('timer');
    const s1El    = document.getElementById('s1');
    const s2El    = document.getElementById('s2');
    const resetBtn= document.getElementById('resetBtn');
    const skipWallBtn = document.getElementById('skipWallBtn');
    const helpBtn = document.getElementById('helpBtn');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpCloseBtn = document.getElementById('helpCloseBtn');

    // ì˜¤ë””ì˜¤ ì»¨íŠ¸ë¡¤
    const volSlider = document.getElementById('volSlider');
    const volVal = document.getElementById('volVal');
    const muteBtn = document.getElementById('muteBtn');

    const COLORS = ['#e74c3c', '#3498db'];     // P1 ë¹¨ê°•, P2 íŒŒë‘

    // ì‚¬ìš´ë“œ
    const sndMove = new Audio('mal.mp3');
    const sndWall = new Audio('wall.mp3');
    const sndWin  = new Audio('win.mp3');
    const allSounds = [sndMove, sndWall, sndWin];

    let grid = [];                // DOM ì…€ 2D
    let current = 0;              // 0 or 1
    let phase   = 'place-extra';  // 'place-extra' | 'move' | 'wall'
    let pieces  = [[], []];       // ê° í”Œë ˆì´ì–´ ë§ ìœ„ì¹˜ ë°°ì—´ [{r,c}, ...]
    let selected = null;          // ì„ íƒëœ ë§ ìœ„ì¹˜ {r,c}

    // ì¶”ê°€ ë°°ì¹˜ ìˆœì„œ: P1, P2, P2, P1
    const extraOrder = [0,1,1,0];
    let extraIdx = 0;

    // íƒ€ì´ë¨¸: ì´ë™ 60ì´ˆ, ë²½ 10ì´ˆ
    const MOVE_SECONDS = 60;
    const WALL_SECONDS = 10;
    let turnTimerId = null;
    let turnDeadline = 0; // epoch ms

    function playSafe(audio){
      try { audio.currentTime = 0; audio.play().catch(()=>{}); } catch(e){}
    }

    // ===== ì´ˆê¸°í™” =====
    function init() {
      clearTurnTimer();
      timerEl.textContent = '';

      boardEl.innerHTML = '';
      boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
      boardEl.style.gridTemplateRows    = `repeat(${GRID}, auto)`;
      grid = Array.from({length: GRID}, () => Array(GRID).fill(null));

      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');

          if (r % 2 === 0 && c % 2 === 0) {
            cell.classList.add('point');
            cell.addEventListener('click', () => onPointClick(r, c));
          } else if (r % 2 === 1 && c % 2 === 0) {
            cell.classList.add('h-wall');
            cell.addEventListener('click', () => onWallClick(r, c));
          } else if (r % 2 === 0 && c % 2 === 1) {
            cell.classList.add('v-wall');
            cell.addEventListener('click', () => onWallClick(r, c));
          } else {
            cell.classList.add('blank');
          }

          boardEl.appendChild(cell);
          grid[r][c] = cell;
        }
      }

      clearFinalPaint();

      // 1-based ì  ì¢Œí‘œ â†’ ë‚´ë¶€ ê·¸ë¦¬ë“œ ì¢Œí‘œ
      const pt = p => (p - 1) * 2;

      // === ì´ˆê¸° ê³ ì • ë°°ì¹˜ ===
      pieces = [[],[]];
      placePiece(0, pt(2), pt(2)); // P1
      placePiece(0, pt(6), pt(6)); // P1
      placePiece(1, pt(6), pt(2)); // P2
      placePiece(1, pt(2), pt(6)); // P2

      // ì¶”ê°€ ë°°ì¹˜ ë‹¨ê³„ë¡œ
      extraIdx  = 0;
      phase     = 'place-extra';
      current   = extraOrder[0];
      selected  = null;

      updateTurnText('ë§ì„ ë°°ì¹˜í•˜ì„¸ìš”');
      clearMovable();
      updateScores();
      refreshSkipWallButton();

      // ì˜¤ë””ì˜¤ ì„¤ì • ë³µì›
      restoreAudioPrefs();

      openHelp(); // ì„¤ëª… íŒì—…
    }

    // ===== ê³µìš© ìœ í‹¸ =====
    function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
    function isPoint(r,c){ return (r%2===0) && (c%2===0); }

    function updateTurnText(extra=''){
      turnEl.textContent = `Player ${current+1}`;
      turnEl.style.color = COLORS[current];
      if (extra) turnEl.textContent += ` â€” ${extra}`;
    }

    function clearMovable(){
      document.querySelectorAll('.movable').forEach(el => el.classList.remove('movable'));
    }

    function clearFinalPaint(){
      document.querySelectorAll('.final-p1-region, .final-p2-region').forEach(el=>{
        el.classList.remove('final-p1-region','final-p2-region');
        if (el.classList.contains('point')) el.style.background = '#fff';
      });
    }

    function refreshSkipWallButton() {
      skipWallBtn.disabled = (phase !== 'move');
    }

    // ===== ë„ì›€ë§ ëª¨ë‹¬ =====
    function openHelp(){ helpOverlay.style.display = 'flex'; }
    function closeHelp(){ helpOverlay.style.display = 'none'; }
    helpBtn.addEventListener('click', openHelp);
    helpCloseBtn.addEventListener('click', closeHelp);
    helpOverlay.addEventListener('click', (e) => {
      if (e.target === helpOverlay) closeHelp();
    });

    // ===== í´ë¦­ ì²˜ë¦¬ =====
    function onPointClick(r,c){
      const cell = grid[r][c];
      if (!cell.classList.contains('point')) return;

      if (phase === 'place-extra'){
        if (cell.querySelector('.piece')) return;
        const who = extraOrder[extraIdx];
        placePiece(who, r, c);
        extraIdx++;

        if (extraIdx >= extraOrder.length){
          // ë³¸ ê²Œì„ ì‹œì‘
          startMovePhase(true); // ì´ë™ 60ì´ˆ íƒ€ì´ë¨¸ ì‹œì‘
        } else {
          current = extraOrder[extraIdx];
          updateTurnText('ë§ì„ ë°°ì¹˜í•˜ì„¸ìš”');
        }
        return;
      }

      if (phase === 'move'){
        const piece = cell.querySelector('.piece');

        // ì„ íƒ í•´ì œ: ê°™ì€ ë§ ì¬í´ë¦­
        if (selected && selected.r === r && selected.c === c) {
          selected = null;
          clearMovable();
          updateTurnText('ë§ì„ ì´ë™í•˜ì„¸ìš”');
          return;
        }

        // ë‚´ ë§ ì„ íƒ
        if (!selected && piece && +piece.dataset.player === current){
          selected = { r, c };
          const cnt = showMovableFrom(r,c); // ê°€ëŠ¥ ì¹¸ ìˆ˜
          if (cnt === 0){
            selected = null;
            clearMovable();
            if (!anyMovableForPlayer(current)) {
              updateTurnText('ì´ë™ ë¶ˆê°€: [ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜] ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”');
            } else {
              updateTurnText('ì´ë™ ë¶ˆê°€: ë‹¤ë¥¸ ë§ì„ ì„ íƒí•˜ì„¸ìš”');
            }
          }
          return;
        }

        // ì´ë™ ëª©ì ì§€
        if (selected && cell.classList.contains('movable')){
          moveSelectedTo(r,c);
          playSafe(sndMove);
          // ë²½ ë‹¨ê³„ë¡œ ì „í™˜ + 10ì´ˆ íƒ€ì´ë¨¸
          startWallPhase();
          return;
        }
      }
      // phase === 'wall'ì¼ ë•Œ ì  í´ë¦­ì€ ë¬´ì‹œ
    }

    function onWallClick(r,c){
      if (phase !== 'wall') return;
      const cell = grid[r][c];
      const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
      if (!isWall) return;
      if (cell.classList.contains('placed')) return;

      // ë²½ ì„¤ì¹˜
      placeWall(cell);

      // ë²½ ì„¤ì¹˜ í›„ êµ¬ì—­ ê³„ì‚° & ì¢…ë£Œ ì²´í¬
      const end = checkGameEndAndScore();
      if (end){
        clearTurnTimer();
        playSafe(sndWin);
        setTimeout(showWinnerWithPaint, 50);
        return;
      }

      // í„´ êµëŒ€ â†’ ì´ë™ ë‹¨ê³„(60ì´ˆ)
      current = 1 - current;
      startMovePhase(true);
    }

    // ===== í•˜ë‹¨ ë²„íŠ¼: ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜ =====
    skipWallBtn.addEventListener('click', () => {
      if (phase !== 'move') return;
      selected = null;
      clearMovable();
      // ë°”ë¡œ ë²½ ë‹¨ê³„ + 10ì´ˆ íƒ€ì´ë¨¸
      startWallPhase(true);
    });

    // ===== ë‹¨ê³„ ì „í™˜ =====
    function startMovePhase(startTimer=false){
      phase = 'move';
      selected = null;
      clearMovable();
      refreshSkipWallButton();
      if (!anyMovableForPlayer(current)){
        updateTurnText('ì´ë™ ë¶ˆê°€: [ì´ë™ ì—†ì´ ë²½ ì„¤ì¹˜] ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”');
      } else {
        updateTurnText('ë§ì„ ì´ë™í•˜ì„¸ìš”');
      }
      if (startTimer) startTurnTimer(MOVE_SECONDS);
    }

    function startWallPhase(fromSkip=false){
      phase = 'wall';
      selected = null;
      clearMovable();
      updateTurnText(fromSkip ? 'ì´ë™ ì—†ì´: ë¹ˆ ë²½ì„ í•˜ë‚˜ ì„¸ìš°ì„¸ìš”' : 'ë¹ˆ ë²½ì„ í•˜ë‚˜ ì„¸ìš°ì„¸ìš”');
      refreshSkipWallButton(); // ë²½ ë‹¨ê³„ì—ì„œëŠ” ë¹„í™œì„±
      startTurnTimer(WALL_SECONDS); // ë²½ë§Œ ë³„ë„ 10ì´ˆ
    }

    function anyMovableForPlayer(player){
      for (const p of pieces[player]){
        if (countMovableFrom(p.r, p.c) > 0) return true;
      }
      return false;
    }

    // ===== ë§ ë°°ì¹˜/ì´ë™ =====
    function placePiece(player, r, c){
      const cell = grid[r][c];
      const p = document.createElement('div');
      p.classList.add('piece');
      p.style.background = COLORS[player];
      p.dataset.player = String(player);
      cell.appendChild(p);
      pieces[player].push({r,c});
    }

    function moveSelectedTo(nr,nc){
      const idx = pieces[current].findIndex(p => p.r===selected.r && p.c===selected.c);
      if (idx < 0) return;

      const fromCell = grid[selected.r][selected.c];
      const toCell   = grid[nr][nc];
      const pieceEl  = fromCell.querySelector('.piece');
      if (!pieceEl) return;

      fromCell.removeChild(pieceEl);
      toCell.appendChild(pieceEl);
      pieces[current][idx] = { r:nr, c:nc };
    }

    // ===== ë²½ ì„¤ì¹˜ ê³µí†µ í•¨ìˆ˜ =====
    function placeWall(cell){
      cell.classList.add('placed');
      cell.style.background = COLORS[current];
      playSafe(sndWall);
    }

    // ë¹ˆ ë²½ ëœë¤ ìë™ ì„¤ì¹˜
    function autoPlaceRandomWall(){
      const candidates = [];
      for (let r=0; r<GRID; r++){
        for (let c=0; c<GRID; c++){
          const cell = grid[r][c];
          if (!cell) continue;
          const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
          if (isWall && !cell.classList.contains('placed')) candidates.push(cell);
        }
      }
      if (candidates.length === 0) return false;
      const pick = candidates[Math.floor(Math.random()*candidates.length)];
      placeWall(pick);
      return true;
    }

    // ì¸ì ‘ ì ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ê³³(1ì¹¸)
    function neighborsReachable(r,c){
      const dirs = [
        {dr:-2, dc:0}, {dr:2, dc:0}, {dr:0, dc:-2}, {dr:0, dc:2}
      ];
      const out = [];
      for (const {dr,dc} of dirs){
        const nr = r+dr, nc=c+dc;
        if (!inBounds(nr,nc) || !isPoint(nr,nc)) continue;
        const wr = r + dr/2, wc = c + dc/2;
        if (!inBounds(wr,wc)) continue;
        const wall = grid[wr][wc];
        const isWallPos = wall.classList.contains('h-wall') || wall.classList.contains('v-wall');
        if (!isWallPos) continue;
        if (wall.classList.contains('placed')) continue; // ë²½ ìˆìœ¼ë©´ ë§‰í˜
        if (grid[nr][nc].querySelector('.piece')) continue; // ë§ ìˆìœ¼ë©´ ë¶ˆê°€
        out.push({nr,nc});
      }
      return out;
    }

    // 1ì¹¸ ë˜ëŠ” 1ì¹¸+1ì¹¸ (ì§ê° ê°€ëŠ¥, ê²½ìœ ì ë„ ë¹„ì–´ìˆì–´ì•¼ í•¨)
    function showMovableFrom(sr,sc){
      clearMovable();
      return markMovable(sr,sc);
    }
    function countMovableFrom(sr,sc){
      return markMovable(sr,sc,false);
    }
    // BFS ê¹Šì´2, mark=trueë©´ .movable í‘œì‹œ, falseë©´ ê°œìˆ˜ë§Œ
    function markMovable(sr,sc,mark=true){
      const visited = Array.from({length:GRID},()=>Array(GRID).fill(false));
      const q = [];
      visited[sr][sc] = true;
      q.push({r:sr,c:sc,d:0});
      let cnt = 0;

      while(q.length){
        const {r,c,d} = q.shift();
        if (d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
          if (mark) grid[r][c].classList.add('movable');
          cnt++;
        }
        if (d===2) continue;
        for (const {nr,nc} of neighborsReachable(r,c)){
          if (!visited[nr][nc]){
            visited[nr][nc] = true;
            q.push({r:nr,c:nc,d:d+1});
          }
        }
      }
      return cnt;
    }

    // ===== êµ¬ì—­ ê³„ì‚° & ì¢…ë£Œ =====
    function checkGameEndAndScore(){
      const { regions, hasMixed } = computeRegions();
      const scores = [0,0];
      for (const reg of regions){
        if (reg.players.size === 1){
          const owner = [...reg.players][0];
          scores[owner] += reg.points.length; // êµ¬ì—­ì˜ ì  ê°œìˆ˜ í•©ì‚°
        }
      }
      s1El.textContent = scores[0];
      s2El.textContent = scores[1];
      return !hasMixed; // í˜¼ì¬ êµ¬ì—­ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ ì¢…ë£Œ
    }

    function updateScores(){
      const end = checkGameEndAndScore();
      if (end && phase!=='place-extra'){
        clearTurnTimer();
        playSafe(sndWin);
        setTimeout(showWinnerWithPaint, 50);
      }
    }

    // ìµœì¢… ì¹ í•˜ê¸° + ìŠ¹ì ì•Œë¦¼
    function showWinnerWithPaint(){
      fillFinalRegions();
      const p1 = parseInt(s1El.textContent,10);
      const p2 = parseInt(s2El.textContent,10);
      let msg = `ê²Œì„ ì¢…ë£Œ!\nP1(ë¹¨ê°•): ${p1} / P2(íŒŒë‘): ${p2}\n`;
      if (p1>p2) msg += 'ìŠ¹ì: P1(ë¹¨ê°•)';
      else if (p2>p1) msg += 'ìŠ¹ì: P2(íŒŒë‘)';
      else msg += 'ë¬´ìŠ¹ë¶€';
      alert(msg);
    }

    // ì—°ê²° ì»´í¬ë„ŒíŠ¸(êµ¬ì—­) ê³„ì‚°
    function computeRegions(){
      const visited = Array.from({length:GRID},()=>Array(GRID).fill(false));
      const regions = [];
      let hasMixed = false;

      for (let r=0;r<GRID;r+=2){
        for (let c=0;c<GRID;c+=2){
          if (visited[r][c]) continue;
          const queue = [{r,c}];
          visited[r][c] = true;
          const pts = [];
          const presentPlayers = new Set();

          while(queue.length){
            const cur = queue.shift();
            pts.push(cur);
            const piece = grid[cur.r][cur.c].querySelector('.piece');
            if (piece){ presentPlayers.add(+piece.dataset.player); }
            for (const {nr,nc} of neighborsByWall(cur.r,cur.c)){
              if (!visited[nr][nc]){
                visited[nr][nc] = true;
                queue.push({r:nr,c:nc});
              }
            }
          }
          if (presentPlayers.size >= 2) hasMixed = true;
          regions.push({ points: pts, players: presentPlayers });
        }
      }
      return { regions, hasMixed };
    }

    function neighborsByWall(r,c){
      const dirs = [{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}];
      const out=[];
      for (const {dr,dc} of dirs){
        const nr=r+dr, nc=c+dc;
        if (!inBounds(nr,nc) || !isPoint(nr,nc)) continue;
        const wr = r+dr/2, wc=c+dc/2;
        const wall = grid[wr][wc];
        const isWallPos = wall.classList.contains('h-wall') || wall.classList.contains('v-wall');
        if (!isWallPos) continue;
        if (wall.classList.contains('placed')) continue; // ë²½ ìˆìœ¼ë©´ ì—°ê²° ë§‰í˜
        out.push({nr,nc});
      }
      return out;
    }

    function fillFinalRegions(){
      clearFinalPaint();
      const { regions } = computeRegions();
      for (const reg of regions){
        if (reg.players.size !== 1) continue; // í˜¼ì¬/ë¬´ì£¼ì§€ëŠ” ì¹ í•˜ì§€ ì•ŠìŒ
        const owner = [...reg.players][0]; // 0 or 1
        for (const {r,c} of reg.points){
          const cell = grid[r][c];
          if (!cell) continue;
          cell.classList.remove('movable');
          if (owner === 0) cell.classList.add('final-p1-region'); // ë¶„í™
          if (owner === 1) cell.classList.add('final-p2-region'); // í•˜ëŠ˜ìƒ‰
        }
      }
    }

    // ===== í„´ íƒ€ì´ë¨¸ =====
    function startTurnTimer(seconds){
      clearTurnTimer();
      turnDeadline = Date.now() + seconds * 1000;
      tickTimer(); // ì¦‰ì‹œ 1íšŒ í‘œì‹œ
      turnTimerId = setInterval(tickTimer, 200);
    }

    function clearTurnTimer(){
      if (turnTimerId){
        clearInterval(turnTimerId);
        turnTimerId = null;
      }
      timerEl.textContent = '';
    }

    function tickTimer(){
      const remainMs = Math.max(0, turnDeadline - Date.now());
      const sec = Math.ceil(remainMs / 1000);
      const mm = String(Math.floor(sec/60)).padStart(2,'0');
      const ss = String(sec%60).padStart(2,'0');
      timerEl.textContent = `${mm}:${ss}`;

      if (remainMs <= 0){
        clearTurnTimer();
        handleTurnTimeout();
      }
    }

    function handleTurnTimeout(){
      // ì‹œê°„ ì´ˆê³¼ ì‹œ: í˜„ì¬ í”Œë ˆì´ì–´ê°€ ì•„ë¬´ í–‰ë™ë„ ëª»í–ˆë”ë¼ë„
      // => ëœë¤ ë¹ˆ ë²½ ìë™ ì„¤ì¹˜ í›„ í„´ ë„˜ê¹€
      const placed = autoPlaceRandomWall();

      // ì ìˆ˜/ì¢…ë£Œ ì²´í¬
      const end = checkGameEndAndScore();
      if (end){
        playSafe(sndWin);
        setTimeout(showWinnerWithPaint, 50);
        return;
      }

      // ë²½ì´ í•˜ë‚˜ë„ ë‚¨ì§€ ì•Šì•˜ë‹¤ë©´ ê·¸ëƒ¥ í„´ë§Œ ë„˜ê¹€
      current = 1 - current;
      startMovePhase(true); // ë‹¤ìŒ í”Œë ˆì´ì–´ ì´ë™ 60ì´ˆ
    }

    // ===== ì˜¤ë””ì˜¤ UI =====
    function applyVolumeUI(volume, muted){
      allSounds.forEach(a => { a.volume = volume; a.muted = muted; });
      volSlider.value = String(volume);
      volVal.textContent = `${Math.round(volume*100)}%`;
      muteBtn.textContent = muted ? 'ğŸ”‡' : 'ğŸ”Š';
      muteBtn.setAttribute('aria-pressed', muted ? 'true' : 'false');
    }

    function restoreAudioPrefs(){
      const savedVol = parseFloat(localStorage.getItem('wb_vol') ?? '1');
      const savedMute = localStorage.getItem('wb_mute') === '1';
      applyVolumeUI(isNaN(savedVol)?1:savedVol, savedMute);
    }

    volSlider.addEventListener('input', (e)=>{
      const v = parseFloat(e.target.value);
      applyVolumeUI(v, muteBtn.getAttribute('aria-pressed')==='true');
      localStorage.setItem('wb_vol', String(v));
    });

    muteBtn.addEventListener('click', ()=>{
      const nowMuted = !(muteBtn.getAttribute('aria-pressed')==='true');
      applyVolumeUI(parseFloat(volSlider.value||'1'), nowMuted);
      localStorage.setItem('wb_mute', nowMuted ? '1' : '0');
    });

    // ===== ì´ë²¤íŠ¸ =====
    resetBtn.addEventListener('click', init);

    // ì´ˆê¸° ì‹œì‘
    init();
  </script>
</body>
</html>
