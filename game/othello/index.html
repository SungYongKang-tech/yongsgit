<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>오델로(온라인/혼자하기)</title>
  <style>
    :root{
      --cell: min(10.5vw, 56px);
      --gap: 1px;
      --board-size: calc(var(--cell)*8 + var(--gap)*9);
    }
    html { color-scheme: light only; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, "Noto Sans KR", sans-serif;
      margin:0; background:#f5f5f5; color:#222; text-align:center;
      display:flex; flex-direction:column; align-items:center; min-height:100dvh;
    }
    header{ width:100%; padding:12px 10px; background:#fff; border-bottom:1px solid #e5e7eb; position:sticky; top:0; z-index:3; }
    header h1{ margin:0; font-size:clamp(18px, 4.8vw, 26px); }
    .wrap{ width:100%; max-width:560px; padding:12px; }
    .card{ background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:12px; margin:10px auto; box-shadow:0 2px 8px rgba(0,0,0,.04); }
    .row{ display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; }
    input[type="text"]{ width:min(260px, 70vw); padding:10px 12px; border:1px solid #bbb; border-radius:8px; font-size:16px; }
    button{ padding:10px 14px; border:1px solid #999; border-radius:10px; background:#0d47a1; color:#fff; font-weight:600; }
    button.ghost{ background:#fff; color:#0d47a1; border-color:#0d47a1; }
    button:disabled{ opacity:.6; pointer-events:none; }
    .small{ font-size:13px; padding:8px 10px; }

    #infoBar{ display:grid; grid-template-columns:1fr 1fr; gap:6px; align-items:center; margin:6px 0 10px; }
    #infoBar .box{ background:#fafafa; border:1px solid #e5e7eb; border-radius:10px; padding:8px; font-size:14px; }
    #status{ font-weight:700; color:#0d47a1; }

    #boardWrap{ display:flex; justify-content:center; }
    #board{
      width:var(--board-size); height:var(--board-size);
      background:#2e7d32; padding:var(--gap);
      display:grid; grid-template-columns:repeat(8, var(--cell)); grid-template-rows:repeat(8, var(--cell));
      gap:var(--gap); border-radius:14px; box-shadow:inset 0 0 0 3px #1b5e20;
      touch-action: manipulation;
    }
    .cell{
      background:#3fa34d; position:relative; border:1px solid rgba(0,0,0,.2);
      display:flex; align-items:center; justify-content:center; cursor:pointer;
    }
    .cell::after{ content:""; position:absolute; inset:0; outline:1px solid rgba(0,0,0,.12); pointer-events:none; }
    .stone{
      width:calc(var(--cell)*0.74); height:calc(var(--cell)*0.74); border-radius:50%;
      box-shadow: inset 0 3px 10px rgba(0,0,0,.35), 0 1px 2px rgba(0,0,0,.25);
      transform:scale(0.98);
    }
    .black{ background: radial-gradient(circle at 30% 30%, #555 0%, #111 65%, #000 100%); }
    .white{ background: radial-gradient(circle at 30% 30%, #fff 0%, #e9e9e9 60%, #cfcfcf 100%); box-shadow: inset 0 1px 6px rgba(0,0,0,.18), 0 1px 2px rgba(0,0,0,.2); }
    .hint{ box-shadow: inset 0 0 0 3px rgba(255,255,0,.6) !important; }

    #actions{ display:flex; gap:8px; justify-content:center; margin:10px 0 4px; flex-wrap:wrap; }

    #toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(0,0,0,.8); color:#fff; padding:10px 14px; border-radius:10px; font-size:14px;
      opacity:0; pointer-events:none; transition:opacity .25s;
    }
    #toast.show{ opacity:1; }

    @media (min-width:720px){ :root{ --cell:56px; } }
  </style>
</head>
<body>
  <header><h1>오델로 · 온라인/혼자하기</h1></header>

  <div class="wrap">
    <!-- 로비 -->
    <section id="lobby" class="card">
      <div class="row" style="margin-bottom:8px;">
        <button id="createBtn">방 만들기</button>
        <input id="roomInput" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="방 코드(예: 824136)" />
        <button id="joinBtn" class="ghost">입장</button>
      </div>
      <div class="row" style="margin-bottom:8px;">
        <button id="soloBtn" class="ghost">혼자하기(고급 AI)</button>
        <button id="shareBtn" class="small">방 코드/링크 복사</button>
      </div>
      <div class="row">
        <span id="lobbyInfo" style="font-size:14px;color:#555;"></span>
      </div>
    </section>

    <!-- 게임 -->
    <section id="game" class="card" style="display:none;">
      <div id="infoBar">
        <div class="box">
          <div><b>모드</b>: <span id="modeLabel">-</span></div>
          <div><b>방</b>: <span id="roomCodeLabel">-</span></div>
        </div>
        <div class="box">
          <div><b>흑</b>: <span id="blackCount">2</span>  <b>백</b>: <span id="whiteCount">2</span></div>
          <div id="status">대기 중…</div>
        </div>
      </div>
      <div class="box" style="margin:-6px 0 10px; font-size:14px;">
        <b>내 역할:</b> <span id="roleLabel">-</span>
      </div>

      <div id="boardWrap"><div id="board" aria-label="오델로 보드"></div></div>

      <div id="actions">
        <button id="passBtn" class="small">패스</button>
        <button id="resetBtn" class="small">재시작</button>
        <button id="leaveBtn" class="small">나가기</button>
      </div>
    </section>
  </div>

  <div id="toast"></div>
  <audio id="sndPlace" src="button-29.mp3" preload="auto"></audio>

  <script type="module">
    /* =========================
       공통 로직 (보드/규칙/렌더)
       ========================= */
    const SIZE=8, EMPTY=0, BLACK=1, WHITE=2;
    const directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    const isOnBoard=(x,y)=>x>=0&&x<SIZE&&y>=0&&y<SIZE;
    const cloneBoard = (b)=> b.map(r=>r.slice());
    const initialBoard = ()=>{
      const b = Array.from({length:SIZE},()=>Array(SIZE).fill(EMPTY));
      b[3][3]=WHITE; b[4][4]=WHITE; b[3][4]=BLACK; b[4][3]=BLACK; return b;
    };
    const validMoves = (board, color)=>{
      const out=[];
      for(let x=0;x<SIZE;x++){
        for(let y=0;y<SIZE;y++){
          if(board[x][y]!==EMPTY) continue;
          for(const [dx,dy] of directions){
            let nx=x+dx, ny=y+dy, found=false;
            while(isOnBoard(nx,ny) && board[nx][ny]===3-color){ nx+=dx; ny+=dy; found=true; }
            if(found && isOnBoard(nx,ny) && board[nx][ny]===color){ out.push([x,y]); break; }
          }
        }
      }
      return out;
    };
    const applyMove = (board,x,y,color)=>{
      const nb = cloneBoard(board);
      nb[x][y]=color;
      for(const [dx,dy] of directions){
        let nx=x+dx, ny=y+dy; const path=[];
        while(isOnBoard(nx,ny) && nb[nx][ny]===3-color){ path.push([nx,ny]); nx+=dx; ny+=dy; }
        if(path.length && isOnBoard(nx,ny) && nb[nx][ny]===color){
          for(const [px,py] of path) nb[px][py]=color;
        }
      }
      return nb;
    };
    const countPieces=(board)=>{
      let b=0,w=0;
      for(let i=0;i<SIZE;i++) for(let j=0;j<SIZE;j++){
        if(board[i][j]===BLACK) b++; else if(board[i][j]===WHITE) w++;
      }
      return {b,w};
    };

    // PSQT(위치 가중치) & 코너/가동성 반영 (고급 AI)
    const PSQT = [
      [120,-20, 20,  5,  5, 20,-20,120],
      [-20,-40, -5, -5, -5, -5,-40,-20],
      [ 20, -5, 15,  3,  3, 15, -5, 20],
      [  5, -5,  3,  3,  3,  3, -5,  5],
      [  5, -5,  3,  3,  3,  3, -5,  5],
      [ 20, -5, 15,  3,  3, 15, -5, 20],
      [-20,-40, -5, -5, -5, -5,-40,-20],
      [120,-20, 20,  5,  5, 20,-20,120],
    ];
    const cornerPos = [[0,0],[0,7],[7,0],[7,7]];
    const xSquares = [[1,1],[1,6],[6,1],[6,6]];
    const cSquares = [[0,1],[1,0],[0,6],[1,7],[6,0],[7,1],[6,7],[7,6]];

    function evaluate(board, me){
      const opp = 3-me;
      let score=0, myDiscs=0, oppDiscs=0;

      for(let i=0;i<SIZE;i++){
        for(let j=0;j<SIZE;j++){
          const v = board[i][j];
          if(v===me){ score += PSQT[i][j]; myDiscs++; }
          else if(v===opp){ score -= PSQT[i][j]; oppDiscs++; }
        }
      }
      // mobility (가동성)
      const myMoves = validMoves(board, me).length;
      const opMoves = validMoves(board, opp).length;
      if(myMoves+opMoves !== 0) score += 8 * ( (myMoves - opMoves) / (myMoves + opMoves) );

      // corner control
      let myC=0, opC=0;
      for(const [x,y] of cornerPos){
        if(board[x][y]===me) myC++;
        else if(board[x][y]===opp) opC++;
      }
      score += 45 * (myC - opC);

      // X-/C- square penalty if corner not taken
      for(let k=0;k<4;k++){
        const [cx,cy]=cornerPos[k];
        const [xx,xy]=xSquares[k];
        const [ax,ay]=cSquares[2*k];
        const [bx,by]=cSquares[2*k+1];
        const cornerOwner = board[cx][cy];
        if(cornerOwner===EMPTY){
          if(board[xx][xy]===me) score -= 25;
          else if(board[xx][xy]===opp) score += 25;
          if(board[ax][ay]===me) score -= 10;
          else if(board[ax][ay]===opp) score += 10;
          if(board[bx][by]===me) score -= 10;
          else if(board[bx][by]===opp) score += 10;
        }
      }

      // parity (후반 디스크 우위 소폭)
      const discs = myDiscs + oppDiscs;
      if(discs > 48){ score += (myDiscs - oppDiscs) * 0.6; }

      return score;
    }

    /* ================
       UI 요소 참조
       ================ */
    const lobby = document.getElementById('lobby');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const soloBtn = document.getElementById('soloBtn');
    const roomInput = document.getElementById('roomInput');
    const shareBtn = document.getElementById('shareBtn');
    const lobbyInfo = document.getElementById('lobbyInfo');

    const game = document.getElementById('game');
    const modeLabel = document.getElementById('modeLabel');
    const roomCodeLabel = document.getElementById('roomCodeLabel');
    const roleLabel = document.getElementById('roleLabel');
    const statusEl = document.getElementById('status');
    const blackCountEl = document.getElementById('blackCount');
    const whiteCountEl = document.getElementById('whiteCount');
    const boardEl = document.getElementById('board');
    const passBtn = document.getElementById('passBtn');
    const resetBtn = document.getElementById('resetBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const sndPlace = document.getElementById('sndPlace');
    const toast = document.getElementById('toast');

    const showToast=(m)=>{ toast.textContent=m; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),1400); };

    /* =========================
       모드 상태 (online/solo)
       ========================= */
    let mode = 'online';            // 'online' | 'solo'
    let uid = null;                 // online에서만 의미
    let roomId = null;              // online에서만 의미
    let myColor = null;             // 공통 (1=흑, 2=백)
    let unsubRoom = null;           // online 구독 해제

    // 공통 렌더
    function renderBoard(board, turn){
      boardEl.innerHTML="";
      const moves = validMoves(board, myColor);
      const hintSet = new Set(moves.map(([x,y])=>`${x}-${y}`));
      for(let x=0;x<SIZE;x++){
        for(let y=0;y<SIZE;y++){
          const cell = document.createElement('div');
          cell.className='cell';
          cell.dataset.x=x; cell.dataset.y=y;
          if(board[x][y]===BLACK || board[x][y]===WHITE){
            const s = document.createElement('div');
            s.className = 'stone ' + (board[x][y]===BLACK?'black':'white');
            cell.appendChild(s);
          }else{
            if(turn===myColor && hintSet.has(`${x}-${y}`)) cell.classList.add('hint');
          }
          boardEl.appendChild(cell);
        }
      }
    }
    function setUICommon(room){
      const {b,w}=countPieces(room.board);
      blackCountEl.textContent=b; whiteCountEl.textContent=w;
      if(room.status==='ended'){
        let result='무승부'; if(b>w) result='흑 승!'; else if(w>b) result='백 승!';
        statusEl.textContent=`종료 · ${result} (흑:${b} 백:${w})`;
        passBtn.disabled = true;
      }else{
        const turnLabel = (room.turn===BLACK?'흑':'백');
        const mine = (room.turn===myColor);
        const passInfo = room.passCount?` · 연속패스:${room.passCount}`:'';
        statusEl.textContent=`진행중 · ${turnLabel} 차례${mine?' (내 턴)':''}${passInfo}`;
        passBtn.disabled = !(room.turn===myColor) || validMoves(room.board, myColor).length>0;
      }
      roleLabel.textContent = myColor===BLACK? '흑(선공)' : '백(후공)';
      renderBoard(room.board, room.turn);
    }
    async function playSound(){ try{ sndPlace.currentTime=0; await sndPlace.play(); }catch{} }

    /* =========================
       솔로 모드 (고급 AI)
       ========================= */
    let soloState = null; // {board, turn, status, passCount}

    function startSolo(){
      mode='solo'; roomId=null; myColor=BLACK;
      soloState = { board: initialBoard(), turn: BLACK, status:'playing', passCount:0 };
      modeLabel.textContent='혼자하기(고급 AI)';
      roomCodeLabel.textContent='-';
      showGame();
      setUICommon(soloState);
      maybeAI(); // 시작은 흑(사람)이므로 대기
    }

    function showGame(){
      lobby.style.display='none';
      game.style.display='';
    }
    function backToLobby(){
      if(unsubRoom){ unsubRoom(); unsubRoom=null; }
      mode='online'; roomId=null; myColor=null;
      game.style.display='none';
      lobby.style.display='';
    }

    // 고급 AI: iterative deepening + alpha-beta + move ordering
    function aiChooseMove(board, aiColor, timeLimitMs=1400){
      const start=performance.now();
      const opp=3-aiColor;
      let bestMove=null, bestScore=-1e9;
      let depth=2;                 // 초깊이
      const maxDepth=8;            // 최대 탐색 깊이
      const orderMoves = (b, color, moves)=>{
        // 코너 > 좋은 PSQT > 중앙, 대략적 정렬
        return moves.sort((a,bm)=>{
          const [ax,ay]=a,[bx,by]=bm;
          const ac = ( (ax===0||ax===7)&&(ay===0||ay===7) ) ? 1 : 0;
          const bc = ( (bx===0||bx===7)&&(by===0||by===7) ) ? 1 : 0;
          if(ac!==bc) return bc-ac;
          return PSQT[bx][by]-PSQT[ax][ay];
        });
      };
      const EVAL=(b)=>evaluate(b, aiColor);

      function alphabeta(b, color, d, alpha, beta){
        // 종료 조건
        const myMoves=validMoves(b, color);
        const opMoves=validMoves(b, 3-color);
        const discs=countPieces(b); const total=discs.b+discs.w;
        if(d===0 || total===64 || (myMoves.length===0 && opMoves.length===0)){
          return EVAL(b);
        }
        // 패스 처리
        if(myMoves.length===0){
          // 연속 패스 또는 상대도 없음 → 종료는 상단에서 잡힘
          return -alphabeta(b, 3-color, d-1, -beta, -alpha);
        }
        const ordered = orderMoves(b, color, myMoves);
        let val=-1e9;
        for(const [x,y] of ordered){
          const nb = applyMove(b,x,y,color);
          const sc = -alphabeta(nb, 3-color, d-1, -beta, -alpha);
          if(sc>val){ val=sc; }
          if(val>alpha) alpha=val;
          if(alpha>=beta) break;      // 가지치기
          // 시간 체크
          if(performance.now()-start > timeLimitMs) break;
        }
        return val;
      }

      // 반복 심화(시간 내 최선 갱신)
      while(depth<=maxDepth){
        if(performance.now()-start > timeLimitMs) break;
        const moves = validMoves(board, aiColor);
        if(moves.length===0) { bestMove=null; break; }
        // 전체 후보 정렬 후 탐색
        let localBest=null, localScore=-1e9;
        for(const [x,y] of moves){
          if(performance.now()-start > timeLimitMs) break;
          const nb = applyMove(board,x,y,aiColor);
          const sc = -alphabeta(nb, 3-aiColor, depth-1, -1e9, 1e9);
          if(sc>localScore){ localScore=sc; localBest=[x,y]; }
        }
        if(localBest){ bestMove=localBest; bestScore=localScore; }
        depth++;
      }
      return bestMove; // [x,y] or null(패스)
    }

    async function soloClickCell(x,y){
      if(!soloState || soloState.status!=='playing') return;
      if(soloState.turn!==myColor) return;

      const myMoves = validMoves(soloState.board, myColor);
      if(!myMoves.some(([xx,yy])=>xx===x&&yy===y)) return;

      soloState.board = applyMove(soloState.board, x,y, myColor);
      await playSound();
      // 상대(백=AI) 유효수 확인
      const next = 3-myColor;
      const vmNext = validMoves(soloState.board, next);
      const myNext = validMoves(soloState.board, myColor);
      if(vmNext.length===0 && myNext.length===0){
        soloState.status='ended'; soloState.passCount=2; setUICommon(soloState); return;
      }
      if(vmNext.length===0){ soloState.turn=myColor; soloState.passCount=(soloState.passCount||0)+1; }
      else{ soloState.turn=next; soloState.passCount=0; }
      setUICommon(soloState);
      maybeAI();
    }
    function maybeAI(){
      if(mode!=='solo' || !soloState || soloState.status!=='playing') return;
      if(soloState.turn!==WHITE) return; // AI는 백
      // 약간의 지연으로 UI 부하 완화
      setTimeout(()=>{
        const move = aiChooseMove(soloState.board, WHITE, 1400);
        if(!move){
          // AI 패스
          const myMoves = validMoves(soloState.board, BLACK);
          if(myMoves.length===0){
            soloState.status='ended'; soloState.passCount=(soloState.passCount||0)+1;
          }else{
            soloState.turn=BLACK; soloState.passCount=(soloState.passCount||0)+1;
          }
          setUICommon(soloState);
          return;
        }
        const [x,y]=move;
        soloState.board = applyMove(soloState.board, x,y, WHITE);
        playSound();
        const vmHuman = validMoves(soloState.board, BLACK);
        const vmAI = validMoves(soloState.board, WHITE);
        if(vmHuman.length===0 && vmAI.length===0){
          soloState.status='ended';
        }else if(vmHuman.length===0){
          // 사람 패스 → AI 연속
          soloState.turn=WHITE; soloState.passCount=(soloState.passCount||0)+1;
          setUICommon(soloState);
          // 연속 둠(시간 체크)
          setTimeout(maybeAI, 200);
          return;
        }else{
          soloState.turn=BLACK; soloState.passCount=0;
        }
        setUICommon(soloState);
      }, 200);
    }

    /* =========================
       온라인 모드(Firebase)
       ========================= */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import { getDatabase, ref, onValue, set, update, get, child, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCoHcYm0_fdpCcJbyh6PO60fjOZZKoR8xg",
      authDomain: "number-baseball-aee52.firebaseapp.com",
      databaseURL: "https://number-baseball-aee52-default-rtdb.firebaseio.com",
      projectId: "number-baseball-aee52",
      storageBucket: "number-baseball-aee52.firebasestorage.app",
      messagingSenderId: "998537150772",
      appId: "1:998537150772:web:6c0de75eee58c24691a561"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    const randCode=()=> String(Math.floor(100000 + Math.random()*900000));

    async function ensurePlayersSeat(roomRef){
      await runTransaction(child(roomRef,'players'), (players)=>{
        players = players || {};
        if(!players.black) players.black = uid;
        else if(!players.white && players.black!==uid) players.white=uid;
        return players;
      });
      const snap = await get(roomRef);
      const players = (snap.val()||{}).players||{};
      if(players.black===uid) myColor=BLACK;
      else if(players.white===uid) myColor=WHITE;
      else { alert('이 방은 이미 2명이 가득 찼습니다.'); return false; }
      return true;
    }

    function subscribeRoom(roomRef){
      if(unsubRoom) { unsubRoom(); unsubRoom=null; }
      unsubRoom = onValue(roomRef, (snap)=>{
        const room = snap.val(); if(!room) return;
        setUICommon(room);
      });
    }

    async function enterRoom(code){
      const roomRef = ref(db, `othelloRooms/${code}`);
      const s = await get(roomRef);
      if(!s.exists()){ showToast('방이 없습니다'); return; }
      roomId=code; roomCodeLabel.textContent=code; roomInput.value=code;
      const ok = await ensurePlayersSeat(roomRef);
      if(!ok){ roomId=null; return; }
      mode='online'; modeLabel.textContent='온라인 대전';
      showGame();
      subscribeRoom(roomRef);
      const url = new URL(location.href);
      url.searchParams.set('room', code);
      history.replaceState({},'',url.toString());
    }

    // UI 동작: 클릭
    boardEl.addEventListener('click', async (e)=>{
      const cell = e.target.closest('.cell'); if(!cell) return;
      const x=+cell.dataset.x, y=+cell.dataset.y;
      if(mode==='solo'){ await soloClickCell(x,y); return; }

      // online
      if(!roomId) return;
      const roomRef = ref(db, `othelloRooms/${roomId}`);
      const snap = await get(roomRef); const room=snap.val();
      if(!room || room.status!=='playing') return;
      if(room.turn!==myColor) return;
      const myMoves=validMoves(room.board, myColor);
      if(!myMoves.some(([xx,yy])=>xx===x&&yy===y)) return;

      const newBoard = applyMove(room.board, x,y, myColor);
      await playSound();
      const next = 3-myColor;
      const vmNext = validMoves(newBoard, next);
      const newStatus = (vmNext.length===0 && validMoves(newBoard, myColor).length===0) ? 'ended' : 'playing';
      const passCount = (vmNext.length===0) ? ((room.passCount||0)+1) : 0;

      await update(roomRef, {
        board: newBoard,
        turn: (vmNext.length>0? next : myColor),
        status: newStatus,
        passCount
      });
    });

    passBtn.onclick = async ()=>{
      if(mode==='solo'){
        if(!soloState || soloState.turn!==myColor) return;
        const myMoves = validMoves(soloState.board, myColor);
        if(myMoves.length>0){ showToast('둘 곳이 있습니다'); return; }
        const next=WHITE;
        const nextMoves = validMoves(soloState.board, next);
        if(nextMoves.length===0){ soloState.status='ended'; soloState.passCount=(soloState.passCount||0)+1; }
        else { soloState.turn=next; soloState.passCount=(soloState.passCount||0)+1; }
        setUICommon(soloState); maybeAI(); return;
      }
      // online
      if(!roomId) return;
      const roomRef = ref(db, `othelloRooms/${roomId}`);
      const snap = await get(roomRef); const room=snap.val();
      if(!room || room.turn!==myColor) return;
      if(validMoves(room.board, myColor).length>0){ showToast('둘 곳이 있습니다'); return; }
      const next = 3-myColor;
      const nextMoves = validMoves(room.board, next);
      const newStatus = (nextMoves.length===0)? 'ended':'playing';
      const passCount=(room.passCount||0)+1;
      await update(roomRef, { turn: next, status:newStatus, passCount });
    };

    resetBtn.onclick = async ()=>{
      if(mode==='solo'){
        startSolo(); showToast('재시작'); return;
      }
      if(!roomId) return;
      const roomRef = ref(db, `othelloRooms/${roomId}`);
      await update(roomRef, { board: initialBoard(), turn:BLACK, status:'playing', passCount:0, createdAt: serverTimestamp() });
      showToast('재시작');
    };

    leaveBtn.onclick = ()=>{ backToLobby(); showToast('나갔습니다'); };

    // 로비 버튼
    createBtn.onclick = async ()=>{
      try{
        const code = randCode();
        const roomRef = ref(db, `othelloRooms/${code}`);
        await set(roomRef, { createdAt: serverTimestamp(), status:'playing', board:initialBoard(), turn:BLACK, players:{}, passCount:0 });
        await enterRoom(code);
      }catch{ showToast('방 만들기 실패'); }
    };
    joinBtn.onclick = async ()=>{
      const code=(roomInput.value||'').trim();
      if(!/^\d{6}$/.test(code)){ showToast('6자리 숫자 코드'); return; }
      await enterRoom(code);
    };
    soloBtn.onclick = ()=> startSolo();

    shareBtn.onclick = async ()=>{
      if(mode==='online' && roomId){
        const url=`${location.origin}${location.pathname}?room=${roomId}`;
        try{ await navigator.clipboard.writeText(url); showToast('방 링크 복사됨'); }catch{ showToast('복사 실패'); }
      }else{
        const code=(roomInput.value||'').trim();
        if(/^\d{6}$/.test(code)){
          try{ await navigator.clipboard.writeText(code); showToast('방 코드 복사됨'); }catch{ showToast('복사 실패'); }
        }else{
          showToast('온라인 입장 후 사용 가능');
        }
      }
    };

    // 인증 후 URL ?room=XXXXXX 자동 입장 (온라인)
    onAuthStateChanged(getAuth(), async (user)=>{
      if(user){ uid=user.uid;
        const url=new URL(location.href); const code=url.searchParams.get('room');
        if(code && /^\d{6}$/.test(code)) await enterRoom(code);
      }else{
        try{ await signInAnonymously(getAuth()); }
        catch{ lobbyInfo.textContent='익명 로그인 실패'; }
      }
    });

    // 초기 안내
    lobbyInfo.textContent='온라인: 방 생성/입장 · 혼자하기: 고급 AI와 대전';
  </script>
</body>
</html>
