<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Wall-baduk (AI 대전)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
  :root {
    --bar-h: 60px;
    /* JS에서 동적으로 --p, --t를 설정합니다 */
    --p: 36px;                 /* 폴백 값 */
    --t: calc(var(--p) * 0.35);
  }
  * { box-sizing: border-box; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Pretendard, sans-serif;
    background:#f5f5f5; text-align:center; margin:0; min-height:100vh;
    display:grid; grid-template-rows:auto auto auto auto 1fr auto;
  }
  h1 { margin: 8px 0 4px; }

  /* 상단 패널 */
  #panel { margin:8px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
  #panel button { padding:10px 14px; border:1px solid #999; border-radius:10px; background:#fff; cursor:pointer; }

  #turnLine { margin:2px 0; font-size:16px; display:flex; gap:8px; justify-content:center; align-items:center; }
  #turnColor { font-weight:700; }
  #timer { font-variant-numeric: tabular-nums; padding:2px 6px; border:1px solid #ddd; border-radius:8px; background:#fff;
    min-width: 54px; display:inline-block; }
  #scores { margin:0 0 4px; font-size:14px; }

  /* 보드 */
  #wrap {
    display:flex; justify-content:center; align-items:flex-start;
    padding:0 10px 6px; overflow:hidden; /* 보드가 화면에 맞게 들어오도록 */
  }
  #board {
    display:grid; background:#fff; border:2px solid #333; user-select:none; touch-action:manipulation;
    /* 가로/세로 크기는 JS에서 보정 */
  }
  .cell { box-sizing:border-box; border:1px solid #000; display:flex; align-items:center; justify-content:center; }

  .point { width:var(--p); height:var(--p); background:#fff; position:relative; cursor:pointer; transition:background .1s; }
  .piece { width:80%; height:80%; border-radius:50%; pointer-events:none; }
  .h-wall { width:var(--p); height:var(--t); background:#fff; cursor:pointer; }
  .v-wall { width:var(--t); height:var(--p); background:#fff; cursor:pointer; }
  .blank  { width:var(--t); height:var(--t); background:#15326b; }

  .movable { background:#d0d0d0 !important; }
  .final-p1-region { background:#ffd6e7 !important; }
  .final-p2-region { background:#d6ecff !important; }

  #bottomBar {
    position:sticky; bottom:0; left:0; right:0; background:#ffffffcc; backdrop-filter:blur(6px);
    border-top:1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center; padding:6px 12px;
  }
  #skipWallBtn { width:min(340px,92vw); height:40px; border-radius:12px; font-weight:700; background:#ffd6e7; border:1px solid #e7a3bd; }
  button:disabled { opacity:.5; cursor:not-allowed; }

  /* 도움말 모달 */
  #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:10000; padding:16px; }
  #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
  #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
  #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
  #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
  #helpBody ul ul { margin-left:6px; padding-left:10px; }
  #helpBody li { margin:4px 0; }
  #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
  .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }

  @media (max-width:420px){
    /* 작은 화면에서 제목 여백 조금 축소 */
    h1 { margin:6px 0 2px; font-size:18px; }
  }
</style>
</head>
<body>
<h1>Wall-baduk (AI 대전)</h1>

<div id="panel">
  <button id="resetBtn">새로 시작</button>
  <button id="helpBtn" onclick="openHelp()">도움말</button>
  <button id="endBtn">게임 종료</button>
</div>

<div id="turnLine">현재 턴: <span id="turnColor"></span> <span id="timer"></span></div>
<div id="scores">P1(빨강): <span id="s1">0</span> / P2(파랑): <span id="s2">0</span></div>

<div id="wrap"><div id="board"></div></div>
<div id="bottomBar"><button id="skipWallBtn" disabled>이동 없이 벽 설치</button></div>

<!-- 도움말 -->
<div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div id="helpCard">
    <div id="helpHeader"><span id="helpTitle">게임 설명</span></div>
    <div id="helpBody">
      <ul>
        <li>말 이동은 상하좌우로 <b>최대 2칸</b> (벽은 통과 불가, 다른 말이 있는 점은 불가).</li>
        <li>이동 후 <b>벽 1개</b>를 설치합니다. (가로/세로 벽 칸)</li>
        <li>영역이 나뉘어 <b>단독 소유</b>인 점들의 합이 점수입니다.</li>
        <li>혼합 영역(양쪽 말이 섞인 구역)이 없으면 게임 종료!</li>
      </ul>
    </div>
    <div id="helpFooter"><button class="helpBtn" id="helpCloseBtn">시작하기</button></div>
  </div>
</div>

<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%2315326b'/%3E%3Ccircle cx='22' cy='22' r='10' fill='%23e74c3c'/%3E%3Ccircle cx='42' cy='42' r='10' fill='%233498db'/%3E%3C/svg%3E">

<script type="module">
/* DOM */
const boardEl   = document.getElementById('board');
const wrapEl    = document.getElementById('wrap');
const skipWallBtn = document.getElementById('skipWallBtn');
const turnEl    = document.getElementById('turnColor');
const s1El      = document.getElementById('s1');
const s2El      = document.getElementById('s2');
const resetBtn  = document.getElementById('resetBtn');
const endBtn    = document.getElementById('endBtn');

/* 오디오 */
const audioMal  = new Audio('mal.mp3');
const audioWall = new Audio('wall.mp3');
const audioWin  = new Audio('win.mp3');

/* 새로 시작 / 종료 */
resetBtn.addEventListener('click', () => {
  local.selected = null;
  local.prevWallCount = null;
  local.state = initialState();
  renderFromState();
});
endBtn.addEventListener('click', () => {
  if (!confirm('현재 상황으로 게임을 종료할까요?')) return;
  const { regions } = computeRegionsLocal();
  const sc = [0,0];
  for (const reg of regions) {
    if (reg.players.size === 1) {
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];
  local.state.phase = 'ended';
  fillFinalRegionsLocal();
  showWinnerWithPaintLocal();

  // index.html로 이동
  window.location.href = 'index.html';
});

/* 공통 상수/상태 */
const BOARD_POINTS = 7;
const GRID = BOARD_POINTS * 2 - 1;      // 7점 → 13그리드
const COLORS = ['#e74c3c', '#3498db'];  // P1 빨강 / P2 파랑
let grid = [];                           // 보드 셀 2차원 배열

/* 유틸 */
function randomChoice(arr){ return (arr && arr.length) ? arr[Math.floor(Math.random()*arr.length)] : null; }
function pt(p){ return (p-1)*2; }
const asArray = x => Array.isArray(x) ? x : (x && typeof x==='object') ? Object.values(x) : [];
function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
function isPoint(r,c){ return (r%2===0) && (c%2===0); }
function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }

/* ✅ 화면에 맞춰 보드 크기 자동 조절 */
function resizeBoard(){
  // 상단 요소 높이 합산
  const h1 = document.querySelector('h1')?.offsetHeight || 0;
  const panel = document.getElementById('panel')?.offsetHeight || 0;
  const turn = document.getElementById('turnLine')?.offsetHeight || 0;
  const scores = document.getElementById('scores')?.offsetHeight || 0;
  const bottom = document.getElementById('bottomBar')?.offsetHeight || 0;

  const verticalPadding = 16; // 여유
  const availableH = window.innerHeight - (h1 + panel + turn + scores + bottom) - verticalPadding;
  const availableW = wrapEl.clientWidth - 4; // 보더 여유

  // 한 칸 크기(px): 가로/세로 중 작은 쪽 기준
  let p = Math.floor(Math.min(availableW / GRID, availableH / GRID));

  // 너무 작아지지 않도록 하한선(원하면 조정 가능)
  p = Math.max(p, 22);

  // CSS 변수 반영
  document.documentElement.style.setProperty('--p', p + 'px');
  document.documentElement.style.setProperty('--t', (p * 0.35) + 'px');

  // 보드 외형 사이즈 고정(정사각)
  const size = p * GRID;
  boardEl.style.width = size + 'px';
  boardEl.style.height = size + 'px';
}

window.addEventListener('resize', () => { resizeBoard(); });
window.addEventListener('orientationchange', () => { setTimeout(resizeBoard, 50); });

/* 초기 상태 */
function initialState(){
  return {
    phase:'place-extra',
    current:0,                 // 0=사람(P1), 1=AI(P2)
    extraOrder:[0,1,1,0],
    extraIdx:0,
    pieces:{
      '0':[ {r:pt(2),c:pt(2)}, {r:pt(6),c:pt(6)} ],
      '1':[ {r:pt(6),c:pt(2)}, {r:pt(2),c:pt(6)} ]
    },
    walls:[],
    lastMoved:null
  };
}
function normalizeState(s){
  if(!s) return s;
  s.walls = asArray(s.walls);
  if(!s.pieces) s.pieces={'0':[],'1':[]};
  s.pieces['0']=asArray(s.pieces['0']);
  s.pieces['1']=asArray(s.pieces['1']);
  s.extraOrder=asArray(s.extraOrder||[0,1,1,0]);
  if (s.lastMoved && (typeof s.lastMoved.r!=='number' || typeof s.lastMoved.c!=='number')) s.lastMoved=null;
  return s;
}

/* 벽/이웃 탐색 (DOM 기반) */
function neighborsReachable(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;                 // 점 사이가 아니라면 이동 불가
    if(wall.classList.contains('placed')) continue;  // 이미 벽이 있으면 통과 불가
    if(grid[nr][nc].querySelector('.piece')) continue; // 도착점에 말 있으면 불가
    out.push({nr,nc});
  }
  return out;
}
function neighborsByWall(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;
    if(wall.classList.contains('placed')) continue; // 벽이 있으면 막힘
    out.push({nr,nc});
  }
  return out;
}

/* 배치/이동 후보 */
function allEmptyPoints(s){
  const occ = new Set();
  for (const pid of ['0','1']){
    for (const p of s.pieces[pid]) occ.add(`${p.r},${p.c}`);
  }
  const out=[];
  for (let r=0; r<GRID; r+=2){
    for (let c=0; c<GRID; c+=2){
      if (!occ.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}
function listMovable(s, sr, sc){
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true;
  const dest=[];
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')) dest.push({r,c});
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}
function adjacentEmptyWallsOfPoint(s, pr, pc){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const cand = [{r:pr-1,c:pc},{r:pr+1,c:pc},{r:pr,c:pc-1},{r:pr,c:pc+1}];
  return cand.filter(({r,c})=>{
    const inBoard = r>=0 && r<GRID && c>=0 && c<GRID;
    const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
    const free = !occupied.has(`${r},${c}`);
    return inBoard && isWallPos && free;
  });
}
function listEmptyWallsFromState(s){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const out=[];
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
      if(!isWallPos) continue;
      if(!occupied.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}

/* 보드 생성/렌더 */
function makeBoard() {
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
  boardEl.style.gridTemplateRows = `repeat(${GRID}, auto)`;
  grid = Array.from({ length: GRID }, () => Array(GRID).fill(null));

  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');

      if (r % 2 === 0 && c % 2 === 0) {
        cell.classList.add('point');
        cell.addEventListener('click', () => onPointClick(r, c));
      } else if (r % 2 === 1 && c % 2 === 0) {
        cell.classList.add('h-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else if (r % 2 === 0 && c % 2 === 1) {
        cell.classList.add('v-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else {
        cell.classList.add('blank');
      }

      boardEl.appendChild(cell);
      grid[r][c] = cell;
    }
  }
  // 최초 렌더 직후 보드 크기 계산
  resizeBoard();
}
function renderFromState() {
  const s = normalizeState(local.state);
  if (!s) return;

  const phaseLabel = s.phase === 'place-extra' ? ' — 말 배치'
                    : s.phase === 'move' ? ' — 말 이동'
                    : s.phase === 'wall' ? ' — 벽 설치'
                    : s.phase === 'ended' ? ' — 종료' : '';
  turnEl.textContent = ((s.current === 0) ? 'P1(빨강)' : 'P2(파랑)') + ' 차례' + phaseLabel;
  turnEl.style.color = COLORS[s.current];

  skipWallBtn.disabled = !(s.phase === 'move' && s.current === local.role);

  // 말
  document.querySelectorAll('.piece').forEach(el => el.remove());
  for (const pid of [0, 1]) {
    for (const p of s.pieces[String(pid)]) {
      const cell = grid[p.r]?.[p.c];
      if (!cell) continue;
      const dot = document.createElement('div');
      dot.classList.add('piece');
      dot.style.background = COLORS[pid];
      dot.dataset.player = String(pid);
      cell.appendChild(dot);
    }
  }

  // 벽
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = grid[r][c];
      if (!cell) continue;
      if (cell.classList.contains('h-wall') || cell.classList.contains('v-wall')) {
        cell.classList.remove('placed');
        cell.style.background = '#fff';
      }
    }
  }
  for (const w of s.walls) {
    const cell = grid[w.r]?.[w.c];
    if (cell) {
      cell.classList.add('placed');
      cell.style.background = COLORS[w.owner];
    }
  }

  updateScoresLocal();

  // 사이즈가 달라졌을 수 있으니 한 번 더 보정
  requestAnimationFrame(resizeBoard);

  // AI 차례 자동 처리
  if (s.current===1 && (s.phase==='place-extra' || s.phase==='move' || s.phase==='wall') && s.phase!=='ended') {
    setTimeout(aiTurn, 500);
  }
}

/* 상호작용 */
function onPointClick(r, c) {
  const s = normalizeState(local.state);
  if (!s) return;

  // 배치 단계
  if (s.phase === 'place-extra') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    if (cell.querySelector('.piece')) return;
    s.pieces[String(s.current)].push({ r, c });
    audioMal.play();
    s.extraIdx++;
    if (s.extraIdx >= s.extraOrder.length) {
      s.phase = 'move';
    } else {
      s.current = s.extraOrder[s.extraIdx];
    }
    renderFromState();
    return;
  }

  // 이동 단계
  if (s.phase === 'move') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    const piece = cell.querySelector('.piece');

    if (local.selected && local.selected.r === r && local.selected.c === c) {
      local.selected = null;
      clearMovable();
      return;
    }

    if (!local.selected && piece && +piece.dataset.player === local.role) {
      local.selected = { r, c };
      const cnt = showMovableFrom(r, c);
      if (cnt === 0) {
        local.selected = null;
        clearMovable();
      }
      return;
    }

    if (local.selected && cell.classList.contains('movable')) {
      const arr = s.pieces[String(local.role)];
      const idx = arr.findIndex(p => p.r === local.selected.r && p.c === local.selected.c);
      if (idx >= 0) {
        arr[idx] = { r, c };
        audioMal.play();
        s.phase = 'wall';
        s.lastMoved = { r, c };
        clearMovable();
        local.selected = null;
        renderFromState(); // 벽 단계로 전환
      }
    }
  }
}
function showMovableFrom(sr,sc){
  clearMovable();
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true; let cnt=0;
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
      grid[r][c].classList.add('movable'); cnt++;
    }
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return cnt;
}
function onWallClick(r, c) {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'wall' || s.current !== local.role) return;
  const cell = grid[r][c];
  const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
  if (!isWall || cell.classList.contains('placed')) return;

  s.walls.push({ r, c, owner: local.role });
  audioWall.play();
  s.current = 1 - s.current;
  s.phase = 'move';
  s.lastMoved = null;
  clearMovable();
  renderFromState();
}
skipWallBtn.addEventListener('click', () => {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'move' || s.current !== local.role) return;
  clearMovable();
  local.selected = null;
  s.phase = 'wall';
  s.lastMoved = null;
  renderFromState();
});

/* ===== 점수/종료 ===== */
function computeRegionsLocal() {
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const regions = [];
  let hasMixed = false;

  for (let r = 0; r < GRID; r += 2) {
    for (let c = 0; c < GRID; c += 2) {
      if (visited[r][c]) continue;
      const q = [{ r, c }];
      visited[r][c] = true;
      const pts = [];
      const present = new Set();
      while (q.length) {
        const cur = q.shift();
        pts.push(cur);
        const piece = grid[cur.r][cur.c].querySelector('.piece');
        if (piece) present.add(+piece.dataset.player);
        for (const { nr, nc } of neighborsByWall(cur.r, cur.c)) {
          if (!visited[nr][nc]) {
            visited[nr][nc] = true;
            q.push({ r: nr, c: nc });
          }
        }
      }
      if (present.size >= 2) hasMixed = true;
      regions.push({ points: pts, players: present });
    }
  }
  return { regions, hasMixed };
}
function updateScoresLocal(){
  const ended = checkGameEndAndScoreLocal();
  if (ended && local.state?.phase !== 'ended'){
    local.state.phase = 'ended';
    showWinnerWithPaintLocal();
  }
}
function checkGameEndAndScoreLocal(){
  const { regions, hasMixed } = computeRegionsLocal();
  const sc = [0, 0];
  for (const reg of regions){
    if (reg.players.size === 1){
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];
  return !hasMixed;
}
function fillFinalRegionsLocal(){
  const { regions } = computeRegionsLocal();
  for (const reg of regions){
    if (reg.players.size !== 1) continue;
    const owner = [...reg.players][0];
    for (const { r, c } of reg.points){
      grid[r][c].classList.remove('movable');
      if (owner === 0) grid[r][c].classList.add('final-p1-region');
      else grid[r][c].classList.add('final-p2-region');
    }
  }
}
function showWinnerWithPaintLocal(){
  audioWin.play();
  fillFinalRegionsLocal();
  const p1 = +s1El.textContent, p2 = +s2El.textContent;
  alert(
    `게임 종료!\nP1(빨강): ${p1} / P2(파랑): ${p2}\n` +
    (p1>p2 ? '승자: P1(빨강)' : p2>p1 ? '승자: P2(파랑)' : '무승부')
  );
}

/* ====== AI 로직 (강화 휴리스틱) ====== */
function keyRC(r,c){ return `${r},${c}`; }
function wallKey(wr,wc){ return `w:${wr},${wc}`; }
function pointsNeighborsByWalls(wallsSet, r, c){
  const out=[], dirs=[[-2,0],[2,0],[0,-2],[0,2]];
  for(const [dr,dc] of dirs){
    const nr=r+dr, nc=c+dc;
    if(nr<0||nr>=GRID||nc<0||nc>=GRID||nr%2||nc%2) continue;
    const wr=r+dr/2, wc=c+dc/2;
    if(wallsSet.has(wallKey(wr,wc))) continue;
    out.push([nr,nc]);
  }
  return out;
}
function listMovableState(wallsSet, occSet, sr, sc){
  const v = new Set([keyRC(sr,sc)]), q=[{r:sr,c:sc,d:0}], dest=[];
  while(q.length){
    const {r,c,d} = q.shift();
    if(d>0 && d<=2 && !occSet.has(keyRC(r,c))) dest.push({r,c});
    if(d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,r,c)){
      const k = keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}
function mobilityAtState(wallsSet, occSet, r, c){
  const v = new Set([keyRC(r,c)]), q=[{r,c,d:0}]; let cnt=0;
  while(q.length){
    const cur = q.shift();
    if(cur.d>0 && cur.d<=2 && !occSet.has(keyRC(cur.r,cur.c))) cnt++;
    if(cur.d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cur.r,cur.c)){
      const k=keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:cur.d+1}); }
    }
  }
  return cnt;
}
function regionsFromState(wallsSet, p0Set, p1Set){
  const visited = new Set(), regs=[];
  for(let r=0;r<GRID;r+=2){
    for(let c=0;c<GRID;c+=2){
      const start = keyRC(r,c);
      if(visited.has(start)) continue;
      const q=[[r,c]]; visited.add(start);
      const points=[]; let has0=false, has1=false;
      while(q.length){
        const [cr,cc]=q.shift();
        points.push([cr,cc]);
        const k=keyRC(cr,cc);
        if(p0Set.has(k)) has0=true;
        if(p1Set.has(k)) has1=true;
        for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cr,cc)){
          const nk=keyRC(nr,nc);
          if(!visited.has(nk)){ visited.add(nk); q.push([nr,nc]); }
        }
      }
      regs.push({points, has0, has1});
    }
  }
  return regs;
}
function territoryDiffAfter(ws, p0Set, p1Set){
  const regs = regionsFromState(ws,p0Set,p1Set);
  let me=0, opp=0;
  for(const reg of regs){
    if(reg.has0 && !reg.has1) opp+=reg.points.length;
    else if(reg.has1 && !reg.has0) me+=reg.points.length;
  }
  return me - opp;
}

/* 난이도 가중치 (원하면 'hard','medium','easy'로 바꿔 사용 가능) */
const level = 'hard';
const W_TERR   = {easy:1.0, medium:1.4, hard:1.8}[level];
const W_TRAP   = {easy:0.8, medium:1.2, hard:1.8}[level];
const W_MOB    = {easy:0.6, medium:0.9, hard:1.2}[level];
const W_CLASH  = {easy:0.6, medium:0.8, hard:1.0}[level];

function evaluateMovePlusBestWall(s, pieceFrom, moveTo){
  const wallsSet = new Set(s.walls.map(w=>wallKey(w.r,w.c)));
  const p0Set = new Set(s.pieces['0'].map(p=>keyRC(p.r,p.c)));
  const p1 = s.pieces['1'].map(p=>({r:p.r,c:p.c}));
  const idx = p1.findIndex(pp => pp.r===pieceFrom.r && pp.c===pieceFrom.c);
  p1[idx] = {r:moveTo.r, c:moveTo.c};
  const p1Set = new Set(p1.map(p=>keyRC(p.r,p.c)));

  const occForMob = new Set([...p0Set, ...p1Set]);
  const myMob = mobilityAtState(wallsSet, occForMob, moveTo.r, moveTo.c);

  // 상대 기동력 (전/후) 비교
  let oppMobBefore=0, oppMobAfter=0;
  for(const k of p0Set){
    const [r,c] = k.split(',').map(Number);
    oppMobBefore += mobilityAtState(wallsSet, occForMob, r, c);
  }

  // 벽 후보: 이동지 인접 우선, 없으면 전체
  let candWalls = [];
  for(const [wr,wc] of [[moveTo.r-1,moveTo.c],[moveTo.r+1,moveTo.c],[moveTo.r,moveTo.c-1],[moveTo.r,moveTo.c+1]]){
    const isWallPos = wr>=0&&wr<GRID&&wc>=0&&wc<GRID && ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
    if(isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr,c:wc});
  }
  if(candWalls.length===0){
    for(let wr=0;wr<GRID;wr++) for(let wc=0;wc<GRID;wc++){
      const isWallPos = ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
      if(isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr,c:wc});
    }
  }

  let bestScore=-Infinity, bestWall=null;
  for(const w of candWalls){
    const ws = new Set(wallsSet); ws.add(wallKey(w.r,w.c));
    const terrDiff = territoryDiffAfter(ws, p0Set, p1Set);

    oppMobAfter = 0;
    for(const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      oppMobAfter += mobilityAtState(ws, occForMob, r, c);
    }
    const trapGain = Math.max(0, oppMobBefore - oppMobAfter);

    // 충돌 위험(상대와 너무 붙으면 페널티)
    let minOpp=Infinity;
    for(const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      const d = Math.abs(r - moveTo.r) + Math.abs(c - moveTo.c);
      if(d<minOpp) minOpp=d;
    }
    const clashPenalty = Math.max(0, 3 - (isFinite(minOpp)?minOpp:99));

    const score = W_TERR*terrDiff + W_TRAP*trapGain + W_MOB*myMob - W_CLASH*clashPenalty;
    if(score>bestScore){ bestScore=score; bestWall=w; }
  }
  return {score: bestScore, bestWall};
}

function aiTurn(){
  const s = normalizeState(local.state);
  if (!s || s.current !== 1) return;

  if (s.phase === 'place-extra') aiPlaceExtra(s);
  else if (s.phase === 'move') aiMove(s);
  else if (s.phase === 'wall') aiPlaceWall(s);

  renderFromState();
}
function aiPlaceExtra(s){
  const points = allEmptyPoints(s);
  const pick = randomChoice(points);
  s.pieces['1'].push({r:pick.r,c:pick.c});
  s.extraIdx++;
  if(s.extraIdx >= s.extraOrder.length) s.phase='move';
  else s.current = s.extraOrder[s.extraIdx];
}
function listMovableStateForDOM(s, r, c){
  return listMovable(s, r, c);
}
function aiMove(s){
  const myPieces = s.pieces['1'];
  let best=null, bestScore=-Infinity, bestWall=null;

  for(const p of myPieces){
    const moves = listMovableStateForDOM(s, p.r, p.c);
    for(const m of moves){
      const {score, bestWall:wallChoice} = evaluateMovePlusBestWall(s, p, m);
      if(score>bestScore){ bestScore=score; best={from:p, to:m}; bestWall=wallChoice; }
    }
  }

  if(best){
    const arr = s.pieces['1'];
    const idx = arr.findIndex(pp=>pp.r===best.from.r && pp.c===best.from.c);
    arr[idx] = { r:best.to.r, c:best.to.c };
    s.phase = 'wall';
    s.lastMoved = { r:best.to.r, c:best.to.c };
    audioMal.play();
    s._aiPlannedWall = bestWall;
  }else{
    s.phase='wall';
    s.lastMoved=null;
  }
}
function aiPlaceWall(s){
  let pick = s._aiPlannedWall || null;
  if(!pick){
    let candidates = [];
    if (s.lastMoved) candidates = adjacentEmptyWallsOfPoint(s, s.lastMoved.r, s.lastMoved.c);
    if (candidates.length === 0) candidates = listEmptyWallsFromState(s);
    pick = candidates && candidates.length ? candidates[0] : null;
  }
  if(pick) s.walls.push({ r:pick.r, c:pick.c, owner:1 });
  audioWall.play();

  delete s._aiPlannedWall;
  s.current = 0; s.phase = 'move'; s.lastMoved = null;
}

/* 도움말 오버레이 */
function openHelp(){ document.getElementById('helpOverlay').style.display='flex'; }
function closeHelp(){ document.getElementById('helpOverlay').style.display='none'; }
window.openHelp = openHelp; window.closeHelp = closeHelp;
document.getElementById('helpCloseBtn')?.addEventListener('click', closeHelp);
document.getElementById('helpOverlay')?.addEventListener('click', (e)=>{
  if (e.target.id==='helpOverlay') closeHelp();
});

/* 로컬 컨트롤러 */
let local = { role:0, state:null, selected:null, prevWallCount:null };

/* 시작 */
makeBoard();
local.state = initialState();
renderFromState();
</script>
</body>
</html>
