<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Wall-baduk (AI 대전)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
  :root {
    --bar-h: 60px;
    --p: min(42px, calc((100vw - 20px) / 13)); /* 13칸 그리드에 맞춤 */
    --t: calc(var(--p) * 0.35); /* 점 크기의 비율로 벽 두께 */
  }
  body { font-family: sans-serif; background:#f5f5f5; text-align:center; margin:0; min-height:100vh;
    display:grid; grid-template-rows:auto auto auto auto auto; }
  h1 { margin: 8px 0 4px; }

  /* 상단 패널 */
  #panel { margin:8px 0 6px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
  #panel button { padding:5px 14px; border:1px solid #999; border-radius:10px; background:#fff; cursor:pointer; }

  #turnLine { margin:2px 0; font-size:16px; display:flex; gap:8px; justify-content:center; align-items:center; }
  #turnColor { font-weight:700; }
  #timer { font-variant-numeric: tabular-nums; padding:2px 6px; border:1px solid #ddd; border-radius:8px; background:#fff;
    min-width: 54px; display:inline-block; }
  #scores { margin:0 0 4px; font-size:14px; }

   /* 보드 */
    #wrap { display:flex; justify-content:center; align-items:flex-start; padding:0 10px 6px; overflow:auto; }
    #board { display:grid; background:#fff; border:2px solid #333; user-select:none; touch-action:manipulation; }
    .cell { box-sizing:border-box; border:1px solid #000; display:flex; align-items:center; justify-content:center; }

    .point { width:var(--p); height:var(--p); background:#fff; position:relative; cursor:pointer; transition:background .1s; }
    .piece { width:80%; height:80%; border-radius:50%; pointer-events:none; }
    .h-wall { width:var(--p); height:var(--t); background:#fff; cursor:pointer; }
    .v-wall { width:var(--t); height:var(--p); background:#fff; cursor:pointer; }
    .blank  { width:var(--t); height:var(--t); background:#15326b; }

    .movable { background:#d0d0d0 !important; }
    .final-p1-region { background:#ffd6e7 !important; }
    .final-p2-region { background:#d6ecff !important; }

    #bottomBar { position:sticky; bottom:0; left:0; right:0; background:#ffffffcc; backdrop-filter:blur(6px);
      border-top:1px solid #ddd; display:flex; gap:10px; align-items:center; justify-content:center; padding:6px 12px; }
    #skipWallBtn { width:min(340px,92vw); height:40px; border-radius:12px; font-weight:700; background:#ffd6e7; border:1px solid #e7a3bd; }
    button:disabled { opacity:.5; cursor:not-allowed; }


  /* 도움말 모달 */
  #helpOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:10000; padding:16px; }
  #helpCard { width:100%; max-width:560px; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.2); text-align:left; overflow:hidden; }
  #helpHeader { padding:14px 18px; background:#222; color:#fff; font-weight:800; }
  #helpBody { padding:14px 18px; color:#222; line-height:1.5; font-size:15px; }
  #helpBody ul { margin:6px 0 0 8px; padding-left:12px; }
  #helpBody ul ul { margin-left:6px; padding-left:10px; }
  #helpBody li { margin:4px 0; }
  #helpFooter { display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; background:#fafafa; }
  .helpBtn { padding:10px 14px; border:1px solid #ccc; border-radius:10px; background:#fff; cursor:pointer; }

  @media (max-width:420px){ #volSlider { width:120px; } }
</style>
</head>
<body>
<h1>Wall-baduk (AI 대전)</h1>

<div id="panel">
  <button id="resetBtn">새로 시작</button>
  <button id="helpBtn" onclick="openHelp()">도움말</button>
  <button id="endBtn">게임 종료</button>
</div>

<div id="turnLine">현재 턴: <span id="turnColor"></span> <span id="timer"></span></div>
<div id="scores">P1(빨강): <span id="s1">0</span> / P2(파랑): <span id="s2">0</span></div>

<div id="wrap"><div id="board"></div></div>
<div id="bottomBar"><button id="skipWallBtn" disabled>이동 없이 벽 설치</button></div>

<!-- 도움말 -->
<div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div id="helpCard">
    <div id="helpHeader"><span id="helpTitle">게임 설명</span></div>
    <div id="helpBody">
      <ul>
        <li>말 이동은 상하좌우로 <b>최대 2칸</b> (벽은 통과 불가, 다른 말이 있는 점은 불가).</li>
        <li>이동 후 <b>벽 1개</b>를 설치합니다. (가로/세로 벽 칸)</li>
        <li>영역이 나뉘어 <b>단독 소유</b>인 점들의 합이 점수입니다.</li>
        <li>혼합 영역(양쪽 말이 섞인 구역)이 없으면 게임 종료!</li>
      </ul>
    </div>
    <div id="helpFooter"><button class="helpBtn" id="helpCloseBtn">시작하기</button></div>
  </div>
</div>

<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%2315326b'/%3E%3Ccircle cx='22' cy='22' r='10' fill='%23e74c3c'/%3E%3Ccircle cx='42' cy='42' r='10' fill='%233498db'/%3E%3C/svg%3E">

<script type="module">
  // ==== 전역 에러 트랩 (로딩 직후 예외 원인 즉시 표시) ====
window.addEventListener('error', (e) => {
  console.error('[WINDOW ERROR]', e?.error || e);
  alert('스크립트 오류(동기):\n' + (e?.error?.message || e?.message || e));
});
window.addEventListener('unhandledrejection', (e) => {
  console.error('[PROMISE ERROR]', e?.reason || e);
  alert('스크립트 오류(비동기):\n' + (e?.reason?.message || e?.reason || e));
});

/* DOM */
const boardEl   = document.getElementById('board');
const skipWallBtn = document.getElementById('skipWallBtn');
const turnEl    = document.getElementById('turnColor');
const s1El      = document.getElementById('s1');
const s2El      = document.getElementById('s2');
const resetBtn  = document.getElementById('resetBtn');
const endBtn    = document.getElementById('endBtn');

/* 오디오 */
const audioMal  = new Audio('mal.mp3');
const audioWall = new Audio('wall.mp3');
const audioWin  = new Audio('win.mp3');

function safePlay(audio){
  try{
    if (!audio) return;
    audio.currentTime = 0;
    const p = audio.play?.();
    if (p && typeof p.catch === 'function') p.catch(()=>{});
  }catch(e){}
}

/* 새로 시작 / 종료 */
resetBtn.addEventListener('click', () => {
  local.selected = null;
  local.prevWallCount = null;
  local.state = initialState();
  renderFromState();
});
endBtn.addEventListener('click', () => {
  if (!confirm('현재 상황으로 게임을 종료할까요?')) return;
  const { regions } = computeRegionsLocal();
  const sc = [0,0];
  for (const reg of regions) {
    if (reg.players.size === 1) {
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];
  local.state.phase = 'ended';
  fillFinalRegionsLocal();
  showWinnerWithPaintLocal();
  // 단일 파일: 새로 시작은 reset 버튼으로, 여기서는 화면 유지

   // index.html로 이동
  window.location.href = 'index.html';
});

/* 공통 상수/상태 */
const BOARD_POINTS = 7;
const GRID = BOARD_POINTS * 2 - 1;      // 7점 → 13그리드
const COLORS = ['#e74c3c', '#3498db'];  // P1 빨강 / P2 파랑
let grid = [];                           // 보드 셀 2차원 배열

/* 유틸 */
function randomChoice(arr){ return (arr && arr.length) ? arr[Math.floor(Math.random()*arr.length)] : null; }
function pt(p){ return (p-1)*2; }
const asArray = x => Array.isArray(x) ? x : (x && typeof x==='object') ? Object.values(x) : [];
function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
function isPoint(r,c){ return (r%2===0) && (c%2===0); }
function clearMovable(){ document.querySelectorAll('.movable').forEach(el=>el.classList.remove('movable')); }

/* 초기 상태 */
function initialState(){
  return {
    phase:'place-extra',
    current:0,                 // 0=사람(P1), 1=AI(P2)
    extraOrder:[0,1,1,0],
    extraIdx:0,
    pieces:{
      '0':[ {r:pt(2),c:pt(2)}, {r:pt(6),c:pt(6)} ],
      '1':[ {r:pt(6),c:pt(2)}, {r:pt(2),c:pt(6)} ]
    },
    walls:[],
    lastMoved:null
  };
}
function normalizeState(s){
  if(!s) return s;
  s.walls = asArray(s.walls);
  if(!s.pieces) s.pieces={'0':[],'1':[]};
  s.pieces['0']=asArray(s.pieces['0']);
  s.pieces['1']=asArray(s.pieces['1']);
  s.extraOrder=asArray(s.extraOrder||[0,1,1,0]);
  if (s.lastMoved && (typeof s.lastMoved.r!=='number' || typeof s.lastMoved.c!=='number')) s.lastMoved=null;
  return s;
}

/* 벽/이웃 탐색 (DOM 기반) */
function neighborsReachable(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;                 // 점 사이가 아니라면 이동 불가
    if(wall.classList.contains('placed')) continue;  // 이미 벽이 있으면 통과 불가
    if(grid[nr][nc].querySelector('.piece')) continue; // 도착점에 말 있으면 불가
    out.push({nr,nc});
  }
  return out;
}
function neighborsByWall(r,c){
  const dirs=[{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}], out=[];
  for(const {dr,dc} of dirs){
    const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)||!isPoint(nr,nc)) continue;
    const wr=r+dr/2, wc=c+dc/2; const wall=grid[wr]?.[wc];
    const isWallPos = wall && (wall.classList.contains('h-wall')||wall.classList.contains('v-wall'));
    if(!isWallPos) continue;
    if(wall.classList.contains('placed')) continue; // 벽이 있으면 막힘
    out.push({nr,nc});
  }
  return out;
}

/* 배치/이동 후보 */
function allEmptyPoints(s){
  const occ = new Set();
  for (const pid of ['0','1']){
    for (const p of s.pieces[pid]) occ.add(`${p.r},${p.c}`);
  }
  const out=[];
  for (let r=0; r<GRID; r+=2){
    for (let c=0; c<GRID; c+=2){
      if (!occ.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}
function listMovable(s, sr, sc){
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true;
  const dest=[];
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')) dest.push({r,c});
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}
function adjacentEmptyWallsOfPoint(s, pr, pc){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const cand = [{r:pr-1,c:pc},{r:pr+1,c:pc},{r:pr,c:pc-1},{r:pr,c:pc+1}];
  return cand.filter(({r,c})=>{
    const inBoard = r>=0 && r<GRID && c>=0 && c<GRID;
    const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
    const free = !occupied.has(`${r},${c}`);
    return inBoard && isWallPos && free;
  });
}
function listEmptyWallsFromState(s){
  const occupied = new Set(s.walls.map(w=>`${w.r},${w.c}`));
  const out=[];
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      const isWallPos = (r%2===1 && c%2===0) || (r%2===0 && c%2===1);
      if(!isWallPos) continue;
      if(!occupied.has(`${r},${c}`)) out.push({r,c});
    }
  }
  return out;
}

/* 보드 생성/렌더 */
function makeBoard() {
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${GRID}, auto)`;
  boardEl.style.gridTemplateRows = `repeat(${GRID}, auto)`;
  grid = Array.from({ length: GRID }, () => Array(GRID).fill(null));

  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');

      if (r % 2 === 0 && c % 2 === 0) {
        cell.classList.add('point');
        cell.addEventListener('click', () => onPointClick(r, c));
      } else if (r % 2 === 1 && c % 2 === 0) {
        cell.classList.add('h-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else if (r % 2 === 0 && c % 2 === 1) {
        cell.classList.add('v-wall');
        cell.addEventListener('click', () => onWallClick(r, c));
      } else {
        cell.classList.add('blank');
      }

      boardEl.appendChild(cell);
      grid[r][c] = cell;
    }
  }
}
function renderFromState() {
  const s = normalizeState(local.state);
  if (!s) return;

  const phaseLabel = s.phase === 'place-extra' ? ' — 말 배치'
                    : s.phase === 'move' ? ' — 말 이동'
                    : s.phase === 'wall' ? ' — 벽 설치'
                    : s.phase === 'ended' ? ' — 종료' : '';
  turnEl.textContent = ((s.current === 0) ? 'P1(빨강)' : 'P2(파랑)') + ' 차례' + phaseLabel;
  turnEl.style.color = COLORS[s.current];

  skipWallBtn.disabled = !(s.phase === 'move' && s.current === local.role);

  // 말 렌더
  document.querySelectorAll('.piece').forEach(el => el.remove());
  for (const pid of [0, 1]) {
    for (const p of s.pieces[String(pid)]) {
      const cell = grid[p.r]?.[p.c];
      if (!cell) continue;
      const dot = document.createElement('div');
      dot.classList.add('piece');
      dot.style.background = COLORS[pid];
      dot.dataset.player = String(pid);
      cell.appendChild(dot);
    }
  }

  // 벽 렌더
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = grid[r][c];
      if (!cell) continue;
      if (cell.classList.contains('h-wall') || cell.classList.contains('v-wall')) {
        cell.classList.remove('placed');
        cell.style.background = '#fff';
      }
    }
  }
  for (const w of s.walls) {
    const cell = grid[w.r]?.[w.c];
    if (cell) {
      cell.classList.add('placed');
      cell.style.background = COLORS[w.owner];
    }
  }

  updateScoresLocal();

  // AI 차례 자동 처리 (여기! s가 준비된 뒤에 호출)
  if (s.current===1 && (s.phase==='place-extra' || s.phase==='move' || s.phase==='wall') && s.phase!=='ended') {
    setTimeout(aiTurn, 300);
  }
}


/* 상호작용 */
function onPointClick(r, c) {
  const s = normalizeState(local.state);
  if (!s) return;

  // 배치 단계
  if (s.phase === 'place-extra') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    if (cell.querySelector('.piece')) return;
    s.pieces[String(s.current)].push({ r, c });
    audioMal.play();
    s.extraIdx++;
    if (s.extraIdx >= s.extraOrder.length) {
      s.phase = 'move';
    } else {
      s.current = s.extraOrder[s.extraIdx];
    }
    renderFromState();
    return;
  }

  // 이동 단계
  if (s.phase === 'move') {
    if (s.current !== local.role) return;
    const cell = grid[r][c];
    const piece = cell.querySelector('.piece');

    if (local.selected && local.selected.r === r && local.selected.c === c) {
      local.selected = null;
      clearMovable();
      return;
    }

    if (!local.selected && piece && +piece.dataset.player === local.role) {
      local.selected = { r, c };
      const cnt = showMovableFrom(r, c);
      if (cnt === 0) {
        local.selected = null;
        clearMovable();
      }
      return;
    }

    if (local.selected && cell.classList.contains('movable')) {
      const arr = s.pieces[String(local.role)];
      const idx = arr.findIndex(p => p.r === local.selected.r && p.c === local.selected.c);
      if (idx >= 0) {
        arr[idx] = { r, c };
        audioMal.play();
        s.phase = 'wall';
        s.lastMoved = { r, c };
        clearMovable();
        local.selected = null;
        renderFromState(); // 벽 단계로 전환
      }
    }
  }
}
function showMovableFrom(sr,sc){
  clearMovable();
  const v=Array.from({length:GRID},()=>Array(GRID).fill(false));
  const q=[{r:sr,c:sc,d:0}]; v[sr][sc]=true; let cnt=0;
  while(q.length){
    const {r,c,d}=q.shift();
    if(d>0 && d<=2 && isPoint(r,c) && !grid[r][c].querySelector('.piece')){
      grid[r][c].classList.add('movable'); cnt++;
    }
    if(d===2) continue;
    for(const {nr,nc} of neighborsReachable(r,c)){
      if(!v[nr][nc]){ v[nr][nc]=true; q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return cnt;
}
function onWallClick(r, c) {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'wall' || s.current !== local.role) return;
  const cell = grid[r][c];
  const isWall = cell.classList.contains('h-wall') || cell.classList.contains('v-wall');
  if (!isWall || cell.classList.contains('placed')) return;

  s.walls.push({ r, c, owner: local.role });
  audioWall.play();
  s.current = 1 - s.current;
  s.phase = 'move';
  s.lastMoved = null;
  clearMovable();
  renderFromState();
}
skipWallBtn.addEventListener('click', () => {
  const s = normalizeState(local.state);
  if (!s || s.phase !== 'move' || s.current !== local.role) return;
  clearMovable();
  local.selected = null;
  s.phase = 'wall';
  s.lastMoved = null;
  renderFromState();
});

/* ===== 점수/종료 ===== */
function computeRegionsLocal() {
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const regions = [];
  let hasMixed = false;

  for (let r = 0; r < GRID; r += 2) {
    for (let c = 0; c < GRID; c += 2) {
      if (visited[r][c]) continue;
      const q = [{ r, c }];
      visited[r][c] = true;
      const pts = [];
      const present = new Set();
      while (q.length) {
        const cur = q.shift();
        pts.push(cur);
        const piece = grid[cur.r][cur.c].querySelector('.piece');
        if (piece) present.add(+piece.dataset.player);
        for (const { nr, nc } of neighborsByWall(cur.r, cur.c)) {
          if (!visited[nr][nc]) {
            visited[nr][nc] = true;
            q.push({ r: nr, c: nc });
          }
        }
      }
      if (present.size >= 2) hasMixed = true;
      regions.push({ points: pts, players: present });
    }
  }
  return { regions, hasMixed };
}
function updateScoresLocal(){
  const ended = checkGameEndAndScoreLocal();
  if (ended && local.state?.phase !== 'ended'){
    local.state.phase = 'ended';
    showWinnerWithPaintLocal();
  }
}
function checkGameEndAndScoreLocal(){
  const { regions, hasMixed } = computeRegionsLocal();
  const sc = [0, 0];
  for (const reg of regions){
    if (reg.players.size === 1){
      const owner = [...reg.players][0];
      sc[owner] += reg.points.length;
    }
  }
  s1El.textContent = sc[0];
  s2El.textContent = sc[1];
  return !hasMixed;
}
function fillFinalRegionsLocal(){
  const { regions } = computeRegionsLocal();
  for (const reg of regions){
    if (reg.players.size !== 1) continue;
    const owner = [...reg.players][0];
    for (const { r, c } of reg.points){
      grid[r][c].classList.remove('movable');
      if (owner === 0) grid[r][c].classList.add('final-p1-region');
      else grid[r][c].classList.add('final-p2-region');
    }
  }
}
function showWinnerWithPaintLocal(){
  audioWin.play();
  fillFinalRegionsLocal();
  const p1 = +s1El.textContent, p2 = +s2El.textContent;
  alert(
    `게임 종료!\nP1(빨강): ${p1} / P2(파랑): ${p2}\n` +
    (p1>p2 ? '승자: P1(빨강)' : p2>p1 ? '승자: P2(파랑)' : '무승부')
  );
}

/* ====== AI 로직 (강화 휴리스틱) ====== */
/* 상태 전용 유틸(시뮬) */
function keyRC(r,c){ return `${r},${c}`; }
function wallKey(wr,wc){ return `w:${wr},${wc}`; }
function pointsNeighborsByWalls(wallsSet, r, c){
  const out=[], dirs=[[-2,0],[2,0],[0,-2],[0,2]];
  for(const [dr,dc] of dirs){
    const nr=r+dr, nc=c+dc;
    if(nr<0||nr>=GRID||nc<0||nc>=GRID||nr%2||nc%2) continue;
    const wr=r+dr/2, wc=c+dc/2;
    if(wallsSet.has(wallKey(wr,wc))) continue;
    out.push([nr,nc]);
  }
  return out;
}
function listMovableState(wallsSet, occSet, sr, sc){
  const v = new Set([keyRC(sr,sc)]), q=[{r:sr,c:sc,d:0}], dest=[];
  while(q.length){
    const {r,c,d} = q.shift();
    if(d>0 && d<=2 && !occSet.has(keyRC(r,c))) dest.push({r,c});
    if(d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,r,c)){
      const k = keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:d+1}); }
    }
  }
  return dest;
}
function mobilityAtState(wallsSet, occSet, r, c){
  const v = new Set([keyRC(r,c)]), q=[{r,c,d:0}]; let cnt=0;
  while(q.length){
    const cur = q.shift();
    if(cur.d>0 && cur.d<=2 && !occSet.has(keyRC(cur.r,cur.c))) cnt++;
    if(cur.d===2) continue;
    for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cur.r,cur.c)){
      const k=keyRC(nr,nc);
      if(!v.has(k)){ v.add(k); q.push({r:nr,c:nc,d:cur.d+1}); }
    }
  }
  return cnt;
}
function regionsFromState(wallsSet, p0Set, p1Set){
  const visited = new Set(), regs=[];
  for(let r=0;r<GRID;r+=2){
    for(let c=0;c<GRID;c+=2){
      const start = keyRC(r,c);
      if(visited.has(start)) continue;
      const q=[[r,c]]; visited.add(start);
      const points=[]; let has0=false, has1=false;
      while(q.length){
        const [cr,cc]=q.shift();
        points.push([cr,cc]);
        const k=keyRC(cr,cc);
        if(p0Set.has(k)) has0=true;
        if(p1Set.has(k)) has1=true;
        for(const [nr,nc] of pointsNeighborsByWalls(wallsSet,cr,cc)){
          const nk=keyRC(nr,nc);
          if(!visited.has(nk)){ visited.add(nk); q.push([nr,nc]); }
        }
      }
      regs.push({points, has0, has1});
    }
  }
  return regs;
}
function territoryDiffAfter(ws, p0Set, p1Set){
  const regs = regionsFromState(ws,p0Set,p1Set);
  let me=0, opp=0;
  for(const reg of regs){
    if(reg.has0 && !reg.has1) opp+=reg.points.length;
    else if(reg.has1 && !reg.has0) me+=reg.points.length;
  }
  return me - opp;
}

// === 추가 가중치 (간단 버전) ===
const W_SEAL_A = 2.2;  // 밀봉: 내 단독영역 '점수' 증가 보너스
const W_SEAL_B = 1.2;  // 밀봉: 혼합영역 개수 감소 보너스
const W_DIST   = 0.9;  // 말 분산(평균 거리) 보너스
const W_CENT   = 0.6;  // 중앙 근접 보너스
const W_FRONT  = 0.7;  // 프론티어(이동지 주변에 벽이 아직 없는 방향 수) 보너스

// ==== 경량 유틸 (간단 보너스 계산) ====

// 평균 맨해튼 거리(말들이 흩어지면 값↑)
function avgPairwiseManhattan(pointsArr){
  const arr = Array.from(pointsArr, p => ({r: p.r, c: p.c}));
  const n = arr.length;
  if (n < 2) return 0;
  let sum = 0, cnt = 0;
  for (let i=0;i<n;i++){
    for (let j=i+1;j<n;j++){
      sum += Math.abs(arr[i].r - arr[j].r) + Math.abs(arr[i].c - arr[j].c);
      cnt++;
    }
  }
  return sum / cnt;
}

// 중앙 보너스: 중심에 가까울수록 큼 (정규화)
function centerBonus(r, c){
  const mid = (GRID - 1) / 2;
  const dist = Math.abs(r - mid) + Math.abs(c - mid);
  const maxDist = (GRID - 1); // 대략적 상한
  return (maxDist - dist) / maxDist; // 0~1
}

// 프론티어 보너스: 이동 위치 주변 4방향 중 아직 '벽이 안 놓인' 방향 수(0~4)를 0~1로 정규화
function frontierBonus(r, c, wallsSet){
  let free = 0, total = 0;
  const cand = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
  for (const [wr, wc] of cand){
    const inBoard = wr>=0 && wr<GRID && wc>=0 && wc<GRID;
    const isWallPos = inBoard && ((wr%2===1 && wc%2===0) || (wr%2===0 && wc%2===1));
    if (!isWallPos) continue;
    total++;
    if (!wallsSet.has(wallKey(wr, wc))) free++;
  }
  return total ? free / total : 0;
}
// === 기본 가중치(필수): 기존 코드에서 누락된 상수 복구 ===
const W_TERR  = 1.4;  // 단독영역 차(나-상대)
const W_TRAP  = 1.2;  // 상대 기동력 감소(함정)
const W_MOB   = 0.8;  // 내 기동력
const W_CLASH = 0.8;  // 과도한 근접 패널티

// 범용 평가(이동 to + 그 후 최적 벽 1개) — moverId: 0(사람), 1(AI)
function evalForMover(s, moverId, pieceFrom, moveTo){
  const wallsSet = new Set(s.walls.map(w=>wallKey(w.r,w.c)));

  // 말 배열 복사 후 mover의 그 말 이동 반영
  const myArr  = s.pieces[String(moverId)].map(p=>({r:p.r,c:p.c}));
  const oppArr = s.pieces[String(1-moverId)].map(p=>({r:p.r,c:p.c}));
  const idx = myArr.findIndex(pp => pp.r===pieceFrom.r && pp.c===pieceFrom.c);
  if (idx < 0) return {score:-1e9, bestWall:null};
  myArr[idx] = { r:moveTo.r, c:moveTo.c };

  const mySet  = new Set(myArr.map(p=>keyRC(p.r,p.c)));
  const oppSet = new Set(oppArr.map(p=>keyRC(p.r,p.c)));
  const occForMob = new Set([...mySet, ...oppSet]);

  // 내 기동력
  const myMob = mobilityAtState(wallsSet, occForMob, moveTo.r, moveTo.c);

  // 상대 기동력(벽 전)
  let oppMobBefore = 0;
  for(const k of oppSet){
    const [r,c] = k.split(',').map(Number);
    oppMobBefore += mobilityAtState(wallsSet, occForMob, r, c);
  }

  // 이동만 반영한 상태에서의 기준값(혼합/단독)
  const regsBefore = regionsFromState(wallsSet, oppSet, mySet);
  const mixedBefore = regsBefore.filter(r => r.has0 && r.has1).length;
  const myExclusiveBefore = regsBefore
    .filter(r => r.has1 && !r.has0)
    .reduce((acc, r) => acc + r.points.length, 0);

  // 벽 후보(이동지 인접 우선, 없으면 전체)
  let candWalls = [];
  for (const [wr, wc] of [[moveTo.r-1,moveTo.c],[moveTo.r+1,moveTo.c],[moveTo.r,moveTo.c-1],[moveTo.r,moveTo.c+1]]){
    const isWallPos = wr>=0&&wr<GRID&&wc>=0&&wc<GRID && ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
    if (isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr, c:wc});
  }
  if (candWalls.length === 0){
    for (let wr=0; wr<GRID; wr++){
      for (let wc=0; wc<GRID; wc++){
        const isWallPos = ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
        if (isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr, c:wc});
      }
    }
  }
  if (!candWalls.length) return {score:-1e9, bestWall:null};

  // 분산·중앙·프론티어 (이동 위치 기준)
  const myAvgDist  = avgPairwiseManhattan(myArr);
  const oppAvgDist = avgPairwiseManhattan(oppArr);
  const distTerm = myAvgDist - oppAvgDist;
  const cent  = centerBonus(moveTo.r, moveTo.c);
  const front = frontierBonus(moveTo.r, moveTo.c, wallsSet);

  let bestScore=-Infinity, bestWall=null;
  for(const w of candWalls){
    const ws = new Set(wallsSet); ws.add(wallKey(w.r,w.c));

    // 단독영역 차: (mover가 '1'인 것으로 가정된 기존 함수와 동일 구조가 되도록)
    const terrDiff = territoryDiffAfter(ws, oppSet, mySet);

    // 상대 기동력 감소
    let oppMobAfter=0;
    for(const k of oppSet){
      const [r,c] = k.split(',').map(Number);
      oppMobAfter += mobilityAtState(ws, occForMob, r, c);
    }
    const trapGain = Math.max(0, oppMobBefore - oppMobAfter);

    // 밀봉 효과
    const regsAfter = regionsFromState(ws, oppSet, mySet);
    const mixedAfter = regsAfter.filter(r => r.has0 && r.has1).length;
    const myExclusiveAfter = regsAfter
      .filter(r => r.has1 && !r.has0)
      .reduce((acc, r) => acc + r.points.length, 0);
    const mixedToPureDelta = Math.max(0, mixedBefore - mixedAfter);
    const sealedPointsGain = Math.max(0, myExclusiveAfter - myExclusiveBefore);

    // 근접 패널티
    let minOpp = Infinity;
    for(const k of oppSet){
      const [r,c] = k.split(',').map(Number);
      const d = Math.abs(r - moveTo.r) + Math.abs(c - moveTo.c);
      if (d < minOpp) minOpp = d;
    }
    const clashPenalty = Math.max(0, 3 - (isFinite(minOpp)?minOpp:99));

    const score =
        W_TERR  * terrDiff
      + W_SEAL_A* sealedPointsGain
      + W_SEAL_B* mixedToPureDelta
      + W_TRAP  * trapGain
      + W_MOB   * myMob
      - W_CLASH * clashPenalty
      + W_DIST  * distTerm
      + W_CENT  * cent
      + W_FRONT * front;

    if (score > bestScore){ bestScore = score; bestWall = w; }
  }
  return {score: bestScore, bestWall};
}


function evaluateMovePlusBestWall(s, pieceFrom, moveTo){
  // 현재 벽/말 상태 세트 구성
  const wallsSet = new Set(s.walls.map(w=>wallKey(w.r,w.c)));
  const p0Set = new Set(s.pieces['0'].map(p=>keyRC(p.r,p.c)));

  // 내 말 배열/세트(이동 반영)
  const p1Arr = s.pieces['1'].map(p=>({r:p.r,c:p.c}));
  const idx = p1Arr.findIndex(pp => pp.r===pieceFrom.r && pp.c===pieceFrom.c);
  p1Arr[idx] = {r:moveTo.r, c:moveTo.c};
  const p1Set = new Set(p1Arr.map(p=>keyRC(p.r,p.c)));

  // 공통 사전 계산(벽 고르기 전)
  const occForMob = new Set([...p0Set, ...p1Set]);
  const myMob = mobilityAtState(wallsSet, occForMob, moveTo.r, moveTo.c);

  // 분산(평균 맨해튼 거리): 내 말↑, 상대↓이면 유리
  // 상대는 p0Set을 배열로 변환
  const p0Arr = Array.from(p0Set, k => { const [r,c]=k.split(',').map(Number); return {r,c}; });
  const myAvgDist  = avgPairwiseManhattan(p1Arr);
  const oppAvgDist = avgPairwiseManhattan(p0Arr);
  const distTerm = myAvgDist - oppAvgDist; // 상대보다 더 흩어지면 +

  // 중앙·프론티어 보너스(벽과 무관, 이동 위치만으로 산정)
  const cent = centerBonus(moveTo.r, moveTo.c);
  const front = frontierBonus(moveTo.r, moveTo.c, wallsSet);

  // 상대 기동력(벽 전/후) 비교용: 먼저 이전값
  let oppMobBefore = 0;
  for (const k of p0Set){
    const [r,c] = k.split(',').map(Number);
    oppMobBefore += mobilityAtState(wallsSet, occForMob, r, c);
  }

  // 밀봉 보너스 계산을 위한 "이동만 반영된 상태"의 기준값(벽 놓기 전)
  const regsBefore = regionsFromState(wallsSet, p0Set, p1Set);
  const mixedBefore = regsBefore.filter(r => r.has0 && r.has1).length;
  const myExclusiveBefore = regsBefore
    .filter(r => r.has1 && !r.has0)
    .reduce((acc, r) => acc + r.points.length, 0);

  // 벽 후보(이동지 인접 우선, 없으면 전체)
  let candWalls = [];
  for (const [wr, wc] of [[moveTo.r-1,moveTo.c],[moveTo.r+1,moveTo.c],[moveTo.r,moveTo.c-1],[moveTo.r,moveTo.c+1]]){
    const isWallPos = wr>=0&&wr<GRID&&wc>=0&&wc<GRID && ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
    if (isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr, c:wc});
  }
  if (candWalls.length === 0){
    for (let wr=0; wr<GRID; wr++){
      for (let wc=0; wc<GRID; wc++){
        const isWallPos = ((wr%2===1&&wc%2===0)||(wr%2===0&&wc%2===1));
        if (isWallPos && !wallsSet.has(wallKey(wr,wc))) candWalls.push({r:wr, c:wc});
      }
    }
  }

let bestScore = -Infinity, bestWall = null;
if (!candWalls.length) return { score: -1e9, bestWall: null };


  // 각 벽 후보 평가
  for (const w of candWalls){
    // 가상으로 벽을 추가
    const ws = new Set(wallsSet); ws.add(wallKey(w.r,w.c));

    // 기본 테리토리(현재 코드와 호환)
    const terrDiff = territoryDiffAfter(ws, p0Set, p1Set); // (나-상대) 단독영역 차

    // 상대 기동력 감소(함정)
    let oppMobAfter = 0;
    for (const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      oppMobAfter += mobilityAtState(ws, occForMob, r, c);
    }
    const trapGain = Math.max(0, oppMobBefore - oppMobAfter);

    // 밀봉(혼합→단독) 보너스: 혼합영역 감소 + 내 단독영역 증가량
    const regsAfter = regionsFromState(ws, p0Set, p1Set);
    const mixedAfter = regsAfter.filter(r => r.has0 && r.has1).length;
    const myExclusiveAfter = regsAfter
      .filter(r => r.has1 && !r.has0)
      .reduce((acc, r) => acc + r.points.length, 0);
    const mixedToPureDelta = Math.max(0, mixedBefore - mixedAfter);
    const sealedPointsGain = Math.max(0, myExclusiveAfter - myExclusiveBefore);

    // 충돌(과도한 근접) 패널티: 상대와의 최소 맨해튼 거리 2 미만일 때 불이익
    let minOpp = Infinity;
    for (const k of p0Set){
      const [r,c] = k.split(',').map(Number);
      const d = Math.abs(r - moveTo.r) + Math.abs(c - moveTo.c);
      if (d < minOpp) minOpp = d;
    }
    const clashPenalty = Math.max(0, 3 - (isFinite(minOpp) ? minOpp : 99)); // 2 이하면 패

    // 최종 점수 (간단·가벼운 강화판)
    const score =
        W_TERR  * terrDiff
      + W_SEAL_A* sealedPointsGain
      + W_SEAL_B* mixedToPureDelta
      + W_TRAP  * trapGain
      + W_MOB   * myMob
      - W_CLASH * clashPenalty
      + W_DIST  * distTerm
      + W_CENT  * cent
      + W_FRONT * front;

    if (score > bestScore){
      bestScore = score;
      bestWall = w;
    }
  }

  return { score: bestScore, bestWall };
}


function aiTurn(){
  try{
    const s = normalizeState(local.state);
    if (!s || s.current !== 1 || s.phase==='ended') return;

    if (s.phase === 'place-extra') aiPlaceExtra(s);
    else if (s.phase === 'move') aiMove(s);
    else if (s.phase === 'wall') aiPlaceWall(s);

    renderFromState();
  }catch(err){
    console.error('[AI ERROR]', err);
    alert('AI 처리 중 오류:\n' + (err?.message || err));
    if (local?.state){ // 안전 복구
      local.state.current = 0;
      local.state.phase = 'move';
      renderFromState();
    }
  }
}

function aiPlaceExtra(s){
  // 내/상대 말 좌표 수집
  const my = s.pieces['1'];
  const opp = s.pieces['0'];
  const cand = allEmptyPoints(s);

  // 간단한 점수: 중앙 보너스 + 내 말과의 분산 + 상대 말과의 견제 거리
  let best = null, bestScore = -Infinity;
  for(const p of cand){
    // 중앙 보너스 (기존 함수 재사용)
    const cent = centerBonus(p.r, p.c);

    // 내 말과의 평균 거리(뭉치지 않게)
    let myDist = 0;
    if (my.length){
      for (const m of my) myDist += Math.abs(m.r - p.r) + Math.abs(m.c - p.c);
      myDist /= my.length;
    }

    // 상대와의 평균 거리(초반에 너무 붙지 않게 약간 띄움)
    let oppDist = 0;
    if (opp.length){
      for (const o of opp) oppDist += Math.abs(o.r - p.r) + Math.abs(o.c - p.c);
      oppDist /= opp.length;
    }

    const score = 0.7*cent + 0.25*(myDist/(GRID)) + 0.05*(oppDist/(GRID));
    if (score > bestScore){ bestScore = score; best = p; }
  }

  const pick = best || randomChoice(cand);
  s.pieces['1'].push({r:pick.r,c:pick.c});
  s.extraIdx++;
  if(s.extraIdx >= s.extraOrder.length) s.phase='move';
  else s.current = s.extraOrder[s.extraIdx];
}

function listMovableStateForDOM(s, r, c){
  // DOM 기반 이동 후보 (현재 보드 상태)
  return listMovable(s, r, c);
}
function aiMove(s){
  const K_MY = 4;     // 내(인공지능) 후보 상위 N
  const K_OPP = 3;    // 상대(사람) 응수 상위 N
  const TIME_BUDGET_MS = 25;
  const t0 = Date.now();

  const myPieces = s.pieces['1'];
  let cand = [];

  // 1단계: 내 모든 이동을 1수 평가로 스코어링 → 상위 K_MY만 유지
  for(const p of myPieces){
    const moves = listMovableStateForDOM(s, p.r, p.c);
    for(const m of moves){
      const {score, bestWall} = evalForMover(s, 1, p, m); // mover=1 (AI)
      cand.push({from:p, to:m, score1:score, wall1:bestWall});
    }
  }
  cand.sort((a,b)=>b.score1 - a.score1);
  if (cand.length > K_MY) cand = cand.slice(0, K_MY);

  // 2단계: 각 후보에 대해, 그 수를 둔 뒤 상대의 최선 응수(상위 K_OPP 탐색)로 페널티
  let best = null, bestScore = -Infinity;
  for (const c of cand){
    if (Date.now() - t0 > TIME_BUDGET_MS) break;

    // 가상 적용: 내 말 이동 + 내 벽(최선)
    const sim = JSON.parse(JSON.stringify(s)); // 얕은 복사로 충분
    // 말 이동
    const arr = sim.pieces['1'];
    const idx = arr.findIndex(pp => pp.r===c.from.r && pp.c===c.from.c);
    if (idx < 0) continue;
    arr[idx] = { r:c.to.r, c:c.to.c };
    // 벽 배치(있으면)
    if (c.wall1) sim.walls.push({ r:c.wall1.r, c:c.wall1.c, owner:1 });

    // 상대 응수 후보
    const oppPieces = sim.pieces['0'];
    let oppCand = [];
    for(const op of oppPieces){
      const moves2 = listMovableStateForDOM(sim, op.r, op.c);
      for(const m2 of moves2){
        const {score:oppScore} = evalForMover(sim, 0, op, m2); // mover=0 (사람)
        oppCand.push({from:op, to:m2, oppScore});
      }
    }
    oppCand.sort((a,b)=>b.oppScore - a.oppScore);
    if (oppCand.length > K_OPP) oppCand = oppCand.slice(0, K_OPP);

    // 미니맥스: 내 점수에서 상대 최선(들)의 평균/최대 중 택1 (보수적으로 최대 사용)
    const worstReply = oppCand.length ? oppCand[0].oppScore : 0;
    const finalScore = c.score1 - 0.8*worstReply; // 상대 응수 반영 가중치(0.6~1.0 사이 조절)

    if (finalScore > bestScore){
      bestScore = finalScore;
      best = { from:c.from, to:c.to, wall:c.wall1 };
    }
  }

  if(best){
    const arr = s.pieces['1'];
    const idx = arr.findIndex(pp=>pp.r===best.from.r && pp.c===best.from.c);
    arr[idx] = { r:best.to.r, c:best.to.c };
    s.phase = 'wall';
    s.lastMoved = { r:best.to.r, c:best.to.c };
    safePlay(audioMal);
    s._aiPlannedWall = best.wall;
  }else{
    // 시간이 다 소모됐거나 이동 불가 → 벽 단계로 전환
    s.phase='wall';
    s.lastMoved=null;
  }
}

function aiPlaceWall(s){
  let pick = s._aiPlannedWall || null;

  if(!pick){
    let candidates = [];
    if (s.lastMoved) candidates = adjacentEmptyWallsOfPoint(s, s.lastMoved.r, s.lastMoved.c);
    if (candidates.length === 0) candidates = listEmptyWallsFromState(s);
    pick = candidates && candidates.length ? candidates[0] : null;
  }

  if (pick) {
    s.walls.push({ r:pick.r, c:pick.c, owner:1 });
    safePlay(audioWall);
  }

  delete s._aiPlannedWall;
  s.current = 0;
  s.phase = 'move';
  s.lastMoved = null;
}


/* 도움말 오버레이 */
function openHelp(){ document.getElementById('helpOverlay').style.display='flex'; }
function closeHelp(){ document.getElementById('helpOverlay').style.display='none'; }
window.openHelp = openHelp; window.closeHelp = closeHelp;
document.getElementById('helpCloseBtn')?.addEventListener('click', closeHelp);
document.getElementById('helpOverlay')?.addEventListener('click', (e)=>{
  if (e.target.id==='helpOverlay') closeHelp();
});

/* 로컬 컨트롤러 */
let local = { role:0, state:null, selected:null, prevWallCount:null };

/* 시작 */
makeBoard();
local.state = initialState();
renderFromState();
</script>
</body>
</html>
